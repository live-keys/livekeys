#include "linecontrol.h"
#include "qmath.h"
#include "textedit_p.h"
#include <QQmlProperty>
#include <queue>

namespace lv {

std::function<bool(LineControl::LineSection, LineControl::LineSection)>
    LineControl::LineSection::compareLines = [](LineSection a, LineSection b)->bool {
        return a.lineNumber < b.lineNumber;
    };

std::function<bool(LineControl::LineSection, LineControl::LineSection)>
    LineControl::LineSection::compareDisplayLines = [](LineSection a, LineSection b)->bool {
        return a.displayLineNumber < b.displayLineNumber;
    };

std::function<bool(LineControl::LineSection, LineControl::LineSection)>
    LineControl::LineSection::compareStartPositions = [](LineSection a, LineSection b)->bool {
        return a.startPosition < b.startPosition;
    };

LineControl::LineControl(QObject *parent) :
          QObject(parent)
        , m_blockHeight(0)
        , m_firstDirtyLine(0)
        , m_prevLineNumber(0)
        , m_lineNumber(0)
        , m_maxWidth(0)
{
    if (!parent) m_textEdit = new TextEdit(nullptr, true);
    else m_textEdit = static_cast<TextEdit*>(parent);

    QObject::connect(m_textEdit, &TextEdit::lineCountChanged, this, &LineControl::lineCountChanged);
}

/**
 * \brief Adds a line section which starts at line `pos`, ending on line `pos + num`.
 * This section's `displayLineSpan` is 1 (third parameter in the constructor),
 * because the only visible line is the first one.
 * \returns Offset generated by the insertion operation
 */
int LineControl::addCollapse(int pos, int num)
{
    LineSection ls(pos, num + 1, 1, LineSection::Collapsed);

    if (m_textEdit &&
        m_textEdit->code() &&
        m_textEdit->code()->textDocument()){

        auto doc = m_textEdit->code()->textDocument();

        ls.startPosition = doc->findBlockByNumber(pos).position();
        ls.endPosition = doc->findBlockByNumber(pos + num).position() + doc->findBlockByNumber(pos + num).length() - 1;
    }

    return addLineSection(ls);
}

/**
 * \brief Removes `Collapsed` line section at given position
 * \returns Offset generated by the removal operation
 */
int LineControl::removeCollapse(int pos)
{
    return removeLineSection(LineSection(pos, 0, 0, LineSection::Collapsed), false);
}

/**
 * \brief Adds a palette given by its position `pos`, the number of lines of code it's replacing
 * given by `span`, its item `p`, as well as start and end position of the code that it's replacing.
 * If it's a "fake palette", i.e. a `Fragment` used to hide lines of code at the beginning and the
 * end of the viewport, its height is 0.
 */
void LineControl::addPalette(int pos, int span, QQuickItem *p, int startPos, int endPos)
{   
    LineSection ls;
    ls.lineNumber = pos;
    ls.lineSpan = span;
    ls.type = static_cast<int>(p->height()) == 0 ? LineSection::Fragment : LineSection::Palette;
    ls.palette = p;
    ls.displayLineSpan = qCeil((p->height() > 0 ? p->height() + 10 : 0)*1.0/ m_blockHeight);

    ls.paletteWidth = static_cast<int>(p->width());
    ls.startPosition = startPos;
    ls.endPosition = endPos;

    addLineSection(ls);

    emit refreshAfterPaletteChange(pos+span-1, ls.lineSpanDelta());
}

/**
 * \brief This function reacts to an external resize of the palette height.
 * This potentially creates offset which needs to be applied to all
 * sections after it
 */
void LineControl::resizePaletteHeight(QQuickItem *p)
{
    auto it = m_sections.begin();
    for (; it != m_sections.end(); ++it)
        if (it->type == LineSection::Palette && it->palette == p) break;

    if (it == m_sections.end()) return;

    int newVisibleRange = qCeil((p->height() > 0 ? p->height() + 10 : 0)*1.0/ m_blockHeight);
    int delta = newVisibleRange - it->displayLineSpan;

    if (delta != 0)
    {
        unsigned index = static_cast<unsigned>(it - m_sections.begin());
        applyOffsetToSectionsAfterIndex(index, delta, false);
        m_totalOffset += delta;
        it->displayLineSpan = newVisibleRange;
        emit refreshAfterPaletteChange(it->lineNumber + it->lineSpan - 1, delta);
    }
}

/**
 * @brief In the event of a palette changing its width, we simply
 * update it in the appropriate line section, as well as reset the
 * maximum width of the space needed to display the total content in the editor
 */
void LineControl::resizePaletteWidth(QQuickItem *p)
{
    auto it = m_sections.begin();
    for (; it != m_sections.end(); ++it)
        if (it->type == LineSection::Palette && it->palette == p) break;

    if (it == m_sections.end()) return;

    it->paletteWidth = static_cast<int>(p->width());

    // update the max width
    auto max = 0;
    for (auto it = m_sections.begin(); it != m_sections.end(); ++it)
    {
        if (it->paletteWidth > max) max = it->paletteWidth;
    }

    m_maxWidth = max;
}

/**
 * \brief Removes a given palette from the sections, optionally destroying it as well if
 * the flag `destroy` is set to true.
 */
void LineControl::removePalette(QQuickItem *p, bool destroy)
{
    unsigned i = 0;
    for (; i < m_sections.size(); ++i)
        if (m_sections[i].type == LineSection::Palette
         && m_sections[i].palette == p)
            break;

    if (i == m_sections.size()) return;
    int pos = m_sections[i].lineNumber;
    int range = m_sections[i].lineSpan;
    int delta = m_sections[i].lineSpanDelta();

    removeLineSection(m_sections[i], destroy);

    // reevaluate max width
    auto max = 0;
    for (auto it = m_sections.begin(); it != m_sections.end(); ++it)
    {
        if (it->paletteWidth > max) max = it->paletteWidth;
    }

    m_maxWidth = max;

    emit refreshAfterPaletteChange(pos + range - 1, -delta);
}

/**
 * \brief Sets the block height to a given value. Since this is the basic unit
 * of measurement in `LineControl` (i.e. everything is measured in lines),
 * we have to recalculate the heights of palettes in terms of number of lines, since their
 * size doesn't scale in the same way.
 */
void LineControl::setBlockHeight(int bh)
{
    m_blockHeight = bh;

    for (unsigned i = 0; i < m_sections.size(); ++i)
    {
        if (m_sections[i].type == LineSection::Collapsed) continue;

        int newVisibleRange = qCeil((m_sections[i].palette->height() > 0 ? m_sections[i].palette->height() + 10 : 0)*1.0/ m_blockHeight);
        if (newVisibleRange != m_sections[i].displayLineSpan)
        {
            applyOffsetToSectionsAfterIndex(i, newVisibleRange - m_sections[i].displayLineSpan, false);
            m_sections[i].displayLineSpan = newVisibleRange;
            m_totalOffset += newVisibleRange - m_sections[i].displayLineSpan;
        }
    }
}

void LineControl::reset()
{
    m_prevLineNumber = m_lineNumber;
    m_lineNumber = 0;
    m_firstDirtyLine = -1;
    // linesRemoved();
    m_sections.clear();
}

std::vector<LineControl::LineSection> LineControl::sections()
{
    return m_sections;
}

/**
 * \brief Main listener for changes in the text document.
 * Calls appropriate handlers in case text was either removed or added.
 */
void LineControl::contentsChange(int pos, int removed, int added)
{
    if (m_sections.empty()) return;

    if (removed > 0)
        codeRemovalHandler(pos, removed);

    if (added > 0)
        codeAddingHandler(pos, added);
}

/**
 * \brief Returns the vertical offset needed when drawing the node for the given
 * lineNumber, or the cursor in that block. It's given in pixels instead of lines.
 *
 */
int LineControl::pixelDrawingOffset(int blockNumber, bool forCursor)
{
    int offset = 0;
    auto upper = std::upper_bound(m_sections.begin(), m_sections.end(),
        LineSection(blockNumber, 0, 0, LineSection::Collapsed), LineSection::compareLines);
    if (upper != m_sections.begin() && !m_sections.empty())
    {
        // The current section is the first one that's not above the given block number, which means
        // that lineNumber >= current->lineNumber.
        auto prev = std::prev(upper);

        if (prev->type == LineSection::Collapsed && blockNumber == prev->lineNumber)
        {
            // If the line we're drawing is the collapsed one, the offset is the
            // difference between its visiblePosition and actual position
            offset = prev->lineNumberDelta();
        }
        else
        if (blockNumber < prev->lineNumber + prev->lineSpan && !forCursor)
        {
            // If the lineNumber is inside a "hidden" part of the section,
            // we need to draw it "outside" of the viewport, which is done
            // by offsetting it in the negative direction
            offset = -blockNumber - 2;
        } else
        if (blockNumber >= prev->lineNumber + prev->lineSpan)
        {
            // The drawing offset in this case is given by the position offset of the
            // section itself, as well as the offset that it creates on its own
            offset = prev->lineNumberDelta() + prev->lineSpanDelta();
        }
    }
    return offset * m_blockHeight;
}

/**
 * \brief Transforms a clicked visible pixel position inside the viewport
 * into a transposed, "fake" pixel click position that corresponds to the actual
 * block number if there were no sections present. This is done so when we click on a line,
 * we actually position it properly within text
 */
int LineControl::transposeClickedPosition(int y)
{
    int visibleBlockClicked = y / m_blockHeight;
    int resultBlock = visibleBlockClicked;

    LineSection search;
    search.displayLineNumber = visibleBlockClicked;

    auto upper = std::upper_bound(m_sections.begin(), m_sections.end(),
        search, LineSection::compareDisplayLines);

    if (upper != m_sections.begin() && !m_sections.empty()) {
        auto prev = std::prev(upper);

        if (upper == m_sections.end() && prev->type == LineSection::Fragment
            && prev->lineNumber != 0)
        {
            resultBlock = prev->lineNumber - 1;
        }
        else if (visibleBlockClicked >= prev->displayLineNumber + prev->displayLineSpan)
        {
            resultBlock = visibleBlockClicked - prev->lineNumberDelta() - prev->lineSpanDelta();
        }
        else if (prev->type == LineSection::Collapsed && visibleBlockClicked == prev->displayLineNumber)
        {
            resultBlock = prev->lineNumber;
        } else
        {
            resultBlock = prev->lineNumber - 1;
        }
    }

    return resultBlock * m_blockHeight + m_blockHeight / 2;
}

/**
 * \brief Total offset generated by sections, necessary for
 * calculations of actual dimensions of the entire canvas
 */
int LineControl::totalOffset()
{
    if (m_sections.empty()) return 0;
    auto lastSection = m_sections[m_sections.size()-1];
    return lastSection.lineNumberDelta() + lastSection.lineSpanDelta();
}

/**
 * \brief Taking into consideration the offsets before a given visible line,
 * we calculate which absolute line of text it represents
 */
int LineControl::displayLineToSourceLine(int displayLine)
{
    LineSection ls;
    ls.displayLineNumber = displayLine;
    auto upper = std::upper_bound(m_sections.begin(), m_sections.end(), ls, LineSection::compareDisplayLines);

    int abs = displayLine;
    if (upper != m_sections.begin())
    {
        auto prev = std::prev(upper);
        if (displayLine >= prev->displayLineNumber + prev->displayLineSpan)
            abs = displayLine - prev->lineNumberDelta() - prev->lineSpanDelta();
        else if (prev->type == LineSection::Collapsed && displayLine == prev->displayLineNumber)
            abs = prev->lineNumber;
        else abs = -1; // not mapping to an absolute line
    }

    if (abs >= m_textEdit->code()->textDocument()->blockCount()) return -1;
    return abs;
}

bool LineControl::isHiddenByPalette(int blockNumber)
{
    auto upper = std::upper_bound(m_sections.begin(), m_sections.end(), LineSection(blockNumber, 0, 0, LineSection::Palette), LineSection::compareLines);
    if (upper != m_sections.begin() && !m_sections.empty())
    {
        auto prev = std::prev(upper);
        if (prev->type == LineSection::Palette
                && blockNumber < prev->lineNumber + prev->lineSpan)
            return true;
    }
    return false;
}

bool LineControl::isHiddenByCollapse(int blockNumber)
{
    auto upper = std::upper_bound(m_sections.begin(), m_sections.end(), LineSection(blockNumber, 0, 0, LineSection::Palette), LineSection::compareLines);
    if (upper != m_sections.begin() && !m_sections.empty())
    {
        auto prev = std::prev(upper);
        if (prev->type == LineSection::Collapsed
                && blockNumber < prev->lineNumber + prev->lineSpan
                && blockNumber != prev->lineNumber)
            return true;
    }
    return false;
}

/**
 * \brief If we're moving the cursor through text, it needs to skip hidden lines.
 * We calculate the necessary forward skip in this function. The assumption is
 * that the `lineNumber` corresponds to a visible line
 */
int LineControl::deltaToNextDisplayLine(int blockNumber, bool forCollapse)
{
    auto lower = std::lower_bound(
        m_sections.begin(), m_sections.end(),
        LineSection(blockNumber, 0,0,LineSection::Collapsed),
        LineSection::compareLines);
    if (lower != m_sections.end())
    {
        switch (lower->type)
        {
        case LineSection::Palette:
            if (blockNumber + 1 == lower->lineNumber && !forCollapse)
                return lower->lineSpan;
            break;
        case LineSection::Collapsed:
            if (blockNumber == lower->lineNumber)
                return lower->lineSpan - 1;
            break;
        case LineSection::Fragment:
            if (blockNumber + 1 == lower->lineNumber && !forCollapse)
                return -1;
            break;
        }
    }

    return 0;
}

/**
 * \brief If we're moving the cursor through text, it needs to skip hidden lines.
 * We calculate the necessary backwards skip in this function. The assumption is
 * that the `lineNumber` corresponds to a visible line
 */
int LineControl::deltaToPreviousDisplayLine(int blockNumber)
{
    auto upper = std::upper_bound(
        m_sections.begin(), m_sections.end(),
        LineSection(blockNumber, 0,0,LineSection::Collapsed),
        LineSection::compareLines);
    if (upper != m_sections.begin() && !m_sections.empty())
    {
        auto prev = std::prev(upper);
        if (blockNumber == prev->lineNumber + prev->lineSpan)
        switch (prev->type)
        {
        case LineSection::Palette:      return prev->lineSpan;
        case LineSection::Collapsed:    return prev->lineSpan - 1;
        case LineSection::Fragment:     return -1;
        }
    }

    return 0;
}

/**
 * \brief Sets the line where there was any change, be it a collapse,
 * palette or text modification, so everything after it is potentially in
 * a wrong state
 */
void LineControl::setFirstDirtyLine(int dirtyPos)
{
    m_firstDirtyLine = dirtyPos;
}

/**
 * \brief Line count change listener which wraps a function that
 * handles such changes, and emits another, more detailed signal that a change has happened
 */
void LineControl::lineCountChanged()
{
    m_prevLineNumber = m_lineNumber;
    m_lineNumber = m_textEdit->code()->textDocument()->blockCount();
    if (m_prevLineNumber == m_lineNumber) return;

    int delta = m_lineNumber - m_prevLineNumber;
    bool internal = false;

    handleLineCountChanged(delta, internal);

    emit lineDelta(delta, m_firstDirtyLine, internal);

}

unsigned LineControl::insertIntoSorted(LineControl::LineSection ls)
{
    auto upper = std::upper_bound(m_sections.begin(), m_sections.end(), ls, LineSection::compareLines);
    unsigned position = static_cast<unsigned>(upper - m_sections.begin());
    m_sections.insert(upper, ls);
    return position;
}

void LineControl::calculateDisplayLine(unsigned pos)
{
    int off = 0;
    for (unsigned i = 0; i < pos; ++i)
        off += m_sections[i].lineSpanDelta();
    m_sections[pos].displayLineNumber = m_sections[pos].lineNumber + off;
}

/**
 * \brief Applies the given offset to every section and sub-section that
 * is positioned after the given index. Optionally, it moves their positions,
 * as well as their visible positions, depending on the context.
 */
void LineControl::applyOffsetToSectionsAfterIndex(unsigned sectionIndex, int offset, bool offsetPositions, bool offsetVisible)
{
    std::queue<LineSection*> q;
    for (unsigned i = sectionIndex + 1; i < m_sections.size(); ++i)
    {
        q.push(&m_sections[i]);
        while (!q.empty())
        {
            LineSection* lsp = q.front(); q.pop();
            for (size_t x = 0; x < lsp->children.size(); ++x)
                q.push(&lsp->children[x]);

            if (offsetVisible) lsp->displayLineNumber += offset;
            if (offsetPositions) lsp->lineNumber += offset;
            if (lsp->type == LineSection::Palette)
            {
                // Positions the palette in the center of its designated space.
                lsp->palette->setY(lsp->displayLineNumber * m_blockHeight + (lsp->displayLineSpan * m_blockHeight - lsp->palette->height()) / 2 + 6);
            }
            else if (lsp->type == LineSection::Fragment)
            {
                // Managing the ending boundary of end fragment
                lsp->lineSpan = m_lineNumber - lsp->lineNumber;
            }
        }
    }
}

/**
 * \brief For code that was removed between positions `pos` and `pos+removed`,
 * we need to remove the appropriate sections that were deleted as well,
 * and also shift everything after accordingly.
 */
void LineControl::codeRemovalHandler(int pos, int removed)
{
    LineSection search;

    // Find sections which need to be shifted only.
    search.startPosition = pos + removed;
    auto safe = std::upper_bound(m_sections.begin(), m_sections.end(), search, LineControl::LineSection::compareStartPositions);

    // Find sections that were affected by the code removal.
    search.startPosition = pos;
    auto iter = std::upper_bound(m_sections.begin(), m_sections.end(), search, LineControl::LineSection::compareStartPositions);

    bool internal = false;
    if (iter != m_sections.begin())
    {
        iter = std::prev(iter);

        if (iter->startPosition <= pos && pos + removed <= iter->endPosition)
        {
            internal = true;
            // handling the case when removed text is inside a section (isn't reflected in the visible part of text)

            LineSection* parent = &(*iter);
            while (parent)
            {
                int leftIndex = -1, rightIndex = -1;
                LineSection *newParent = nullptr;
                while (true)
                {
                    // finding which nested sections contain the left and right borders of the removed text
                    for (size_t i = 0; i < parent->children.size(); ++i)
                    {
                        if (pos >= parent->children[i].startPosition && pos < parent->children[i].endPosition)
                            leftIndex = i;
                        if (pos + removed >= parent->children[i].startPosition && pos + removed < parent->children[i].endPosition)
                            rightIndex = i;
                    }

                    if (leftIndex == -1 && rightIndex == -1) break;
                    // if it's the same section that contains both,
                    // this means the nesting goes even deeper, so
                    // we continue the process with the nested sub-section
                    if (leftIndex == rightIndex)
                    {
                        newParent = &parent->children[leftIndex];
                        break;
                    }

                    // The removal of code means that the sections contained are also being
                    // "destabilized" i.e. erasing a part of a collapsed section expands it, which
                    // pops out its nested sections. This is done for both affected sections
                    if (leftIndex != -1)
                        for (auto sec: parent->children[leftIndex].children)
                            parent->children.push_back(sec);
                    if (rightIndex != -1)
                        for (auto sec: parent->children[rightIndex].children)
                            parent->children.push_back(sec);

                    int offset = 0;
                    // The newly expanded sections are also removed
                    if (leftIndex != -1)
                    {
                        parent->children.erase(parent->children.begin() + leftIndex);
                        offset = -1;
                    }
                    if (rightIndex != -1)
                        parent->children.erase(parent->children.begin() + rightIndex + offset);



                    leftIndex = -1;
                    rightIndex = -1;
                }

                // we shift the appropriate positions of sections that are after
                // the last affected position
                for (unsigned i = 0; i < parent->children.size(); ++i){
                    if (parent->children[i].startPosition > pos + removed)
                    {
                        parent->children[i].startPosition -= removed;
                        parent->children[i].endPosition -= removed;
                    }
                }

                parent->endPosition -= removed;

                // if we've reached the end of descending through the hieararchy of sections,
                // this means that we only need to remove the sections contained between
                // the boundaries of removed text, since there's no other affected sections anymore
                if (newParent == nullptr)
                {
                    for (auto it = parent->children.begin(); it != parent->children.end();)
                    {
                        if (pos < it->startPosition && it->endPosition < pos + removed)
                            it = parent->children.erase(it);
                        else ++it;
                    }
                }

                // going deeper into the nesting, or ending the loop
                parent = newParent;
            }
        }
    }

    if (!internal)
    {
        // If the code removed wasn't contained in a single section,
        // it potentially affects multiple first-level sections.

        // Handle left boundary
        while (true)
        {
            search.startPosition = pos;
            auto iter = std::upper_bound(m_sections.begin(), m_sections.end(), search, LineControl::LineSection::compareStartPositions);
            if (iter != m_sections.begin())
            {
                iter = std::prev(iter);
            }
            else break; // no section that contains left boundary anymore

            if (iter->type == LineSection::Fragment) break;
            if (iter->startPosition < pos && pos < iter->endPosition)
            {
                if (iter->palette)
                {
                    removePalette(iter->palette);
                } else {
                    std::vector<LineSection> nested = iter->children;
                    // This might pop out several nested collapses,
                    // which is why we have an infinite loop
                    int position = iter->lineNumber;
                    int delta = removeCollapse(iter->lineNumber);
                    signalRefreshAfterCollapseChange(position, delta);
                }
            } else break;
        }

        // Handle the right boundary in a way similar to the one above
        while (true)
        {
            search.startPosition = pos + removed;
            auto iter = std::upper_bound(m_sections.begin(), m_sections.end(), search, LineControl::LineSection::compareStartPositions);
            if (iter != m_sections.begin())
            {
                iter = std::prev(iter);
            }
            else break; // no section that contains right boundary anymore

            if (iter->type == LineSection::Fragment) break;
            if (iter->startPosition < pos + removed && pos + removed < iter->endPosition)
            {
                if (iter->palette)
                {
                    removePalette(iter->palette);
                } else {
                    std::vector<LineSection> nested = iter->children;
                    int pos = iter->lineNumber;
                    int delta = removeCollapse(pos);
                    signalRefreshAfterCollapseChange(pos, delta);
                }
            } else break;
        }

        // now we should delete all sections between
        while (true)
        {
            search.startPosition = pos;
            iter = std::upper_bound(m_sections.begin(), m_sections.end(), search, LineControl::LineSection::compareStartPositions);

            if (iter != m_sections.end() && iter->startPosition < pos + removed)
            {
                if (iter->palette)
                {
                    removePalette(iter->palette);
                } else {
                    std::vector<LineSection> nested = iter->children;
                    int pos = iter->lineNumber;
                    int delta = removeCollapse(pos);
                    signalRefreshAfterCollapseChange(pos, delta);
                }

            }
            else break;
        }

        search.startPosition = pos + removed;
        safe = std::upper_bound(m_sections.begin(), m_sections.end(), search, LineControl::LineSection::compareStartPositions);
    }

    // We update the boundaries of sections which are positioned after the removed code
    // TODO: This should probably consider their nested sections as well.
    for (auto it = safe; it != m_sections.end(); ++it)
    {
        it->startPosition -= removed;
        it->endPosition -= removed;
    }

}

/**
 * \brief The case of adding code after a given position, which is
 * the task of this function, is simpler, in the sense that nothing
 * is being destroyed, merely shifted
 */
void LineControl::codeAddingHandler(int pos, int added)
{
    std::queue<LineSection*> q;

    LineSection search;
    search.startPosition = pos;
    auto iter = std::upper_bound(m_sections.begin(), m_sections.end(), search, LineControl::LineSection::compareStartPositions);

    if (iter != m_sections.begin() && !m_sections.empty())
    {
        iter = std::prev(iter);
    }

    // For every section, nested or otherwise, that was positioned after the text insertion point,
    // we need to shift the appropriate section bounds by the amount of added characters
    while (iter != m_sections.end())
    {
        q.push(&(*iter));
        ++iter;
    }

    while (!q.empty())
    {
        LineSection* lsp = q.front(); q.pop();
        for (size_t x = 0; x < lsp->children.size(); ++x)
            q.push(&lsp->children[x]);

        // If the section contains the text addition point, we shift the round bound only
        if (lsp->startPosition <= pos && pos < lsp->endPosition)
            lsp->endPosition += added;
        // If the sections is after the text addition point, we shift both bounds
        if (lsp->startPosition > pos)
        {
            lsp->startPosition += added;
            lsp->endPosition += added;
        }

        if (lsp->type == LineSection::Fragment && lsp->lineNumber != 0) // handles end fragment bounds
        {
            lsp->endPosition = m_textEdit->code()->textDocument()->characterCount() -1;
        }
    }
}

/**
 * \brief Handles offsets that happen when the code was edited externally,
 * so we have to handle the inner parts of a collapsed section so we maintain
 * the appropriate structure. Every inner section must be moved accordingly
 */
bool LineControl::handleOffsetsWithinASection(int sectionIndex, int delta)
{
    // the lines added/removed are contained inside a single section
    LineSection& sec = m_sections[sectionIndex];

    std::queue<LineSection*> q;
    q.push(&sec);
    // For each nested section, and even sections nested any level deeper, we need to move
    // the line boundaries. If the change happened inside the section, we only offset the right boundary.
    // If the section is position after the change location, we move both boundaries.
    while (!q.empty())
    {
        LineSection* lsp = q.front(); q.pop();
        for (size_t x = 0; x < lsp->children.size(); ++x)
            q.push(&lsp->children[x]);

        if (lsp->lineNumber <= m_firstDirtyLine && m_firstDirtyLine < lsp->lineNumber + lsp->lineSpan)
            lsp->lineSpan += delta;
        if (lsp->lineNumber > m_firstDirtyLine)
        {
            lsp->lineNumber += delta;
            lsp->displayLineNumber += delta;
        }

        if (lsp->type == LineSection::Palette)
        {
            // Considering the new, shifted position of a palette, we place it in the center of its designated spaces
            lsp->palette->setY(lsp->displayLineNumber * m_blockHeight + (lsp->displayLineSpan * m_blockHeight - lsp->palette->height()) / 2 + 6);
        }
        else if (lsp->type == LineSection::Fragment && lsp->lineNumber != 0) // handles end fragment bounds
        {
            // We modify the ending boundary of the end fragment
            lsp->lineSpan = m_lineNumber - lsp->lineNumber;
        }
    }
    return true;
}

/**
 * \brief Starting from `m_dirtyPos`, this function handles a line change of `delta` lines,
 * either added or removed. If the line change happened inside a hidden part of code,
 * i.e. inside a section, we need to handle this change internally. We also have to offset
 * every section that follows after it.
 */
void LineControl::handleLineCountChanged(int delta, bool& internal)
{
    auto upper = std::upper_bound(m_sections.begin(), m_sections.end(), LineSection(m_firstDirtyLine, 0,0,LineSection::Collapsed), LineSection::compareLines);

    if (upper != m_sections.begin() && !m_sections.empty())
    {
        auto prev = std::prev(upper);
        if (m_firstDirtyLine < prev->lineNumber + prev->lineSpan)
        {
            internal = handleOffsetsWithinASection(prev-m_sections.begin(), delta);
        }
    }

    applyOffsetToSectionsAfterIndex(static_cast<unsigned>(upper-m_sections.begin() -1), delta, true, !internal);
}

int LineControl::firstContentLine()
{
    if (m_sections.empty()) return 0;
    auto first = m_sections[0];
    if (first.type == LineSection::Fragment && first.lineNumber == 0)
        return first.lineSpan;
    return 0;
}

int LineControl::lastContentLine()
{
    int blockCount = m_textEdit->code()->textDocument()->blockCount();
    if (m_sections.empty()) return blockCount;
    auto last = m_sections[m_sections.size()-1];
    if (last.type == LineSection::Fragment && last.lineNumber + last.lineSpan == blockCount)
        return last.lineNumber;
    return blockCount;
}

/**
 * \brief Returns the first visible line of text before the given one
 */
int LineControl::firstDisplayLineBefore(int lineNumber)
{
    auto upper = std::upper_bound(m_sections.begin(), m_sections.end(),
        LineSection(lineNumber, 0, 0, LineSection::Collapsed), LineSection::compareLines);

    if (upper != m_sections.begin())
    {
        auto prev = std::prev(upper);
        int currResult = lineNumber;
        while (true)
        {
            switch (prev->type)
            {
            case LineSection::Collapsed:
                if (currResult > prev->lineNumber && currResult < prev->lineNumber + prev->lineSpan)
                {
                    return prev->lineNumber;
                }
                return currResult;
            case LineSection::Palette:
            case LineSection::Fragment:
                // In case here are multiple palettes/fragments in a row,
                // we have to jump back for each of them.
                // TODO: The functions `offsetToNextVisibleLine` and `offsetToPreviousVisibleLine`
                // should probably do this in the same manner, making this function unecessary.
                if (currResult >= prev->lineNumber && currResult < prev->lineNumber + prev->lineSpan)
                {
                    currResult = prev->lineNumber - 1;

                    if (prev == m_sections.begin())
                    {
                        return currResult;
                    }
                    prev = std::prev(prev);
                } else
                {
                    return currResult;
                }
                break;
            }
        }

    }

    return lineNumber;
}

void LineControl::signalRefreshAfterCollapseChange(int pos, int delta)
{
    emit refreshAfterCollapseChange(pos, delta);
}

/**
 * \brief Calculates line boundaries of viewport, and then finds
 * the visible sections of code withing those boundaries
 */
std::vector<VisibleSection> LineControl::visibleSectionsForViewport(const QRect &rect) const
{
    if (m_blockHeight < 1 || rect.width() <0 || rect.height() < 0)
        return std::vector<VisibleSection>();


    int firstBlock = qMax(0, qFloor(rect.y()*1.0/m_blockHeight));
    int lastBlock = qCeil((rect.y() + rect.height())*1.0/m_blockHeight);

    return visibleSections(firstBlock, lastBlock);
}

/**
 * \brief Returns visible sections of code within a given range,
 * as a complement of line sections
 */
std::vector<VisibleSection> LineControl::visibleSections(int firstBlock, int lastBlock) const
{    
    std::vector<VisibleSection> result;

    if (m_sections.empty()) {
        // If there's no line sections, the entire range is visible
        result.push_back(VisibleSection(std::min(m_lineNumber - firstBlock, lastBlock - firstBlock + 1), firstBlock));
        return result;
    }

    LineSection ls;
    ls.displayLineNumber = firstBlock;

    auto next = std::upper_bound(m_sections.begin(), m_sections.end(), ls, LineSection::compareDisplayLines);
    decltype(next) curr;
    bool noCurr = false;

    // curr is the first section that has curr->displayLineNumber <= firstBlock
    if (next != m_sections.begin())
    {
        curr = std::prev(next);
    } else {
        noCurr = true;
    }

    int startPos = firstBlock;

    // The total number of lines that need to be "filled out",
    // so we eiher reach zero, or reach the end of text
    int total = lastBlock - firstBlock + 1;

    while (total > 0)
    {
        // This flag lets us know that we're outside of a line section, which means
        // we're in code, and can use every line until the next line section
        bool aboveCurr = false;
        if (!noCurr)
        {
            switch (curr->type)
            {
            case LineSection::Palette:
                if (startPos < curr->displayLineNumber + curr->displayLineSpan)
                {
                    // Start position is within palette, we're showing the lower part of it
                    int size = curr->displayLineSpan - (startPos - curr->displayLineNumber);
                    result.push_back(VisibleSection(std::min(total, size), curr->lineNumber, curr->palette));
                    total -= std::min(total, size);
                    startPos = curr->displayLineNumber + curr->displayLineSpan;
                } else {
                    aboveCurr = true;
                }
                break;

            case LineSection::Collapsed:
                // If we're at the start of collapsed, we only show the first line
                if (startPos == curr->displayLineNumber)
                {
                    result.push_back(VisibleSection(1, curr->lineNumber));
                    total -= 1;
                    startPos = curr->displayLineNumber + 1;
                 } else {
                     aboveCurr = true;
                 }
                break;
            case LineSection::Fragment:
                if (curr->lineNumber == 0) {
                    // If we're inside the start fragment, we skip it completely, since it's all hidden
                    aboveCurr = true;
                } else {
                    // If we've reached the end fragment, there's no more lines to add
                    noCurr = false;
                    total = 0; // the end
                }
                break;
            }
        }

        if (noCurr || aboveCurr)
        {
            // This means we're in code, so we can add a visible section until the next line section,
            // or perhaps the end of code
            if (next == m_sections.end())
            {
                int size = std::min(total, m_lineNumber - startPos + curr->lineNumberDelta() + curr->lineSpanDelta());
                if (size > 0) result.push_back(VisibleSection(std::min(total, m_lineNumber - startPos + curr->lineNumberDelta() + curr->lineSpanDelta()), startPos - curr->lineNumberDelta() - curr->lineSpanDelta()));
                total = 0;
            } else {
                int size = std::min(total, next->displayLineNumber - startPos);
                if (size > 0)
                {
                    result.push_back(VisibleSection(std::min(total, next->displayLineNumber - startPos), startPos - next->lineNumberDelta()));
                    total -= size;
                }
                startPos = next->displayLineNumber;

                curr = next;
                next = std::next(next);
                if (noCurr) noCurr = false;
            }
        }
    }

    return result;
}

/**
 * \brief A test function to simulate change of line count
 */
void LineControl::simulateLineCountChange(int deltaLines)
{
    if (deltaLines == 0) return;
    m_prevLineNumber = m_lineNumber;
    m_lineNumber += deltaLines;

    bool internal = false;

    handleLineCountChanged(deltaLines, internal);
}

int LineControl::maxWidth()
{
    return m_maxWidth;
}

/**
 * \brief This function adds the line section to `m_sections`, taking into consideration
 * nesting, as well as generated offsets created by its insertion.
 * \returns Total offset generated by its insertion
 */
int LineControl::addLineSection(LineControl::LineSection ls)
{
    // Find sections whose starting position is larger than the one we're currently inserting.
    auto srch = std::upper_bound(m_sections.begin(), m_sections.end(), ls, LineSection::compareLines);
    // This variable stores the visual offset (measured in lines) that this operation creates.
    int resultLineOffset = 0;
    std::vector<LineSection> nested;
    // Every section that's contained inside the section being inserted is stored in a `nested` container
    while (srch != m_sections.end()
           && srch->lineNumber + srch->lineSpan < ls.lineNumber+ls.lineSpan)
    {
        nested.push_back(*srch);
        srch++;
    }

    // Each nested section needs to be "reverted"
    for (LineSection l: nested)
    {
        if (l.type == LineSection::Collapsed)
        {
            resultLineOffset += removeLineSection(l, false, false);
        }
        else {
            l.palette->setVisible(false);
            resultLineOffset += removeLineSection(l, false, false);
        }
    }

    // If we've inserted a line section that already has nested sections, we include those as well
    for (LineSection l: ls.children)
    {
        nested.push_back(l);
    }

    ls.children = nested;


    unsigned elementPos = insertIntoSorted(ls);

    // We calculate the visible (line) position of the newly inserted section
    // based on the offsets from every previous section.
    calculateDisplayLine(elementPos);

    if (ls.type == LineSection::Palette)
    {
        ls.palette->setProperty("x", 0);
        // This yValue is calculated in a way to center it inside the space given by a `displayLineSpan` number of lines
        int yValue = m_sections[elementPos].displayLineNumber * m_blockHeight + (m_sections[elementPos].displayLineSpan * m_blockHeight - static_cast<int>(ls.palette->height())) / 2;
        yValue = yValue > 0 ? yValue : 0;
        ls.palette->setProperty("y", yValue);
    }

    if (ls.paletteWidth > m_maxWidth) m_maxWidth = ls.paletteWidth;


    // We add the offset generated by this section alone to the resulting offset
    resultLineOffset += m_sections[elementPos].lineSpanDelta();
    // We also have to update the sections following this one with the offset it has generated
    if (m_sections[elementPos].displayLineSpan != m_sections[elementPos].lineSpan)
        applyOffsetToSectionsAfterIndex(elementPos, m_sections[elementPos].lineSpanDelta(), false);
    m_totalOffset += m_sections[elementPos].lineSpanDelta();

    return resultLineOffset;
}

/**
 * \brief Removes the line section given by its first parameter. If it's a palette, we can optionally
 * destroy it.
 * \returns Line offset created by the execution of this function.
 */
int LineControl::removeLineSection(LineControl::LineSection ls, bool destroy, bool restoreNestedPalettes)
{
    auto lower = std::lower_bound(m_sections.begin(), m_sections.end(), ls, LineSection::compareLines);
    unsigned index = static_cast<unsigned>(lower-m_sections.begin());
    std::vector<LineSection> nested = lower->children;
    int result = 0;

    if (lower->type == LineSection::Palette && destroy){
        lower->palette->setVisible(false);
        QMetaObject::invokeMethod(lower->palette, "close", Qt::DirectConnection);
    }

    applyOffsetToSectionsAfterIndex(index, -m_sections[index].lineSpanDelta(), false);
    m_totalOffset -= lower->lineSpanDelta();

    result -= lower->lineSpanDelta();
    m_sections.erase(lower);

    if (restoreNestedPalettes)
    {
        for (LineSection lsx: nested){
            if (lsx.type == LineSection::Palette){
                lsx.palette->setVisible(true);
            }
            result += addLineSection(lsx);

        }
    }

    return result;
}

int LineControl::LineSection::lineSpanDelta() const
{
    return displayLineSpan - lineSpan;
}

int LineControl::LineSection::lineNumberDelta() const
{
    return displayLineNumber - lineNumber;
}

VisibleSection::VisibleSection(int sz, int st, QQuickItem* p):
    size(sz), start(st), palette(p) {}


} // namespace
