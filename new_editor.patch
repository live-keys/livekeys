diff --git a/application/application.qrc b/application/application.qrc
index 222cedf..63232da 100644
--- a/application/application.qrc
+++ b/application/application.qrc
@@ -1,59 +1,60 @@
-<RCC>
-    <qresource prefix="/">
-        <file alias="main.qml">qml/main.qml</file>
-        <file alias="LogWindow.qml">qml/LogWindow.qml</file>
-        <file alias="Top.qml">qml/Top.qml</file>
-        <file alias="Project.qml">qml/Project.qml</file>
-        <file alias="MessageDialogButton.qml">qml/MessageDialogButton.qml</file>
-        <file alias="MessageDialogInternal.qml">qml/MessageDialogInternal.qml</file>
-        <file alias="ProjectNavigation.qml">qml/ProjectNavigation.qml</file>
-        <file alias="ProjectAddEntry.qml">qml/ProjectAddEntry.qml</file>
-        <file alias="License.qml">qml/License.qml</file>
-        <file alias="MessageDialogMain.qml">qml/MessageDialogMain.qml</file>
-        <file alias="LogContainer.qml">qml/LogContainer.qml</file>
-        <file alias="CommandsMenu.qml">qml/CommandsMenu.qml</file>
-    </qresource>
-    <qresource prefix="/fonts">
-        <file alias="UbuntuMono-Bold.ttf">fonts/UbuntuMono-Bold.ttf</file>
-        <file alias="UbuntuMono-Italic.ttf">fonts/UbuntuMono-Italic.ttf</file>
-        <file alias="UbuntuMono-Regular.ttf">fonts/UbuntuMono-Regular.ttf</file>
-        <file alias="SourceCodePro-Bold.ttf">fonts/SourceCodePro-Bold.ttf</file>
-        <file alias="SourceCodePro-Regular.ttf">fonts/SourceCodePro-Regular.ttf</file>
-        <file alias="SourceCodePro-Light.ttf">fonts/SourceCodePro-Light.ttf</file>
-        <file alias="OpenSans-Bold.ttf">fonts/OpenSans-Bold.ttf</file>
-        <file alias="OpenSans-Light.ttf">fonts/OpenSans-Light.ttf</file>
-        <file alias="OpenSans-Regular.ttf">fonts/OpenSans-Regular.ttf</file>
-        <file alias="OpenSans-LightItalic.ttf">fonts/OpenSans-LightItalic.ttf</file>
-    </qresource>
-    <qresource prefix="/images">
-        <file alias="log.png">images/log.png</file>
-        <file alias="logo.png">images/logo.png</file>
-        <file alias="new.png">images/new.png</file>
-        <file alias="open.png">images/open.png</file>
-        <file alias="save.png">images/save.png</file>
-        <file alias="project-arrow.png">images/project-arrow.png</file>
-        <file alias="project-directory.png">images/project-directory.png</file>
-        <file alias="project-file.png">images/project-file.png</file>
-        <file alias="project-file-active.png">images/project-file-active.png</file>
-        <file alias="project-file-unsaved.png">images/project-file-unsaved.png</file>
-        <file alias="open-directory.png">images/open-directory.png</file>
-        <file alias="toggle-navigation.png">images/toggle-navigation.png</file>
-        <file alias="project-file-monitor.png">images/project-file-monitor.png</file>
-        <file alias="license.png">images/license.png</file>
-        <file alias="settings.png">images/settings.png</file>
-        <file alias="license-check.png">images/license-check.png</file>
-        <file alias="log-search-tag.png">images/log-search-tag.png</file>
-        <file alias="log-toggle-window.png">images/log-toggle-window.png</file>
-        <file alias="log-view-prefix.png">images/log-view-prefix.png</file>
-        <file alias="palette-add.png">images/palette-add.png</file>
-        <file alias="palette-add-property.png">images/palette-add-property.png</file>
-        <file alias="palette-expand.png">images/palette-expand.png</file>
-        <file alias="palette-swap.png">images/palette-swap.png</file>
-        <file alias="palette-commit.png">images/palette-commit.png</file>
-        <file alias="switch-file.png">images/switch-file.png</file>
-        <file alias="command.png">images/command.png</file>
-        <file alias="live.png">images/live.png</file>
-        <file alias="onsave.png">images/onsave.png</file>
-        <file alias="disabled.png">images/disabled.png</file>
-    </qresource>
-</RCC>
+<RCC>
+    <qresource prefix="/">
+        <file alias="main.qml">qml/main.qml</file>
+        <file alias="LogWindow.qml">qml/LogWindow.qml</file>
+        <file alias="Top.qml">qml/Top.qml</file>
+        <file alias="Project.qml">qml/Project.qml</file>
+        <file alias="MessageDialogButton.qml">qml/MessageDialogButton.qml</file>
+        <file alias="MessageDialogInternal.qml">qml/MessageDialogInternal.qml</file>
+        <file alias="ProjectNavigation.qml">qml/ProjectNavigation.qml</file>
+        <file alias="ProjectAddEntry.qml">qml/ProjectAddEntry.qml</file>
+        <file alias="License.qml">qml/License.qml</file>
+        <file alias="MessageDialogMain.qml">qml/MessageDialogMain.qml</file>
+        <file alias="LogContainer.qml">qml/LogContainer.qml</file>
+        <file alias="CommandsMenu.qml">qml/CommandsMenu.qml</file>
+        <file alias="TextEditNodeView.qml">qml/TextEditNodeView.qml</file>
+    </qresource>
+    <qresource prefix="/fonts">
+        <file alias="UbuntuMono-Bold.ttf">fonts/UbuntuMono-Bold.ttf</file>
+        <file alias="UbuntuMono-Italic.ttf">fonts/UbuntuMono-Italic.ttf</file>
+        <file alias="UbuntuMono-Regular.ttf">fonts/UbuntuMono-Regular.ttf</file>
+        <file alias="SourceCodePro-Bold.ttf">fonts/SourceCodePro-Bold.ttf</file>
+        <file alias="SourceCodePro-Regular.ttf">fonts/SourceCodePro-Regular.ttf</file>
+        <file alias="SourceCodePro-Light.ttf">fonts/SourceCodePro-Light.ttf</file>
+        <file alias="OpenSans-Bold.ttf">fonts/OpenSans-Bold.ttf</file>
+        <file alias="OpenSans-Light.ttf">fonts/OpenSans-Light.ttf</file>
+        <file alias="OpenSans-Regular.ttf">fonts/OpenSans-Regular.ttf</file>
+        <file alias="OpenSans-LightItalic.ttf">fonts/OpenSans-LightItalic.ttf</file>
+    </qresource>
+    <qresource prefix="/images">
+        <file alias="log.png">images/log.png</file>
+        <file alias="logo.png">images/logo.png</file>
+        <file alias="new.png">images/new.png</file>
+        <file alias="open.png">images/open.png</file>
+        <file alias="save.png">images/save.png</file>
+        <file alias="project-arrow.png">images/project-arrow.png</file>
+        <file alias="project-directory.png">images/project-directory.png</file>
+        <file alias="project-file.png">images/project-file.png</file>
+        <file alias="project-file-active.png">images/project-file-active.png</file>
+        <file alias="project-file-unsaved.png">images/project-file-unsaved.png</file>
+        <file alias="open-directory.png">images/open-directory.png</file>
+        <file alias="toggle-navigation.png">images/toggle-navigation.png</file>
+        <file alias="project-file-monitor.png">images/project-file-monitor.png</file>
+        <file alias="license.png">images/license.png</file>
+        <file alias="settings.png">images/settings.png</file>
+        <file alias="license-check.png">images/license-check.png</file>
+        <file alias="log-search-tag.png">images/log-search-tag.png</file>
+        <file alias="log-toggle-window.png">images/log-toggle-window.png</file>
+        <file alias="log-view-prefix.png">images/log-view-prefix.png</file>
+        <file alias="palette-add.png">images/palette-add.png</file>
+        <file alias="palette-add-property.png">images/palette-add-property.png</file>
+        <file alias="palette-expand.png">images/palette-expand.png</file>
+        <file alias="palette-swap.png">images/palette-swap.png</file>
+        <file alias="palette-commit.png">images/palette-commit.png</file>
+        <file alias="switch-file.png">images/switch-file.png</file>
+        <file alias="command.png">images/command.png</file>
+        <file alias="live.png">images/live.png</file>
+        <file alias="onsave.png">images/onsave.png</file>
+        <file alias="disabled.png">images/disabled.png</file>
+    </qresource>
+</RCC>
diff --git a/application/qml/TextEditNodeView.qml b/application/qml/TextEditNodeView.qml
new file mode 100644
index 0000000..9e672e2
--- /dev/null
+++ b/application/qml/TextEditNodeView.qml
@@ -0,0 +1,113 @@
+import QtQuick 2.0
+
+ListView{
+    id: textEditNodeView
+    width: parent? parent.width: 0
+    height: parent? parent.height: 0
+    clip: true
+    currentIndex : 0
+    onCountChanged: currentIndex = 0
+
+    boundsBehavior : Flickable.StopAtBounds
+    highlightMoveDuration: 100
+
+    property int delegateHeight : 25
+
+    delegate: Rectangle {
+
+        height: delegateHeight
+        width: parent.width
+        z: 400
+
+        color: {
+            if (model.hiddenByPalette) return "#805100"
+            if (model.hiddenByCollapse) return "#7d0011"
+            return "black"
+        }
+
+        Text {
+            height: parent.height
+            width: 20
+            anchors.left: parent.left
+            anchors.leftMargin: 10
+            text: model.blockNumber
+            color: "white"
+
+            anchors.verticalCenter: parent.verticalCenter
+            font.family: "Open Sans, sans-serif"
+            font.pixelSize: 15
+            font.weight: Font.Light
+        }
+
+        Rectangle {
+            anchors.left: parent.left
+            anchors.leftMargin: 30
+            height: parent.height
+            width: 1
+            color: "#555555"
+        }
+
+        Text {
+            height: parent.height
+            width: 40
+            anchors.left: parent.left
+            anchors.leftMargin: 40
+            text: model.lineText
+            color: "white"
+
+            anchors.verticalCenter: parent.verticalCenter
+            font.family: "Open Sans, sans-serif"
+            font.pixelSize: 15
+            font.weight: Font.Light
+        }
+
+        Rectangle {
+            anchors.left: parent.left
+            anchors.leftMargin: 80
+            height: parent.height
+            width: 1
+            color: "#555555"
+        }
+
+        Text {
+            height: parent.height
+            width: parent.width - 130
+            clip: true
+            anchors.left: parent.left
+            anchors.leftMargin: 90
+            text: model.blockText
+            color: "white"
+
+            elide: Text.ElideRight
+            anchors.verticalCenter: parent.verticalCenter
+            font.family: "Open Sans, sans-serif"
+            font.pixelSize: 15
+            font.weight: Font.Light
+        }
+
+        Rectangle {
+            anchors.right: parent.right
+            anchors.rightMargin: 40
+            height: parent.height
+            width: 1
+            color: "#555555"
+        }
+
+        Text {
+            height: parent.height
+            width: 30
+            clip: true
+            anchors.right: parent.right
+            anchors.rightMargin: 10
+            anchors.leftMargin: 10
+            text: model.offset
+            color: "white"
+
+            anchors.verticalCenter: parent.verticalCenter
+            font.family: "Open Sans, sans-serif"
+            font.pixelSize: 15
+            font.weight: Font.Light
+        }
+    }
+}
+
diff --git a/application/qml/main.qml b/application/qml/main.qml
index b149c66..c663f1c 100644
--- a/application/qml/main.qml
+++ b/application/qml/main.qml
@@ -48,6 +48,7 @@ ApplicationWindow{
         navEditor: null
         codingMode: 0
         prevWindowState: 2
+        createWindow: newWindow
     }
 
     property bool documentsReloaded : false
@@ -64,6 +65,27 @@ ApplicationWindow{
         }
     }
 
+    Component {
+        id: windowFactory
+
+        Window {
+
+            visible: true
+            width: 800
+            height: 500
+            property var item: recItem
+
+            Rectangle {
+                id: recItem
+                anchors.fill: parent
+            }
+        }
+    }
+
+    function newWindow() {
+        return windowFactory.createObject(root)
+    }
+
     function toggleFullScreen(){
         if (root.visibility !== Window.FullScreen){
             root.controls.prevWindowState = root.visibility
diff --git a/lib/lveditor/3rdparty/textcontrol.cpp b/lib/lveditor/3rdparty/textcontrol.cpp
index acc74c8..53a0935 100644
--- a/lib/lveditor/3rdparty/textcontrol.cpp
+++ b/lib/lveditor/3rdparty/textcontrol.cpp
@@ -1,2043 +1,2047 @@
-/****************************************************************************
-**
-** Copyright (C) 2016 The Qt Company Ltd.
-** Contact: https://www.qt.io/licensing/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and The Qt Company. For licensing terms
-** and conditions see https://www.qt.io/terms-conditions. For further
-** information use the contact form at https://www.qt.io/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 2.0 or (at your option) the GNU General
-** Public license version 3 or any later version approved by the KDE Free
-** Qt Foundation. The licenses are as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
-** included in the packaging of this file. Please review the following
-** information to ensure the GNU General Public License requirements will
-** be met: https://www.gnu.org/licenses/gpl-2.0.html and
-** https://www.gnu.org/licenses/gpl-3.0.html.
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "textcontrol_p.h"
-#include "textcontrol_p_p.h"
-
-#ifndef QT_NO_TEXTCONTROL
-
-#include "qabstracttextdocumentlayout.h"
-#include <qcoreapplication.h>
-#include <qfont.h>
-#include <qevent.h>
-#include <qdebug.h>
-#include <qdrag.h>
-#include <qclipboard.h>
-#include <qtimer.h>
-#include <qinputmethod.h>
-#include "qtextdocument.h"
-#include "textdocumentlayout.h"
-
-#include "qtextlist.h"
-#include "qtextdocumentwriter.h"
-
-// <TOREMOVE>
-// See what is being used throughout
-#include "private/qqmlglobal_p.h"
-
-#include <qtextformat.h>
-#include <qdatetime.h>
-#include <qbuffer.h>
-#include <qguiapplication.h>
-#include <limits.h>
-#include <qtexttable.h>
-#include <qvariant.h>
-#include <qurl.h>
-#include <qstylehints.h>
-#include <qmetaobject.h>
-
-#include "textedit_p.h"
-#include "palettemanager.h"
-
-namespace lv {
-
-// ### these should come from QStyleHints
-const int textCursorWidth = 1;
-
-QT_BEGIN_NAMESPACE
-
-#ifndef QT_NO_CONTEXTMENU
-#endif
-
-// could go into QTextCursor...
-static QTextLine currentTextLine(const QTextCursor &cursor)
-{
-    const QTextBlock block = cursor.block();
-    if (!block.isValid())
-        return QTextLine();
-
-    const QTextLayout *layout = block.layout();
-    if (!layout)
-        return QTextLine();
-
-    const int relativePos = cursor.position() - block.position();
-    return layout->lineForTextPosition(relativePos);
-}
-
-TextControlPrivate::TextControlPrivate()
-    : doc(0),
-#ifndef QT_NO_IM
-      preeditCursor(0),
-#endif
-      interactionFlags(Qt::TextEditorInteraction),
-      cursorOn(false),
-      cursorIsFocusIndicator(false),
-      mousePressed(false),
-      lastSelectionState(false),
-      ignoreAutomaticScrollbarAdjustement(false),
-      overwriteMode(false),
-      acceptRichText(true),
-      cursorVisible(false),
-      cursorBlinkingEnabled(false),
-      hasFocus(false),
-      hadSelectionOnMousePress(false),
-      wordSelectionEnabled(false),
-      hasImState(false),
-      cursorRectangleChanged(false),
-      clearSelectionOnFocus(true),
-      lastSelectionStart(-1),
-      lastSelectionEnd(-1)
-{}
-
-bool TextControlPrivate::cursorMoveKeyEvent(QKeyEvent *e)
-{
-#ifdef QT_NO_SHORTCUT
-    Q_UNUSED(e);
-#endif
-
-    Q_Q(TextControl);
-    if (cursor.isNull())
-        return false;
-
-    const QTextCursor oldSelection = cursor;
-    const int oldCursorPos = cursor.position();
-
-    QTextCursor::MoveMode mode = QTextCursor::MoveAnchor;
-    QTextCursor::MoveOperation op = QTextCursor::NoMove;
-
-    if (false) {
-    }
-#ifndef QT_NO_SHORTCUT
-    if (e == QKeySequence::MoveToNextChar) {
-            op = QTextCursor::Right;
-    }
-    else if (e == QKeySequence::MoveToPreviousChar) {
-            op = QTextCursor::Left;
-    }
-    else if (e == QKeySequence::SelectNextChar) {
-           op = QTextCursor::Right;
-           mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectPreviousChar) {
-            op = QTextCursor::Left;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectNextWord) {
-            op = QTextCursor::WordRight;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectPreviousWord) {
-            op = QTextCursor::WordLeft;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectStartOfLine) {
-            op = QTextCursor::StartOfLine;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectEndOfLine) {
-            op = QTextCursor::EndOfLine;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectStartOfBlock) {
-            op = QTextCursor::StartOfBlock;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectEndOfBlock) {
-            op = QTextCursor::EndOfBlock;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectStartOfDocument) {
-            op = QTextCursor::Start;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectEndOfDocument) {
-            op = QTextCursor::End;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectPreviousLine) {
-            op = QTextCursor::Up;
-            mode = QTextCursor::KeepAnchor;
-    }
-    else if (e == QKeySequence::SelectNextLine) {
-            op = QTextCursor::Down;
-            mode = QTextCursor::KeepAnchor;
-            {
-                QTextBlock block = cursor.block();
-                QTextLine line = currentTextLine(cursor);
-                if (!block.next().isValid()
-                    && line.isValid()
-                    && line.lineNumber() == block.layout()->lineCount() - 1)
-                    op = QTextCursor::End;
-            }
-    }
-    else if (e == QKeySequence::MoveToNextWord) {
-            op = QTextCursor::WordRight;
-    }
-    else if (e == QKeySequence::MoveToPreviousWord) {
-            op = QTextCursor::WordLeft;
-    }
-    else if (e == QKeySequence::MoveToEndOfBlock) {
-            op = QTextCursor::EndOfBlock;
-    }
-    else if (e == QKeySequence::MoveToStartOfBlock) {
-            op = QTextCursor::StartOfBlock;
-    }
-    else if (e == QKeySequence::MoveToNextLine) {
-            op = QTextCursor::Down;
-    }
-    else if (e == QKeySequence::MoveToPreviousLine) {
-            op = QTextCursor::Up;
-    }
-    else if (e == QKeySequence::MoveToStartOfLine) {
-            op = QTextCursor::StartOfLine;
-    }
-    else if (e == QKeySequence::MoveToEndOfLine) {
-            op = QTextCursor::EndOfLine;
-    }
-    else if (e == QKeySequence::MoveToStartOfDocument) {
-            op = QTextCursor::Start;
-    }
-    else if (e == QKeySequence::MoveToEndOfDocument) {
-            op = QTextCursor::End;
-    }
-#endif // QT_NO_SHORTCUT
-    else {
-        return false;
-    }
-
-// Except for pageup and pagedown, OS X has very different behavior, we don't do it all, but
-// here's the breakdown:
-// Shift still works as an anchor, but only one of the other keys can be down Ctrl (Command),
-// Alt (Option), or Meta (Control).
-// Command/Control + Left/Right -- Move to left or right of the line
-//                 + Up/Down -- Move to top bottom of the file. (Control doesn't move the cursor)
-// Option + Left/Right -- Move one word Left/right.
-//        + Up/Down  -- Begin/End of Paragraph.
-// Home/End Top/Bottom of file. (usually don't move the cursor, but will select)
-
-    bool visualNavigation = cursor.visualNavigation();
-    cursor.setVisualNavigation(true);
-
-    auto pm = textEdit->getPaletteManager();
-    int result = pm->isLineBeforePalette(cursor.block().blockNumber());
-    if (result != 0)
-    {
-        if (cursor.atBlockEnd() &&(e == QKeySequence::MoveToNextChar || e ==  QKeySequence::MoveToNextWord || e == QKeySequence::MoveToEndOfLine))
-        {
-            for (int i = 0; i < result; ++i)
-                cursor.movePosition(QTextCursor::Down);
-            cursor.movePosition(QTextCursor::EndOfBlock);
-        }
-
-        if (cursor.atBlockEnd() && (e == QKeySequence::SelectNextChar || e == QKeySequence::SelectNextWord || e == QKeySequence::SelectEndOfLine))
-        {
-            for (int i = 0; i < result; ++i)
-            {
-                cursor.movePosition(QTextCursor::Down, QTextCursor::KeepAnchor);
-            }
-            cursor.movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);
-        }
-
-        if (e == QKeySequence::MoveToNextLine)
-        {
-            for (int i = 0; i < result; ++i)
-            {
-                cursor.movePosition(QTextCursor::Down);
-            }
-        }
-
-        if (e == QKeySequence::SelectNextLine)
-        {
-            for (int i = 0; i < result; ++i)
-            {
-                cursor.movePosition(QTextCursor::Down, QTextCursor::KeepAnchor);
-            }
-        }
-
-    }
-
-    result = pm->isLineAfterPalette(cursor.block().blockNumber());
-    if (result != 0)
-    {
-        if (cursor.atBlockStart() &&(e == QKeySequence::MoveToPreviousChar || e ==  QKeySequence::MoveToPreviousWord || e == QKeySequence::MoveToStartOfLine))
-        {
-            for (int i = 0; i < result; ++i)
-                cursor.movePosition(QTextCursor::Up);
-            cursor.movePosition(QTextCursor::StartOfBlock);
-        }
-
-        if (cursor.atBlockStart() && (e == QKeySequence::SelectPreviousChar || e == QKeySequence::SelectPreviousWord || e == QKeySequence::SelectStartOfLine))
-        {
-            for (int i = 0; i < result; ++i)
-            {
-                cursor.movePosition(QTextCursor::Up, QTextCursor::KeepAnchor);
-            }
-            cursor.movePosition(QTextCursor::StartOfBlock, QTextCursor::KeepAnchor);
-        }
-
-        if (e == QKeySequence::MoveToPreviousLine)
-        {
-            for (int i = 0; i < result; ++i)
-            {
-                cursor.movePosition(QTextCursor::Up);
-            }
-        }
-
-        if (e == QKeySequence::SelectPreviousLine)
-        {
-            for (int i = 0; i < result; ++i)
-            {
-                cursor.movePosition(QTextCursor::Up, QTextCursor::KeepAnchor);
-            }
-        }
-
-    }
-
-
-    const bool moved = cursor.movePosition(op, mode);
-    cursor.setVisualNavigation(visualNavigation);
-
-    bool isNavigationEvent
-            =  e->key() == Qt::Key_Up
-            || e->key() == Qt::Key_Down
-            || e->key() == Qt::Key_Left
-            || e->key() == Qt::Key_Right;
-
-    if (moved) {
-        if (cursor.position() != oldCursorPos)
-            emit q->cursorPositionChanged();
-        q->updateCursorRectangle(true);
-    } else if (isNavigationEvent && oldSelection.anchor() == cursor.anchor()) {
-        return false;
-    }
-
-    selectionChanged(/*forceEmitSelectionChanged =*/(mode == QTextCursor::KeepAnchor));
-
-    repaintOldAndNewSelection(oldSelection);
-
-    return true;
-}
-
-void TextControlPrivate::updateCurrentCharFormat()
-{
-    Q_Q(TextControl);
-
-    QTextCharFormat fmt = cursor.charFormat();
-    if (fmt == lastCharFormat)
-        return;
-    lastCharFormat = fmt;
-
-    emit q->currentCharFormatChanged(fmt);
-    cursorRectangleChanged = true;
-}
-
-void TextControlPrivate::setContent(Qt::TextFormat format, const QString &text)
-{
-    Q_Q(TextControl);
-
-#ifndef QT_NO_IM
-    cancelPreedit();
-#endif
-
-    // for use when called from setPlainText. we may want to re-use the currently
-    // set char format then.
-    const QTextCharFormat charFormatForInsertion = cursor.charFormat();
-
-    bool previousUndoRedoState = doc->isUndoRedoEnabled();
-    doc->setUndoRedoEnabled(false);
-
-    const int oldCursorPos = cursor.position();
-
-    // avoid multiple textChanged() signals being emitted
-    qmlobject_disconnect(doc, QTextDocument, SIGNAL(contentsChanged()), q, TextControl, SIGNAL(textChanged()));
-
-    if (!text.isEmpty()) {
-        // clear 'our' cursor for insertion to prevent
-        // the emission of the cursorPositionChanged() signal.
-        // instead we emit it only once at the end instead of
-        // at the end of the document after loading and when
-        // positioning the cursor again to the start of the
-        // document.
-        cursor = QTextCursor();
-        if (format == Qt::PlainText) {
-            QTextCursor formatCursor(doc);
-            // put the setPlainText and the setCharFormat into one edit block,
-            // so that the syntax highlight triggers only /once/ for the entire
-            // document, not twice.
-            formatCursor.beginEditBlock();
-            doc->setPlainText(text);
-            doc->setUndoRedoEnabled(false);
-            formatCursor.select(QTextCursor::Document);
-            formatCursor.setCharFormat(charFormatForInsertion);
-            formatCursor.endEditBlock();
-        } else {
-#ifndef QT_NO_TEXTHTMLPARSER
-            doc->setHtml(text);
-#else
-            doc->setPlainText(text);
-#endif
-            doc->setUndoRedoEnabled(false);
-        }
-        cursor = QTextCursor(doc);
-    } else {
-        doc->clear();
-    }
-    cursor.setCharFormat(charFormatForInsertion);
-
-    qmlobject_connect(doc, QTextDocument, SIGNAL(contentsChanged()), q, TextControl, SIGNAL(textChanged()));
-    emit q->textChanged();
-    doc->setUndoRedoEnabled(previousUndoRedoState);
-    _q_updateCurrentCharFormatAndSelection();
-    doc->setModified(false);
-
-    q->updateCursorRectangle(true);
-    if (cursor.position() != oldCursorPos)
-        emit q->cursorPositionChanged();
-}
-
-void TextControlPrivate::setCursorPosition(const QPointF &pos)
-{
-    Q_Q(TextControl);
-    const int cursorPos = q->hitTest(pos, Qt::FuzzyHit);
-    if (cursorPos == -1)
-        return;
-    cursor.setPosition(cursorPos);
-}
-
-void TextControlPrivate::setCursorPosition(int pos, QTextCursor::MoveMode mode)
-{
-    cursor.setPosition(pos, mode);
-
-    if (mode != QTextCursor::KeepAnchor) {
-        selectedWordOnDoubleClick = QTextCursor();
-        selectedBlockOnTripleClick = QTextCursor();
-    }
-}
-
-void TextControlPrivate::repaintCursor()
-{
-    Q_Q(TextControl);
-    emit q->updateCursorRequest();
-}
-
-void TextControlPrivate::repaintOldAndNewSelection(const QTextCursor &oldSelection)
-{
-    Q_Q(TextControl);
-    if (cursor.hasSelection()
-        && oldSelection.hasSelection()
-        && cursor.currentFrame() == oldSelection.currentFrame()
-        && !cursor.hasComplexSelection()
-        && !oldSelection.hasComplexSelection()
-        && cursor.anchor() == oldSelection.anchor()
-        ) {
-        QTextCursor differenceSelection(doc);
-        differenceSelection.setPosition(oldSelection.position());
-        differenceSelection.setPosition(cursor.position(), QTextCursor::KeepAnchor);
-        emit q->updateRequest();
-    } else {
-        if (!oldSelection.hasSelection() && !cursor.hasSelection()) {
-            if (!oldSelection.isNull())
-                emit q->updateCursorRequest();
-            emit q->updateCursorRequest();
-
-        } else {
-            if (!oldSelection.isNull())
-                emit q->updateRequest();
-            emit q->updateRequest();
-        }
-    }
-}
-
-void TextControlPrivate::selectionChanged(bool forceEmitSelectionChanged /*=false*/)
-{
-    Q_Q(TextControl);
-    if (forceEmitSelectionChanged) {
-#ifndef QT_NO_IM
-        if (hasFocus)
-            qGuiApp->inputMethod()->update(Qt::ImCurrentSelection);
-#endif
-        emit q->selectionChanged();
-    }
-
-    bool current = cursor.hasSelection();
-    int selectionStart = cursor.selectionStart();
-    int selectionEnd = cursor.selectionEnd();
-    if (current == lastSelectionState && (!current || (selectionStart == lastSelectionStart && selectionEnd == lastSelectionEnd)))
-        return;
-
-    if (lastSelectionState != current) {
-        lastSelectionState = current;
-        emit q->copyAvailable(current);
-    }
-
-    lastSelectionStart = selectionStart;
-    lastSelectionEnd = selectionEnd;
-
-    if (!forceEmitSelectionChanged) {
-#ifndef QT_NO_IM
-        if (hasFocus)
-            qGuiApp->inputMethod()->update(Qt::ImCurrentSelection);
-#endif
-        emit q->selectionChanged();
-    }
-}
-
-void TextControlPrivate::_q_updateCurrentCharFormatAndSelection()
-{
-    updateCurrentCharFormat();
-    selectionChanged();
-}
-
-#ifndef QT_NO_CLIPBOARD
-void TextControlPrivate::setClipboardSelection()
-{
-    QClipboard *clipboard = QGuiApplication::clipboard();
-    if (!cursor.hasSelection() || !clipboard->supportsSelection())
-        return;
-    Q_Q(TextControl);
-    QMimeData *data = q->createMimeDataFromSelection();
-    clipboard->setMimeData(data, QClipboard::Selection);
-}
-#endif
-
-void TextControlPrivate::_q_updateCursorPosChanged(const QTextCursor &someCursor)
-{
-    Q_Q(TextControl);
-    if (someCursor.isCopyOf(cursor)) {
-        emit q->cursorPositionChanged();
-        q->updateCursorRectangle(true);
-    }
-}
-
-void TextControlPrivate::setBlinkingCursorEnabled(bool enable)
-{
-    if (cursorBlinkingEnabled == enable)
-        return;
-
-    cursorBlinkingEnabled = enable;
-    updateCursorFlashTime();
-
-    if (enable)
-        connect(qApp->styleHints(), &QStyleHints::cursorFlashTimeChanged, this, &TextControlPrivate::updateCursorFlashTime);
-    else
-        disconnect(qApp->styleHints(), &QStyleHints::cursorFlashTimeChanged, this, &TextControlPrivate::updateCursorFlashTime);
-}
-
-void TextControlPrivate::updateCursorFlashTime()
-{
-    // Note: cursorOn represents the current blinking state controlled by a timer, and
-    // should not be confused with cursorVisible or cursorBlinkingEnabled. However, we
-    // interpretate a cursorFlashTime of 0 to mean "always on, never blink".
-    cursorOn = true;
-    int flashTime = QGuiApplication::styleHints()->cursorFlashTime();
-
-    if (cursorBlinkingEnabled && flashTime >= 2)
-        cursorBlinkTimer.start(flashTime / 2, q_func());
-    else
-        cursorBlinkTimer.stop();
-
-    repaintCursor();
-}
-
-void TextControlPrivate::extendWordwiseSelection(int suggestedNewPosition, qreal mouseXPosition)
-{
-    Q_Q(TextControl);
-
-    // if inside the initial selected word keep that
-    if (suggestedNewPosition >= selectedWordOnDoubleClick.selectionStart()
-        && suggestedNewPosition <= selectedWordOnDoubleClick.selectionEnd()) {
-        q->setTextCursor(selectedWordOnDoubleClick);
-        return;
-    }
-
-    QTextCursor curs = selectedWordOnDoubleClick;
-    curs.setPosition(suggestedNewPosition, QTextCursor::KeepAnchor);
-
-    if (!curs.movePosition(QTextCursor::StartOfWord))
-        return;
-    const int wordStartPos = curs.position();
-
-    const int blockPos = curs.block().position();
-    const QPointF blockCoordinates = q->blockBoundingRect(curs.block()).topLeft();
-
-    QTextLine line = currentTextLine(curs);
-    if (!line.isValid())
-        return;
-
-    const qreal wordStartX = line.cursorToX(curs.position() - blockPos) + blockCoordinates.x();
-
-    if (!curs.movePosition(QTextCursor::EndOfWord))
-        return;
-    const int wordEndPos = curs.position();
-
-    const QTextLine otherLine = currentTextLine(curs);
-    if (otherLine.textStart() != line.textStart()
-        || wordEndPos == wordStartPos)
-        return;
-
-    const qreal wordEndX = line.cursorToX(curs.position() - blockPos) + blockCoordinates.x();
-
-    if (!wordSelectionEnabled && (mouseXPosition < wordStartX || mouseXPosition > wordEndX))
-        return;
-
-    if (suggestedNewPosition < selectedWordOnDoubleClick.position()) {
-        cursor.setPosition(selectedWordOnDoubleClick.selectionEnd());
-        setCursorPosition(wordStartPos, QTextCursor::KeepAnchor);
-    } else {
-        cursor.setPosition(selectedWordOnDoubleClick.selectionStart());
-        setCursorPosition(wordEndPos, QTextCursor::KeepAnchor);
-    }
-
-    if (interactionFlags & Qt::TextSelectableByMouse) {
-#ifndef QT_NO_CLIPBOARD
-        setClipboardSelection();
-#endif
-        selectionChanged(true);
-    }
-}
-
-void TextControlPrivate::extendBlockwiseSelection(int suggestedNewPosition)
-{
-    Q_Q(TextControl);
-
-    // if inside the initial selected line keep that
-    if (suggestedNewPosition >= selectedBlockOnTripleClick.selectionStart()
-        && suggestedNewPosition <= selectedBlockOnTripleClick.selectionEnd()) {
-        q->setTextCursor(selectedBlockOnTripleClick);
-        return;
-    }
-
-    if (suggestedNewPosition < selectedBlockOnTripleClick.position()) {
-        cursor.setPosition(selectedBlockOnTripleClick.selectionEnd());
-        cursor.setPosition(suggestedNewPosition, QTextCursor::KeepAnchor);
-        cursor.movePosition(QTextCursor::StartOfBlock, QTextCursor::KeepAnchor);
-    } else {
-        cursor.setPosition(selectedBlockOnTripleClick.selectionStart());
-        cursor.setPosition(suggestedNewPosition, QTextCursor::KeepAnchor);
-        cursor.movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);
-        cursor.movePosition(QTextCursor::NextCharacter, QTextCursor::KeepAnchor);
-    }
-
-    if (interactionFlags & Qt::TextSelectableByMouse) {
-#ifndef QT_NO_CLIPBOARD
-        setClipboardSelection();
-#endif
-        selectionChanged(true);
-    }
-}
-
-void TextControl::undo()
-{
-    Q_D(TextControl);
-    d->repaintSelection();
-    const int oldCursorPos = d->cursor.position();
-    d->doc->undo(&d->cursor);
-    if (d->cursor.position() != oldCursorPos)
-        emit cursorPositionChanged();
-    updateCursorRectangle(true);
-}
-
-void TextControl::redo()
-{
-    Q_D(TextControl);
-    d->repaintSelection();
-    const int oldCursorPos = d->cursor.position();
-    d->doc->redo(&d->cursor);
-    if (d->cursor.position() != oldCursorPos)
-        emit cursorPositionChanged();
-    updateCursorRectangle(true);
-}
-
-void TextControl::clear()
-{
-    Q_D(TextControl);
-    d->cursor.select(QTextCursor::Document);
-    d->cursor.removeSelectedText();
-}
-
-TextControl::TextControl(QTextDocument *doc, QObject *parent)
-    : QObject(*new TextControlPrivate, parent)
-{
-    Q_D(TextControl);
-    Q_ASSERT(doc);
-
-    QAbstractTextDocumentLayout *layout = doc->documentLayout();
-    qmlobject_connect(layout, QAbstractTextDocumentLayout, SIGNAL(update(QRectF)), this, TextControl, SIGNAL(updateRequest()));
-    qmlobject_connect(layout, QAbstractTextDocumentLayout, SIGNAL(updateBlock(QTextBlock)), this, TextControl, SIGNAL(updateRequest()));
-    qmlobject_connect(doc, QTextDocument, SIGNAL(contentsChanged()), this, TextControl, SIGNAL(textChanged()));
-    qmlobject_connect(doc, QTextDocument, SIGNAL(contentsChanged()), this, TextControl, SLOT(_q_updateCurrentCharFormatAndSelection()));
-    qmlobject_connect(doc, QTextDocument, SIGNAL(cursorPositionChanged(QTextCursor)), this, TextControl, SLOT(_q_updateCursorPosChanged(QTextCursor)));
-    connect(doc, &QTextDocument::contentsChange, this, &TextControl::contentsChange);
-
-    layout->setProperty("cursorWidth", textCursorWidth);
-
-    d->doc = doc;
-    d->cursor = QTextCursor(doc);
-    d->lastCharFormat = d->cursor.charFormat();
-    doc->setPageSize(QSizeF(0, 0));
-    doc->setModified(false);
-    doc->setUndoRedoEnabled(true);
-}
-
-TextControl::~TextControl()
-{
-}
-
-QTextDocument *TextControl::document() const
-{
-    Q_D(const TextControl);
-    return d->doc;
-}
-
-void TextControl::updateCursorRectangle(bool force)
-{
-    Q_D(TextControl);
-    const bool update = d->cursorRectangleChanged || force;
-    d->cursorRectangleChanged = false;
-    if (update)
-        emit cursorRectangleChanged();
-}
-
-void TextControl::clearSelectionOnFocus(bool value){
-    Q_D(TextControl);
-    d->clearSelectionOnFocus = value;
-}
-
-void TextControl::setTextCursor(const QTextCursor &cursor)
-{
-    Q_D(TextControl);
-#ifndef QT_NO_IM
-    d->commitPreedit();
-#endif
-    d->cursorIsFocusIndicator = false;
-    const bool posChanged = cursor.position() != d->cursor.position();
-    const QTextCursor oldSelection = d->cursor;
-    d->cursor = cursor;
-    d->cursorOn = d->hasFocus && (d->interactionFlags & Qt::TextEditable);
-    d->_q_updateCurrentCharFormatAndSelection();
-    updateCursorRectangle(true);
-    d->repaintOldAndNewSelection(oldSelection);
-    if (posChanged)
-        emit cursorPositionChanged();
-}
-
-QTextCursor TextControl::textCursor() const
-{
-    Q_D(const TextControl);
-    return d->cursor;
-}
-
-#ifndef QT_NO_CLIPBOARD
-
-void TextControl::cut()
-{
-    Q_D(TextControl);
-    if (!(d->interactionFlags & Qt::TextEditable) || !d->cursor.hasSelection())
-        return;
-    copy();
-    d->cursor.removeSelectedText();
-}
-
-void TextControl::copy()
-{
-    Q_D(TextControl);
-    if (!d->cursor.hasSelection())
-        return;
-    QMimeData *data = createMimeDataFromSelection();
-    QGuiApplication::clipboard()->setMimeData(data);
-}
-
-void TextControl::paste(QClipboard::Mode mode)
-{
-    const QMimeData *md = QGuiApplication::clipboard()->mimeData(mode);
-    if (md)
-        insertFromMimeData(md);
-}
-#endif
-
-void TextControl::selectAll()
-{
-    Q_D(TextControl);
-    const int selectionLength = qAbs(d->cursor.position() - d->cursor.anchor());
-    d->cursor.select(QTextCursor::Document);
-    d->selectionChanged(selectionLength != qAbs(d->cursor.position() - d->cursor.anchor()));
-    d->cursorIsFocusIndicator = false;
-    emit updateRequest();
-}
-
-void TextControl::processEvent(QEvent *e, const QPointF &coordinateOffset)
-{
-    QMatrix m;
-    m.translate(coordinateOffset.x(), coordinateOffset.y());
-    processEvent(e, m);
-}
-
-void TextControl::processEvent(QEvent *e, const QMatrix &matrix)
-{
-    Q_D(TextControl);
-    if (d->interactionFlags == Qt::NoTextInteraction) {
-        e->ignore();
-        return;
-    }
-
-    // PALETTE
-    QMouseEvent *ev = nullptr;
-    if (e->type() == QEvent::MouseButtonPress || e->type() == QEvent::MouseMove ||
-            e->type() == QEvent::MouseButtonRelease || e->type() == QEvent::MouseButtonDblClick)
-    {
-        ev = static_cast<QMouseEvent *>(e);
-        QPointF mousePos = ev->localPos();
-        int oldy = mousePos.y();
-        mousePos.setY(d->textEdit->getPaletteManager()->positionOffset(oldy));
-#if (QT_VERSION > QT_VERSION_CHECK(5,7,1))
-        ev->setLocalPos(mousePos);
-#else
-        ev = new QMouseEvent(ev->type(), mousePos, ev->windowPos(), ev->screenPos(), ev->button(), ev->buttons(), ev->modifiers(), ev->source());
-        e = ev;
-#endif
-    }
-
-    switch (e->type()) {
-        case QEvent::KeyPress:
-            d->keyPressEvent(static_cast<QKeyEvent *>(e));
-            break;
-        case QEvent::KeyRelease:
-            d->keyReleaseEvent(static_cast<QKeyEvent *>(e));
-            break;
-        case QEvent::MouseButtonPress: {
-            QMouseEvent *ev = static_cast<QMouseEvent *>(e);
-            d->mousePressEvent(ev, matrix.map(ev->localPos()));
-            break; }
-        case QEvent::MouseMove: {
-            QMouseEvent *ev = static_cast<QMouseEvent *>(e);
-            d->mouseMoveEvent(ev, matrix.map(ev->localPos()));
-            break; }
-        case QEvent::MouseButtonRelease: {
-            QMouseEvent *ev = static_cast<QMouseEvent *>(e);
-            d->mouseReleaseEvent(ev, matrix.map(ev->localPos()));
-            break; }
-        case QEvent::MouseButtonDblClick: {
-            QMouseEvent *ev = static_cast<QMouseEvent *>(e);
-            d->mouseDoubleClickEvent(ev, matrix.map(ev->localPos()));
-            break; }
-        case QEvent::HoverEnter:
-        case QEvent::HoverMove:
-        case QEvent::HoverLeave: {
-            QHoverEvent *ev = static_cast<QHoverEvent *>(e);
-            d->hoverEvent(ev, matrix.map(ev->posF()));
-            break; }
-#ifndef QT_NO_IM
-        case QEvent::InputMethod:
-            d->inputMethodEvent(static_cast<QInputMethodEvent *>(e));
-            break;
-#endif
-        case QEvent::FocusIn:
-        case QEvent::FocusOut:
-            d->focusEvent(static_cast<QFocusEvent *>(e));
-            break;
-
-        case QEvent::ShortcutOverride:
-            if (d->interactionFlags & Qt::TextEditable) {
-                QKeyEvent* ke = static_cast<QKeyEvent *>(e);
-                if (ke->modifiers() == Qt::NoModifier
-                    || ke->modifiers() == Qt::ShiftModifier
-                    || ke->modifiers() == Qt::KeypadModifier) {
-                    if (ke->key() < Qt::Key_Escape) {
-                        ke->accept();
-                    } else {
-                        switch (ke->key()) {
-                            case Qt::Key_Return:
-                            case Qt::Key_Enter:
-                            case Qt::Key_Delete:
-                            case Qt::Key_Home:
-                            case Qt::Key_End:
-                            case Qt::Key_Backspace:
-                            case Qt::Key_Left:
-                            case Qt::Key_Right:
-                            case Qt::Key_Up:
-                            case Qt::Key_Down:
-                            case Qt::Key_Tab:
-
-                            if (ke->key() == Qt::Key_Return)
-                            {
-                                auto layout = d->textEdit->getDocumentLayout();
-                                std::pair<int, int> result(-1, -1);
-                                if (layout)
-                                {
-                                    result = layout->isFirstLineOfCollapsedSection(d->cursor.block().blockNumber());
-                                }
-                                if (layout && result.first != -1)
-                                {
-                                    layout->expandLines(result.first, result.second);
-                                }
-                            }
-                            ke->accept();
-                        default:
-                            break;
-                        }
-                    }
-#ifndef QT_NO_SHORTCUT
-                } else if (ke == QKeySequence::Copy
-                           || ke == QKeySequence::Paste
-                           || ke == QKeySequence::Cut
-                           || ke == QKeySequence::Redo
-                           || ke == QKeySequence::Undo
-                           || ke == QKeySequence::MoveToNextWord
-                           || ke == QKeySequence::MoveToPreviousWord
-                           || ke == QKeySequence::MoveToStartOfDocument
-                           || ke == QKeySequence::MoveToEndOfDocument
-                           || ke == QKeySequence::SelectNextWord
-                           || ke == QKeySequence::SelectPreviousWord
-                           || ke == QKeySequence::SelectStartOfLine
-                           || ke == QKeySequence::SelectEndOfLine
-                           || ke == QKeySequence::SelectStartOfBlock
-                           || ke == QKeySequence::SelectEndOfBlock
-                           || ke == QKeySequence::SelectStartOfDocument
-                           || ke == QKeySequence::SelectEndOfDocument
-                           || ke == QKeySequence::SelectAll
-                          ) {
-
-                    auto layout = d->textEdit->getDocumentLayout();
-                    std::pair<int, int> result(-1, -1);
-                    if (layout && ke == QKeySequence::Paste)
-                    {
-                        result = layout->isFirstLineOfCollapsedSection(d->cursor.block().blockNumber());
-                    }
-                    if (result.first != -1)
-                    {
-                        layout->expandLines(result.first, result.second);
-                    }
-
-                    ke->accept();
-#endif
-                }
-            }
-            break;
-        default:
-            break;
-    }
-
-#if (QT_VERSION <= QT_VERSION_CHECK(5,7,1))
-    if (ev) delete ev;
-#endif
-}
-
-bool TextControl::event(QEvent *e)
-{
-    return QObject::event(e);
-}
-
-void TextControl::timerEvent(QTimerEvent *e)
-{
-    Q_D(TextControl);
-    if (e->timerId() == d->cursorBlinkTimer.timerId()) {
-        d->cursorOn = !d->cursorOn;
-
-        d->repaintCursor();
-    } else if (e->timerId() == d->tripleClickTimer.timerId()) {
-        d->tripleClickTimer.stop();
-    }
-}
-
-void TextControl::setPlainText(const QString &text)
-{
-    Q_D(TextControl);
-    d->setContent(Qt::PlainText, text);
-}
-
-void TextControl::setHtml(const QString &text)
-{
-    Q_D(TextControl);
-    d->setContent(Qt::RichText, text);
-}
-
-
-void TextControlPrivate::keyReleaseEvent(QKeyEvent *e)
-{
-    if (e->key() == Qt::Key_Back) {
-         e->ignore();
-         return;
-    }
-    return;
-}
-
-void TextControlPrivate::keyPressEvent(QKeyEvent *e)
-{
-    Q_Q(TextControl);
-
-/*    //PALETTE TEST
-    static int cnt = 0;
-
-    switch (cnt)
-    {
-    case 0: textEdit->linePaletteAdded(8, 9, 35, textEdit); break;
-    case 1: textEdit->linePaletteAdded(15, 17, 75, nullptr); break;
-    case 2: textEdit->linePaletteRemoved(nullptr); break;
-    case 3: textEdit->linePaletteHeightChanged(textEdit, 55); break;
-    }
-
-    cnt++;*/
-
-    if (e->key() == Qt::Key_Back) {
-         e->ignore();
-         return;
-    }
-
-#ifndef QT_NO_SHORTCUT
-    if (e == QKeySequence::SelectAll) {
-            e->accept();
-            q->selectAll();
-            return;
-    }
-#ifndef QT_NO_CLIPBOARD
-    else if (e == QKeySequence::Copy) {
-            e->accept();
-            q->copy();
-            return;
-    }
-#endif
-#endif // QT_NO_SHORTCUT
-
-    if (interactionFlags & Qt::TextSelectableByKeyboard
-        && cursorMoveKeyEvent(e))
-        goto accept;
-
-    if (!(interactionFlags & Qt::TextEditable)) {
-        e->ignore();
-        return;
-    }
-
-    if (e->key() == Qt::Key_Direction_L || e->key() == Qt::Key_Direction_R) {
-        QTextBlockFormat fmt;
-        fmt.setLayoutDirection((e->key() == Qt::Key_Direction_L) ? Qt::LeftToRight : Qt::RightToLeft);
-        cursor.mergeBlockFormat(fmt);
-        goto accept;
-    }
-
-    // schedule a repaint of the region of the cursor, as when we move it we
-    // want to make sure the old cursor disappears (not noticeable when moving
-    // only a few pixels but noticeable when jumping between cells in tables for
-    // example)
-    repaintSelection();
-
-    if (e->key() == Qt::Key_Backspace && !(e->modifiers() & ~Qt::ShiftModifier)) {
-        QTextBlockFormat blockFmt = cursor.blockFormat();
-        QTextList *list = cursor.currentList();
-        if (list && cursor.atBlockStart() && !cursor.hasSelection()) {
-            list->remove(cursor.block());
-        } else if (cursor.atBlockStart() && blockFmt.indent() > 0) {
-            blockFmt.setIndent(blockFmt.indent() - 1);
-            cursor.setBlockFormat(blockFmt);
-        } else {
-            QTextCursor localCursor = cursor;
-            std::pair<int, int> result(-1, -1);
-            if (textEdit && textEdit->getDocumentLayout())
-            {
-                result = textEdit->getDocumentLayout()->isLineAfterCollapsedSection(localCursor.block().blockNumber());
-            }
-
-            if (result.first != -1 && localCursor.atBlockStart())
-            {
-                textEdit->manageExpandCollapse(result.first, false);
-            }
-            else {
-                localCursor.deletePreviousChar();
-            }
-
-        }
-        goto accept;
-    }
-#ifndef QT_NO_SHORTCUT
-      else if (e == QKeySequence::InsertParagraphSeparator) {
-        cursor.insertBlock();
-        e->accept();
-        goto accept;
-    } else if (e == QKeySequence::InsertLineSeparator) {
-        cursor.insertText(QString(QChar::LineSeparator));
-        e->accept();
-        goto accept;
-    }
-#endif
-    if (false) {
-    }
-#ifndef QT_NO_SHORTCUT
-    else if (e == QKeySequence::Undo) {
-            q->undo();
-    }
-    else if (e == QKeySequence::Redo) {
-           q->redo();
-    }
-#ifndef QT_NO_CLIPBOARD
-    else if (e == QKeySequence::Cut) {
-           q->cut();
-    }
-    else if (e == QKeySequence::Paste) {
-        QClipboard::Mode mode = QClipboard::Clipboard;
-        q->paste(mode);
-    }
-#endif
-    else if (e == QKeySequence::Delete) {
-        QTextCursor localCursor = cursor;
-        localCursor.deleteChar();
-    }
-    else if (e == QKeySequence::DeleteEndOfWord) {
-        if (!cursor.hasSelection())
-            cursor.movePosition(QTextCursor::NextWord, QTextCursor::KeepAnchor);
-        cursor.removeSelectedText();
-    }
-    else if (e == QKeySequence::DeleteStartOfWord) {
-        if (!cursor.hasSelection())
-            cursor.movePosition(QTextCursor::PreviousWord, QTextCursor::KeepAnchor);
-        cursor.removeSelectedText();
-    }
-    else if (e == QKeySequence::DeleteEndOfLine) {
-        QTextBlock block = cursor.block();
-        if (cursor.position() == block.position() + block.length() - 2)
-            cursor.movePosition(QTextCursor::Right, QTextCursor::KeepAnchor);
-        else
-            cursor.movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);
-        cursor.removeSelectedText();
-    }
-#endif // QT_NO_SHORTCUT
-    else {
-        goto process;
-    }
-    goto accept;
-
-process:
-    {
-        QString text = e->text();
-        if (!text.isEmpty() && (text.at(0).isPrint() || text.at(0) == QLatin1Char('\t'))) {
-            cursor.insertText(text);
-            selectionChanged();
-        } else {
-            e->ignore();
-            return;
-        }
-    }
-
- accept:
-
-    e->accept();
-    cursorOn = true;
-
-    q->updateCursorRectangle(true);
-    updateCurrentCharFormat();
-}
-
-QRectF TextControlPrivate::rectForPosition(int position) const
-{
-    Q_Q(const TextControl);
-    const QTextBlock block = doc->findBlock(position);
-    if (!block.isValid())
-        return QRectF();
-    const QTextLayout *layout = block.layout();
-    const QPointF layoutPos = q->blockBoundingRect(block).topLeft();
-    int relativePos = position - block.position();
-#ifndef QT_NO_IM
-    if (preeditCursor != 0) {
-        int preeditPos = layout->preeditAreaPosition();
-        if (relativePos == preeditPos)
-            relativePos += preeditCursor;
-        else if (relativePos > preeditPos)
-            relativePos += layout->preeditAreaText().length();
-    }
-#endif
-    QTextLine line = layout->lineForTextPosition(relativePos);
-
-    QRectF r;
-     int offset = textEdit->getPaletteManager()->drawingOffset(block.blockNumber(), true);
-
-    if (line.isValid()) {
-        qreal x = line.cursorToX(relativePos);
-        qreal w = 0;
-
-        r = QRectF(layoutPos.x() + x, layoutPos.y() + line.y() + offset, textCursorWidth + w, line.height());
-    } else {
-        r = QRectF(layoutPos.x(), layoutPos.y() + offset, textCursorWidth, 10); // #### correct height
-    }
-
-    return r;
-}
-
-void TextControlPrivate::mousePressEvent(QMouseEvent *e, const QPointF &pos)
-{
-    Q_Q(TextControl);
-
-    mousePressed = (interactionFlags & Qt::TextSelectableByMouse) && (e->button() & Qt::LeftButton);
-    mousePressPos = pos.toPoint();
-
-    if (sendMouseEventToInputContext(e, pos))
-        return;
-
-    if (interactionFlags & Qt::LinksAccessibleByMouse) {
-        anchorOnMousePress = q->anchorAt(pos);
-
-        if (cursorIsFocusIndicator) {
-            cursorIsFocusIndicator = false;
-            repaintSelection();
-            cursor.clearSelection();
-        }
-    }
-    if (e->button() & Qt::MiddleButton) {
-        return;
-    } else  if (!(e->button() & Qt::LeftButton)) {
-        e->ignore();
-        return;
-    } else if (!(interactionFlags & (Qt::TextSelectableByMouse | Qt::TextEditable))) {
-        if (!(interactionFlags & Qt::LinksAccessibleByMouse))
-            e->ignore();
-        return;
-    }
-
-    cursorIsFocusIndicator = false;
-    const QTextCursor oldSelection = cursor;
-    const int oldCursorPos = cursor.position();
-
-#ifndef QT_NO_IM
-    commitPreedit();
-#endif
-
-    if (tripleClickTimer.isActive()
-        && ((pos - tripleClickPoint).toPoint().manhattanLength() < QGuiApplication::styleHints()->startDragDistance())) {
-
-        cursor.movePosition(QTextCursor::StartOfBlock);
-        cursor.movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);
-        cursor.movePosition(QTextCursor::NextCharacter, QTextCursor::KeepAnchor);
-        selectedBlockOnTripleClick = cursor;
-
-        anchorOnMousePress = QString();
-
-        tripleClickTimer.stop();
-    } else {
-        int cursorPos = q->hitTest(pos, Qt::FuzzyHit);
-        if (cursorPos == -1) {
-            e->ignore();
-            return;
-        }
-
-        if (e->modifiers() == Qt::ShiftModifier && (interactionFlags & Qt::TextSelectableByMouse)) {
-            if (wordSelectionEnabled && !selectedWordOnDoubleClick.hasSelection()) {
-                selectedWordOnDoubleClick = cursor;
-                selectedWordOnDoubleClick.select(QTextCursor::WordUnderCursor);
-            }
-
-            if (selectedBlockOnTripleClick.hasSelection())
-                extendBlockwiseSelection(cursorPos);
-            else if (selectedWordOnDoubleClick.hasSelection())
-                extendWordwiseSelection(cursorPos, pos.x());
-            else if (!wordSelectionEnabled)
-                setCursorPosition(cursorPos, QTextCursor::KeepAnchor);
-        } else {
-            setCursorPosition(cursorPos);
-        }
-    }
-
-    if (cursor.position() != oldCursorPos) {
-        q->updateCursorRectangle(true);
-        emit q->cursorPositionChanged();
-    }
-    if (interactionFlags & Qt::TextEditable)
-        _q_updateCurrentCharFormatAndSelection();
-    else
-        selectionChanged();
-    repaintOldAndNewSelection(oldSelection);
-    hadSelectionOnMousePress = cursor.hasSelection();
-}
-
-void TextControlPrivate::mouseMoveEvent(QMouseEvent *e, const QPointF &mousePos)
-{
-    Q_Q(TextControl);
-
-    if ((e->buttons() & Qt::LeftButton)) {
-        const bool editable = interactionFlags & Qt::TextEditable;
-
-        if (!(mousePressed
-              || editable
-              || selectedWordOnDoubleClick.hasSelection()
-              || selectedBlockOnTripleClick.hasSelection()))
-            return;
-
-        const QTextCursor oldSelection = cursor;
-        const int oldCursorPos = cursor.position();
-
-        if (!mousePressed)
-            return;
-
-        const qreal mouseX = qreal(mousePos.x());
-
-        int newCursorPos = q->hitTest(mousePos, Qt::FuzzyHit);
-
-#ifndef QT_NO_IM
-        if (isPreediting()) {
-            // note: oldCursorPos not including preedit
-            int selectionStartPos = q->hitTest(mousePressPos, Qt::FuzzyHit);
-            if (newCursorPos != selectionStartPos) {
-                commitPreedit();
-                // commit invalidates positions
-                newCursorPos = q->hitTest(mousePos, Qt::FuzzyHit);
-                selectionStartPos = q->hitTest(mousePressPos, Qt::FuzzyHit);
-                setCursorPosition(selectionStartPos);
-            }
-        }
-#endif
-
-        if (newCursorPos == -1)
-            return;
-
-        if (wordSelectionEnabled && !selectedWordOnDoubleClick.hasSelection()) {
-            selectedWordOnDoubleClick = cursor;
-            selectedWordOnDoubleClick.select(QTextCursor::WordUnderCursor);
-        }
-
-        if (selectedBlockOnTripleClick.hasSelection())
-            extendBlockwiseSelection(newCursorPos);
-        else if (selectedWordOnDoubleClick.hasSelection())
-            extendWordwiseSelection(newCursorPos, mouseX);
-#ifndef QT_NO_IM
-        else if (!isPreediting())
-            setCursorPosition(newCursorPos, QTextCursor::KeepAnchor);
-#endif
-
-        if (interactionFlags & Qt::TextEditable) {
-            if (cursor.position() != oldCursorPos) {
-                emit q->cursorPositionChanged();
-                q->updateCursorRectangle(true);
-            }
-            _q_updateCurrentCharFormatAndSelection();
-#ifndef QT_NO_IM
-            if (qGuiApp)
-                qGuiApp->inputMethod()->update(Qt::ImQueryInput);
-#endif
-        } else if (cursor.position() != oldCursorPos) {
-            emit q->cursorPositionChanged();
-            q->updateCursorRectangle(true);
-        }
-        selectionChanged(true);
-        repaintOldAndNewSelection(oldSelection);
-    }
-
-    sendMouseEventToInputContext(e, mousePos);
-}
-
-void TextControlPrivate::mouseReleaseEvent(QMouseEvent *e, const QPointF &pos)
-{
-    Q_Q(TextControl);
-
-    if (sendMouseEventToInputContext(e, pos))
-        return;
-
-    const QTextCursor oldSelection = cursor;
-    const int oldCursorPos = cursor.position();
-
-    if (mousePressed) {
-        mousePressed = false;
-#ifndef QT_NO_CLIPBOARD
-        setClipboardSelection();
-        selectionChanged(true);
-    } else if (e->button() == Qt::MidButton
-               && (interactionFlags & Qt::TextEditable)
-               && QGuiApplication::clipboard()->supportsSelection()) {
-        setCursorPosition(pos);
-        const QMimeData *md = QGuiApplication::clipboard()->mimeData(QClipboard::Selection);
-        if (md)
-            q->insertFromMimeData(md);
-#endif
-    }
-
-    repaintOldAndNewSelection(oldSelection);
-
-    if (cursor.position() != oldCursorPos) {
-        emit q->cursorPositionChanged();
-        q->updateCursorRectangle(true);
-    }
-
-    if (interactionFlags & Qt::LinksAccessibleByMouse) {
-        if (!(e->button() & Qt::LeftButton))
-            return;
-
-        const QString anchor = q->anchorAt(pos);
-
-        if (anchor.isEmpty())
-            return;
-
-        if (!cursor.hasSelection()
-            || (anchor == anchorOnMousePress && hadSelectionOnMousePress)) {
-
-            const int anchorPos = q->hitTest(pos, Qt::ExactHit);
-            if (anchorPos != -1) {
-                cursor.setPosition(anchorPos);
-
-                QString anchor = anchorOnMousePress;
-                anchorOnMousePress = QString();
-                activateLinkUnderCursor(anchor);
-            }
-        }
-    }
-}
-
-void TextControlPrivate::mouseDoubleClickEvent(QMouseEvent *e, const QPointF &pos)
-{
-    Q_Q(TextControl);
-
-    if (e->button() == Qt::LeftButton && (interactionFlags & Qt::TextSelectableByMouse)) {
-#ifndef QT_NO_IM
-        commitPreedit();
-#endif
-
-        const QTextCursor oldSelection = cursor;
-        setCursorPosition(pos);
-        QTextLine line = currentTextLine(cursor);
-        bool doEmit = false;
-        if (line.isValid() && line.textLength()) {
-            cursor.select(QTextCursor::WordUnderCursor);
-            doEmit = true;
-        }
-        repaintOldAndNewSelection(oldSelection);
-
-        cursorIsFocusIndicator = false;
-        selectedWordOnDoubleClick = cursor;
-
-        tripleClickPoint = pos;
-        tripleClickTimer.start(QGuiApplication::styleHints()->mouseDoubleClickInterval(), q);
-        if (doEmit) {
-            selectionChanged();
-#ifndef QT_NO_CLIPBOARD
-            setClipboardSelection();
-#endif
-            emit q->cursorPositionChanged();
-            q->updateCursorRectangle(true);
-        }
-    } else if (!sendMouseEventToInputContext(e, pos)) {
-        e->ignore();
-    }
-}
-
-bool TextControlPrivate::sendMouseEventToInputContext(QMouseEvent *e, const QPointF &pos)
-{
-#if !defined(QT_NO_IM)
-    Q_Q(TextControl);
-
-    Q_UNUSED(e);
-
-    if (isPreediting()) {
-        QTextLayout *layout = cursor.block().layout();
-        int cursorPos = q->hitTest(pos, Qt::FuzzyHit) - cursor.position();
-
-        if (cursorPos >= 0 && cursorPos <= layout->preeditAreaText().length()) {
-            if (e->type() == QEvent::MouseButtonRelease) {
-                QGuiApplication::inputMethod()->invokeAction(QInputMethod::Click, cursorPos);
-            }
-
-            return true;
-        }
-    }
-#else
-    Q_UNUSED(e);
-    Q_UNUSED(pos);
-#endif
-    return false;
-}
-
-#ifndef QT_NO_IM
-void TextControlPrivate::inputMethodEvent(QInputMethodEvent *e)
-{
-    Q_Q(TextControl);
-    if (!(interactionFlags & Qt::TextEditable) || cursor.isNull()) {
-        e->ignore();
-        return;
-    }
-    bool isGettingInput = !e->commitString().isEmpty()
-            || e->preeditString() != cursor.block().layout()->preeditAreaText()
-            || e->replacementLength() > 0;
-    bool forceSelectionChanged = false;
-
-    cursor.beginEditBlock();
-    if (isGettingInput) {
-        cursor.removeSelectedText();
-    }
-
-    // insert commit string
-    if (!e->commitString().isEmpty() || e->replacementLength()) {
-        QTextCursor c = cursor;
-        c.setPosition(c.position() + e->replacementStart());
-        c.setPosition(c.position() + e->replacementLength(), QTextCursor::KeepAnchor);
-        c.insertText(e->commitString());
-    }
-
-    for (int i = 0; i < e->attributes().size(); ++i) {
-        const QInputMethodEvent::Attribute &a = e->attributes().at(i);
-        if (a.type == QInputMethodEvent::Selection) {
-            QTextCursor oldCursor = cursor;
-            int blockStart = a.start + cursor.block().position();
-            cursor.setPosition(blockStart, QTextCursor::MoveAnchor);
-            cursor.setPosition(blockStart + a.length, QTextCursor::KeepAnchor);
-            repaintOldAndNewSelection(oldCursor);
-            forceSelectionChanged = true;
-        }
-    }
-
-    QTextBlock block = cursor.block();
-    QTextLayout *layout = block.layout();
-    if (isGettingInput) {
-        layout->setPreeditArea(cursor.position() - block.position(), e->preeditString());
-        emit q->preeditTextChanged();
-    }
-    QVector<QTextLayout::FormatRange> overrides;
-    const int oldPreeditCursor = preeditCursor;
-    preeditCursor = e->preeditString().length();
-    hasImState = !e->preeditString().isEmpty();
-    cursorVisible = true;
-    for (int i = 0; i < e->attributes().size(); ++i) {
-        const QInputMethodEvent::Attribute &a = e->attributes().at(i);
-        if (a.type == QInputMethodEvent::Cursor) {
-            hasImState = true;
-            preeditCursor = a.start;
-            cursorVisible = a.length != 0;
-        } else if (a.type == QInputMethodEvent::TextFormat) {
-            hasImState = true;
-            QTextCharFormat f = qvariant_cast<QTextFormat>(a.value).toCharFormat();
-            if (f.isValid()) {
-                QTextLayout::FormatRange o;
-                o.start = a.start + cursor.position() - block.position();
-                o.length = a.length;
-                o.format = f;
-                overrides.append(o);
-            }
-        }
-    }
-    layout->setFormats(overrides);
-
-    cursor.endEditBlock();
-
-
-    // THIS IS TO BE REMOVED
-//    QTextCursorPrivate *cursor_d = QTextCursorPrivate::getPrivate(&cursor);
-//    if (cursor_d)
-//        cursor_d->setX();
-
-    // TO BE REMOVED
-
-
-    q->updateCursorRectangle(oldPreeditCursor != preeditCursor || forceSelectionChanged || isGettingInput);
-    selectionChanged(forceSelectionChanged);
-}
-
-QVariant TextControl::inputMethodQuery(Qt::InputMethodQuery property) const
-{
-    return inputMethodQuery(property, QVariant());
-}
-
-QVariant TextControl::inputMethodQuery(Qt::InputMethodQuery property, QVariant argument) const
-{
-    Q_D(const TextControl);
-    QTextBlock block = d->cursor.block();
-    switch (property) {
-    case Qt::ImCursorRectangle:
-        return cursorRect();
-    case Qt::ImAnchorRectangle:
-        return anchorRect();
-    case Qt::ImFont:
-        return QVariant(d->cursor.charFormat().font());
-    case Qt::ImCursorPosition: {
-        const QPointF pt = argument.toPointF();
-        if (!pt.isNull())
-            return QVariant(d->doc->documentLayout()->hitTest(pt, Qt::FuzzyHit) - block.position());
-        return QVariant(d->cursor.position() - block.position());
-    }
-    case Qt::ImSurroundingText:
-        return QVariant(block.text());
-    case Qt::ImCurrentSelection:
-        return QVariant(d->cursor.selectedText());
-    case Qt::ImMaximumTextLength:
-        return QVariant(); // No limit.
-    case Qt::ImAnchorPosition:
-        return QVariant(d->cursor.anchor() - block.position());
-    case Qt::ImAbsolutePosition:
-        return QVariant(d->cursor.anchor());
-    case Qt::ImTextAfterCursor:
-    {
-        int maxLength = argument.isValid() ? argument.toInt() : 1024;
-        QTextCursor tmpCursor = d->cursor;
-        int localPos = d->cursor.position() - block.position();
-        QString result = block.text().mid(localPos);
-        while (result.length() < maxLength) {
-            int currentBlock = tmpCursor.blockNumber();
-            tmpCursor.movePosition(QTextCursor::NextBlock);
-            if (tmpCursor.blockNumber() == currentBlock)
-                break;
-            result += QLatin1Char('\n') + tmpCursor.block().text();
-        }
-        return QVariant(result);
-    }
-    case Qt::ImTextBeforeCursor:
-    {
-        int maxLength = argument.isValid() ? argument.toInt() : 1024;
-        QTextCursor tmpCursor = d->cursor;
-        int localPos = d->cursor.position() - block.position();
-        int numBlocks = 0;
-        int resultLen = localPos;
-        while (resultLen < maxLength) {
-            int currentBlock = tmpCursor.blockNumber();
-            tmpCursor.movePosition(QTextCursor::PreviousBlock);
-            if (tmpCursor.blockNumber() == currentBlock)
-                break;
-            numBlocks++;
-            resultLen += tmpCursor.block().length();
-        }
-        QString result;
-        while (numBlocks) {
-            result += tmpCursor.block().text() + QLatin1Char('\n');
-            tmpCursor.movePosition(QTextCursor::NextBlock);
-            --numBlocks;
-        }
-        result += block.text().midRef(0,localPos);
-        return QVariant(result);
-    }
-    default:
-        return QVariant();
-    }
-}
-#endif // QT_NO_IM
-
-void TextControlPrivate::focusEvent(QFocusEvent *e)
-{
-    Q_Q(TextControl);
-    emit q->updateRequest();
-    hasFocus = e->gotFocus();
-    if (e->gotFocus()) {
-        setBlinkingCursorEnabled(interactionFlags & (Qt::TextEditable | Qt::TextSelectableByKeyboard));
-    } else {
-        setBlinkingCursorEnabled(false);
-
-        if (cursorIsFocusIndicator
-            && e->reason() != Qt::ActiveWindowFocusReason
-            && e->reason() != Qt::PopupFocusReason
-            && cursor.hasSelection() && clearSelectionOnFocus)
-        {
-            cursor.clearSelection();
-            emit q->selectionChanged();
-        }
-    }
-}
-
-void TextControlPrivate::hoverEvent(QHoverEvent *e, const QPointF &pos)
-{
-    Q_Q(TextControl);
-
-    QString link;
-    if (e->type() != QEvent::HoverLeave)
-        link = q->anchorAt(pos);
-
-    if (hoveredLink != link) {
-        hoveredLink = link;
-        emit q->linkHovered(link);
-    }
-}
-
-bool TextControl::hasImState() const
-{
-    Q_D(const TextControl);
-    return d->hasImState;
-}
-
-bool TextControl::cursorVisible() const
-{
-    Q_D(const TextControl);
-    return d->cursorVisible;
-}
-
-void TextControl::setCursorVisible(bool visible)
-{
-    Q_D(TextControl);
-    d->cursorVisible = visible;
-    d->setBlinkingCursorEnabled(d->cursorVisible
-            && (d->interactionFlags & (Qt::TextEditable | Qt::TextSelectableByKeyboard)));
-}
-
-QRectF TextControl::anchorRect() const
-{
-    Q_D(const TextControl);
-    QRectF rect;
-    QTextCursor cursor = d->cursor;
-    if (!cursor.isNull()) {
-        rect = d->rectForPosition(cursor.anchor());
-    }
-    return rect;
-}
-
-QRectF TextControl::cursorRect(const QTextCursor &cursor) const
-{
-    Q_D(const TextControl);
-    if (cursor.isNull())
-        return QRectF();
-
-    return d->rectForPosition(cursor.position());
-}
-
-QRectF TextControl::cursorRect() const
-{
-    Q_D(const TextControl);
-    return cursorRect(d->cursor);
-}
-
-QString TextControl::hoveredLink() const
-{
-    Q_D(const TextControl);
-    return d->hoveredLink;
-}
-
-QString TextControl::anchorAt(const QPointF &pos) const
-{
-    Q_D(const TextControl);
-    return d->doc->documentLayout()->anchorAt(pos);
-}
-
-void TextControl::setAcceptRichText(bool accept)
-{
-    Q_D(TextControl);
-    d->acceptRichText = accept;
-}
-
-void TextControl::moveCursor(QTextCursor::MoveOperation op, QTextCursor::MoveMode mode)
-{
-    Q_D(TextControl);
-    const QTextCursor oldSelection = d->cursor;
-    const bool moved = d->cursor.movePosition(op, mode);
-    d->_q_updateCurrentCharFormatAndSelection();
-    updateCursorRectangle(true);
-    d->repaintOldAndNewSelection(oldSelection);
-    if (moved)
-        emit cursorPositionChanged();
-}
-
-bool TextControl::canPaste() const
-{
-#ifndef QT_NO_CLIPBOARD
-    Q_D(const TextControl);
-    if (d->interactionFlags & Qt::TextEditable) {
-        const QMimeData *md = QGuiApplication::clipboard()->mimeData();
-        return md && canInsertFromMimeData(md);
-    }
-#endif
-    return false;
-}
-
-void TextControl::setCursorIsFocusIndicator(bool b)
-{
-    Q_D(TextControl);
-    d->cursorIsFocusIndicator = b;
-    d->repaintCursor();
-}
-
-void TextControl::setWordSelectionEnabled(bool enabled)
-{
-    Q_D(TextControl);
-    d->wordSelectionEnabled = enabled;
-}
-
-QMimeData *TextControl::createMimeDataFromSelection() const
-{
-    Q_D(const TextControl);
-    const QTextDocumentFragment fragment(d->cursor);
-    return new TextEditMimeData(fragment);
-}
-
-bool TextControl::canInsertFromMimeData(const QMimeData *source) const
-{
-    Q_D(const TextControl);
-    if (d->acceptRichText)
-        return source->hasText()
-            || source->hasHtml()
-            || source->hasFormat(QLatin1String("application/x-qrichtext"))
-            || source->hasFormat(QLatin1String("application/x-qt-richtext"));
-    else
-        return source->hasText();
-}
-
-void TextControl::insertFromMimeData(const QMimeData *source)
-{
-    Q_D(TextControl);
-    if (!(d->interactionFlags & Qt::TextEditable) || !source)
-        return;
-
-    bool hasData = false;
-    QTextDocumentFragment fragment;
-#ifndef QT_NO_TEXTHTMLPARSER
-    if (source->hasFormat(QLatin1String("application/x-qrichtext")) && d->acceptRichText) {
-        // x-qrichtext is always UTF-8 (taken from Qt3 since we don't use it anymore).
-        QString richtext = QString::fromUtf8(source->data(QLatin1String("application/x-qrichtext")));
-        richtext.prepend(QLatin1String("<meta name=\"qrichtext\" content=\"1\" />"));
-        fragment = QTextDocumentFragment::fromHtml(richtext, d->doc);
-        hasData = true;
-    } else if (source->hasHtml() && d->acceptRichText) {
-        fragment = QTextDocumentFragment::fromHtml(source->html(), d->doc);
-        hasData = true;
-    } else {
-        QString text = source->text();
-        if (!text.isNull()) {
-            fragment = QTextDocumentFragment::fromPlainText(text);
-            hasData = true;
-        }
-    }
-#else
-    fragment = QTextDocumentFragment::fromPlainText(source->text());
-#endif // QT_NO_TEXTHTMLPARSER
-
-    if (hasData)
-        d->cursor.insertFragment(fragment);
-    updateCursorRectangle(true);
-}
-
-void TextControlPrivate::activateLinkUnderCursor(QString href)
-{
-    QTextCursor oldCursor = cursor;
-
-    if (href.isEmpty()) {
-        QTextCursor tmp = cursor;
-        if (tmp.selectionStart() != tmp.position())
-            tmp.setPosition(tmp.selectionStart());
-        tmp.movePosition(QTextCursor::NextCharacter);
-        href = tmp.charFormat().anchorHref();
-    }
-    if (href.isEmpty())
-        return;
-
-    if (!cursor.hasSelection()) {
-        QTextBlock block = cursor.block();
-        const int cursorPos = cursor.position();
-
-        QTextBlock::Iterator it = block.begin();
-        QTextBlock::Iterator linkFragment;
-
-        for (; !it.atEnd(); ++it) {
-            QTextFragment fragment = it.fragment();
-            const int fragmentPos = fragment.position();
-            if (fragmentPos <= cursorPos &&
-                fragmentPos + fragment.length() > cursorPos) {
-                linkFragment = it;
-                break;
-            }
-        }
-
-        if (!linkFragment.atEnd()) {
-            it = linkFragment;
-            cursor.setPosition(it.fragment().position());
-            if (it != block.begin()) {
-                do {
-                    --it;
-                    QTextFragment fragment = it.fragment();
-                    if (fragment.charFormat().anchorHref() != href)
-                        break;
-                    cursor.setPosition(fragment.position());
-                } while (it != block.begin());
-            }
-
-            for (it = linkFragment; !it.atEnd(); ++it) {
-                QTextFragment fragment = it.fragment();
-                if (fragment.charFormat().anchorHref() != href)
-                    break;
-                cursor.setPosition(fragment.position() + fragment.length(), QTextCursor::KeepAnchor);
-            }
-        }
-    }
-
-    if (hasFocus) {
-        cursorIsFocusIndicator = true;
-    } else {
-        cursorIsFocusIndicator = false;
-        cursor.clearSelection();
-    }
-    repaintOldAndNewSelection(oldCursor);
-
-    emit q_func()->linkActivated(href);
-}
-
-#ifndef QT_NO_IM
-bool TextControlPrivate::isPreediting() const
-{
-    QTextLayout *layout = cursor.block().layout();
-    if (layout && !layout->preeditAreaText().isEmpty())
-        return true;
-
-    return false;
-}
-
-void TextControlPrivate::commitPreedit()
-{
-    Q_Q(TextControl);
-
-    if (!hasImState)
-        return;
-
-    QGuiApplication::inputMethod()->commit();
-
-    if (!hasImState)
-        return;
-
-    QInputMethodEvent event;
-    QCoreApplication::sendEvent(q->parent(), &event);
-}
-
-void TextControlPrivate::cancelPreedit()
-{
-    Q_Q(TextControl);
-
-    if (!hasImState)
-        return;
-
-    QGuiApplication::inputMethod()->reset();
-
-    QInputMethodEvent event;
-    QCoreApplication::sendEvent(q->parent(), &event);
-}
-#endif // QT_NO_IM
-
-void TextControl::setTextEdit(TextEdit* te)
-{
-    Q_D(TextControl);
-    d->textEdit = te;
-}
-
-void TextControl::setTextInteractionFlags(Qt::TextInteractionFlags flags)
-{
-    Q_D(TextControl);
-    if (flags == d->interactionFlags)
-        return;
-    d->interactionFlags = flags;
-
-    if (d->hasFocus)
-        d->setBlinkingCursorEnabled(flags & (Qt::TextEditable | Qt::TextSelectableByKeyboard));
-}
-
-Qt::TextInteractionFlags TextControl::textInteractionFlags() const
-{
-    Q_D(const TextControl);
-    return d->interactionFlags;
-}
-
-QString TextControl::toPlainText() const
-{
-    return document()->toPlainText();
-}
-
-#ifndef QT_NO_TEXTHTMLPARSER
-QString TextControl::toHtml() const
-{
-    return document()->toHtml();
-}
-#endif
-
-bool TextControl::cursorOn() const
-{
-    Q_D(const TextControl);
-    return d->cursorOn;
-}
-
-int TextControl::hitTest(const QPointF &point, Qt::HitTestAccuracy accuracy) const
-{
-    Q_D(const TextControl);
-    return d->doc->documentLayout()->hitTest(point, accuracy);
-}
-
-QRectF TextControl::blockBoundingRect(const QTextBlock &block) const
-{
-    Q_D(const TextControl);
-    return d->doc->documentLayout()->blockBoundingRect(block);
-}
-
-QString TextControl::preeditText() const
-{
-#ifndef QT_NO_IM
-    Q_D(const TextControl);
-    QTextLayout *layout = d->cursor.block().layout();
-    if (!layout)
-        return QString();
-
-    return layout->preeditAreaText();
-#else
-    return QString();
-#endif
-}
-
-
-QStringList TextEditMimeData::formats() const
-{
-    if (!fragment.isEmpty())
-        return QStringList() << QString::fromLatin1("text/plain") << QString::fromLatin1("text/html")
-#ifndef QT_NO_TEXTODFWRITER
-            << QString::fromLatin1("application/vnd.oasis.opendocument.text")
-#endif
-        ;
-    else
-        return QMimeData::formats();
-}
-
-QVariant TextEditMimeData::retrieveData(const QString &mimeType, QVariant::Type type) const
-{
-    if (!fragment.isEmpty())
-        setup();
-    return QMimeData::retrieveData(mimeType, type);
-}
-
-void TextEditMimeData::setup() const
-{
-    TextEditMimeData *that = const_cast<TextEditMimeData *>(this);
-#ifndef QT_NO_TEXTHTMLPARSER
-    that->setData(QLatin1String("text/html"), fragment.toHtml("utf-8").toUtf8());
-#endif
-#ifndef QT_NO_TEXTODFWRITER
-    {
-        QBuffer buffer;
-        QTextDocumentWriter writer(&buffer, "ODF");
-        writer.write(fragment);
-        buffer.close();
-        that->setData(QLatin1String("application/vnd.oasis.opendocument.text"), buffer.data());
-    }
-#endif
-    that->setText(fragment.toPlainText());
-    fragment = QTextDocumentFragment();
-}
-
-
-}
-
-#include "moc_textcontrol_p.cpp"
-
-#endif // QT_NO_TEXTCONTROL
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "textcontrol_p.h"
+#include "textcontrol_p_p.h"
+
+#ifndef QT_NO_TEXTCONTROL
+
+#include "qabstracttextdocumentlayout.h"
+#include <qcoreapplication.h>
+#include <qfont.h>
+#include <qevent.h>
+#include <qdebug.h>
+#include <qdrag.h>
+#include <qclipboard.h>
+#include <qtimer.h>
+#include <qinputmethod.h>
+#include "qtextdocument.h"
+#include "textdocumentlayout.h"
+
+#include "qtextlist.h"
+#include "qtextdocumentwriter.h"
+
+// <TOREMOVE>
+// See what is being used throughout
+#include "private/qqmlglobal_p.h"
+
+#include <qtextformat.h>
+#include <qdatetime.h>
+#include <qbuffer.h>
+#include <qguiapplication.h>
+#include <limits.h>
+#include <qtexttable.h>
+#include <qvariant.h>
+#include <qurl.h>
+#include <qstylehints.h>
+#include <qmetaobject.h>
+
+#include "textedit_p.h"
+//#include "palettemanager.h"
+#include "linecontrol.h"
+
+namespace lv {
+
+// ### these should come from QStyleHints
+const int textCursorWidth = 1;
+
+QT_BEGIN_NAMESPACE
+
+#ifndef QT_NO_CONTEXTMENU
+#endif
+
+// could go into QTextCursor...
+static QTextLine currentTextLine(const QTextCursor &cursor)
+{
+    const QTextBlock block = cursor.block();
+    if (!block.isValid())
+        return QTextLine();
+
+    const QTextLayout *layout = block.layout();
+    if (!layout)
+        return QTextLine();
+
+    const int relativePos = cursor.position() - block.position();
+    return layout->lineForTextPosition(relativePos);
+}
+
+TextControlPrivate::TextControlPrivate()
+    : doc(0),
+#ifndef QT_NO_IM
+      preeditCursor(0),
+#endif
+      interactionFlags(Qt::TextEditorInteraction),
+      cursorOn(false),
+      cursorIsFocusIndicator(false),
+      mousePressed(false),
+      lastSelectionState(false),
+      ignoreAutomaticScrollbarAdjustement(false),
+      overwriteMode(false),
+      acceptRichText(true),
+      cursorVisible(false),
+      cursorBlinkingEnabled(false),
+      hasFocus(false),
+      hadSelectionOnMousePress(false),
+      wordSelectionEnabled(false),
+      hasImState(false),
+      cursorRectangleChanged(false),
+      clearSelectionOnFocus(true),
+      lastSelectionStart(-1),
+      lastSelectionEnd(-1)
+{}
+
+bool TextControlPrivate::cursorMoveKeyEvent(QKeyEvent *e)
+{
+#ifdef QT_NO_SHORTCUT
+    Q_UNUSED(e);
+#endif
+
+    Q_Q(TextControl);
+    if (cursor.isNull())
+        return false;
+
+    const QTextCursor oldSelection = cursor;
+    const int oldCursorPos = cursor.position();
+
+    QTextCursor::MoveMode mode = QTextCursor::MoveAnchor;
+    QTextCursor::MoveOperation op = QTextCursor::NoMove;
+
+    if (false) {
+    }
+#ifndef QT_NO_SHORTCUT
+    if (e == QKeySequence::MoveToNextChar) {
+            op = QTextCursor::Right;
+    }
+    else if (e == QKeySequence::MoveToPreviousChar) {
+            op = QTextCursor::Left;
+    }
+    else if (e == QKeySequence::SelectNextChar) {
+           op = QTextCursor::Right;
+           mode = QTextCursor::KeepAnchor;
+    }
+    else if (e == QKeySequence::SelectPreviousChar) {
+            op = QTextCursor::Left;
+            mode = QTextCursor::KeepAnchor;
+    }
+    else if (e == QKeySequence::SelectNextWord) {
+            op = QTextCursor::WordRight;
+            mode = QTextCursor::KeepAnchor;
+    }
+    else if (e == QKeySequence::SelectPreviousWord) {
+            op = QTextCursor::WordLeft;
+            mode = QTextCursor::KeepAnchor;
+    }
+    else if (e == QKeySequence::SelectStartOfLine) {
+            op = QTextCursor::StartOfLine;
+            mode = QTextCursor::KeepAnchor;
+    }
+    else if (e == QKeySequence::SelectEndOfLine) {
+            op = QTextCursor::EndOfLine;
+            mode = QTextCursor::KeepAnchor;
+    }
+    else if (e == QKeySequence::SelectStartOfBlock) {
+            op = QTextCursor::StartOfBlock;
+            mode = QTextCursor::KeepAnchor;
+    }
+    else if (e == QKeySequence::SelectEndOfBlock) {
+            op = QTextCursor::EndOfBlock;
+            mode = QTextCursor::KeepAnchor;
+    }
+    else if (e == QKeySequence::SelectStartOfDocument) {
+            op = QTextCursor::Start;
+            mode = QTextCursor::KeepAnchor;
+    }
+    else if (e == QKeySequence::SelectEndOfDocument) {
+            op = QTextCursor::End;
+            mode = QTextCursor::KeepAnchor;
+    }
+    else if (e == QKeySequence::SelectPreviousLine) {
+            op = QTextCursor::Up;
+            mode = QTextCursor::KeepAnchor;
+    }
+    else if (e == QKeySequence::SelectNextLine) {
+            op = QTextCursor::Down;
+            mode = QTextCursor::KeepAnchor;
+            {
+                QTextBlock block = cursor.block();
+                QTextLine line = currentTextLine(cursor);
+                if (!block.next().isValid()
+                    && line.isValid()
+                    && line.lineNumber() == block.layout()->lineCount() - 1)
+                    op = QTextCursor::End;
+            }
+    }
+    else if (e == QKeySequence::MoveToNextWord) {
+            op = QTextCursor::WordRight;
+    }
+    else if (e == QKeySequence::MoveToPreviousWord) {
+            op = QTextCursor::WordLeft;
+    }
+    else if (e == QKeySequence::MoveToEndOfBlock) {
+            op = QTextCursor::EndOfBlock;
+    }
+    else if (e == QKeySequence::MoveToStartOfBlock) {
+            op = QTextCursor::StartOfBlock;
+    }
+    else if (e == QKeySequence::MoveToNextLine) {
+            op = QTextCursor::Down;
+    }
+    else if (e == QKeySequence::MoveToPreviousLine) {
+            op = QTextCursor::Up;
+    }
+    else if (e == QKeySequence::MoveToStartOfLine) {
+            op = QTextCursor::StartOfLine;
+    }
+    else if (e == QKeySequence::MoveToEndOfLine) {
+            op = QTextCursor::EndOfLine;
+    }
+    else if (e == QKeySequence::MoveToStartOfDocument) {
+            op = QTextCursor::Start;
+    }
+    else if (e == QKeySequence::MoveToEndOfDocument) {
+            op = QTextCursor::End;
+    }
+#endif // QT_NO_SHORTCUT
+    else {
+        return false;
+    }
+
+// Except for pageup and pagedown, OS X has very different behavior, we don't do it all, but
+// here's the breakdown:
+// Shift still works as an anchor, but only one of the other keys can be down Ctrl (Command),
+// Alt (Option), or Meta (Control).
+// Command/Control + Left/Right -- Move to left or right of the line
+//                 + Up/Down -- Move to top bottom of the file. (Control doesn't move the cursor)
+// Option + Left/Right -- Move one word Left/right.
+//        + Up/Down  -- Begin/End of Paragraph.
+// Home/End Top/Bottom of file. (usually don't move the cursor, but will select)
+
+    bool visualNavigation = cursor.visualNavigation();
+    cursor.setVisualNavigation(true);
+
+    // auto pm = textEdit->getPaletteManager();
+    // int result = pm->isLineBeforePalette(cursor.block().blockNumber());
+    LineControl* lc = textEdit->lineControl();
+    int result = lc->isJumpForwardLine(cursor.block().blockNumber());
+    if (result != 0)
+    {
+        if (cursor.atBlockEnd() &&(e == QKeySequence::MoveToNextChar || e ==  QKeySequence::MoveToNextWord || e == QKeySequence::MoveToEndOfLine))
+        {
+            if (result == -1) return false;
+            for (int i = 0; i < result; ++i)
+                cursor.movePosition(QTextCursor::Down);
+            cursor.movePosition(QTextCursor::EndOfBlock);
+        }
+
+        if (cursor.atBlockEnd() && (e == QKeySequence::SelectNextChar || e == QKeySequence::SelectNextWord || e == QKeySequence::SelectEndOfLine))
+        {
+            if (result == -1) return false;
+            for (int i = 0; i < result; ++i)
+            {
+                cursor.movePosition(QTextCursor::Down, QTextCursor::KeepAnchor);
+            }
+            cursor.movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);
+        }
+
+        if (e == QKeySequence::MoveToNextLine)
+        {
+            if (result == -1) return false;
+            for (int i = 0; i < result; ++i)
+            {
+                cursor.movePosition(QTextCursor::Down);
+            }
+        }
+
+        if (e == QKeySequence::SelectNextLine)
+        {
+            if (result == -1) return false;
+            for (int i = 0; i < result; ++i)
+            {
+                cursor.movePosition(QTextCursor::Down, QTextCursor::KeepAnchor);
+            }
+        }
+
+    }
+
+    result = lc->isJumpBackwardsLine(cursor.block().blockNumber());
+    if (result != 0)
+    {
+        if (cursor.atBlockStart() &&(e == QKeySequence::MoveToPreviousChar || e ==  QKeySequence::MoveToPreviousWord || e == QKeySequence::MoveToStartOfLine))
+        {
+            if (result == -1) return false;
+            for (int i = 0; i < result; ++i)
+                cursor.movePosition(QTextCursor::Up);
+            cursor.movePosition(QTextCursor::StartOfBlock);
+        }
+
+        if (cursor.atBlockStart() && (e == QKeySequence::SelectPreviousChar || e == QKeySequence::SelectPreviousWord || e == QKeySequence::SelectStartOfLine))
+        {
+            if (result == -1) return false;
+            for (int i = 0; i < result; ++i)
+            {
+                cursor.movePosition(QTextCursor::Up, QTextCursor::KeepAnchor);
+            }
+            cursor.movePosition(QTextCursor::StartOfBlock, QTextCursor::KeepAnchor);
+        }
+
+        if (e == QKeySequence::MoveToPreviousLine)
+        {
+
+            if (result == -1) return false;
+            for (int i = 0; i < result; ++i)
+            {
+                cursor.movePosition(QTextCursor::Up);
+            }
+        }
+
+        if (e == QKeySequence::SelectPreviousLine)
+        {
+            if (result == -1) return false;
+            for (int i = 0; i < result; ++i)
+            {
+                cursor.movePosition(QTextCursor::Up, QTextCursor::KeepAnchor);
+            }
+        }
+
+    }
+
+
+    const bool moved = cursor.movePosition(op, mode);
+    cursor.setVisualNavigation(visualNavigation);
+
+    bool isNavigationEvent
+            =  e->key() == Qt::Key_Up
+            || e->key() == Qt::Key_Down
+            || e->key() == Qt::Key_Left
+            || e->key() == Qt::Key_Right;
+
+    if (moved) {
+        if (cursor.position() != oldCursorPos)
+            emit q->cursorPositionChanged();
+        q->updateCursorRectangle(true);
+    } else if (isNavigationEvent && oldSelection.anchor() == cursor.anchor()) {
+        return false;
+    }
+
+    selectionChanged(/*forceEmitSelectionChanged =*/(mode == QTextCursor::KeepAnchor));
+
+    repaintOldAndNewSelection(oldSelection);
+
+    return true;
+}
+
+void TextControlPrivate::updateCurrentCharFormat()
+{
+    Q_Q(TextControl);
+
+    QTextCharFormat fmt = cursor.charFormat();
+    if (fmt == lastCharFormat)
+        return;
+    lastCharFormat = fmt;
+
+    emit q->currentCharFormatChanged(fmt);
+    cursorRectangleChanged = true;
+}
+
+void TextControlPrivate::setContent(Qt::TextFormat format, const QString &text)
+{
+    Q_Q(TextControl);
+
+#ifndef QT_NO_IM
+    cancelPreedit();
+#endif
+
+    // for use when called from setPlainText. we may want to re-use the currently
+    // set char format then.
+    const QTextCharFormat charFormatForInsertion = cursor.charFormat();
+
+    bool previousUndoRedoState = doc->isUndoRedoEnabled();
+    doc->setUndoRedoEnabled(false);
+
+    const int oldCursorPos = cursor.position();
+
+    // avoid multiple textChanged() signals being emitted
+    qmlobject_disconnect(doc, QTextDocument, SIGNAL(contentsChanged()), q, TextControl, SIGNAL(textChanged()));
+
+    if (!text.isEmpty()) {
+        // clear 'our' cursor for insertion to prevent
+        // the emission of the cursorPositionChanged() signal.
+        // instead we emit it only once at the end instead of
+        // at the end of the document after loading and when
+        // positioning the cursor again to the start of the
+        // document.
+        cursor = QTextCursor();
+        if (format == Qt::PlainText) {
+            QTextCursor formatCursor(doc);
+            // put the setPlainText and the setCharFormat into one edit block,
+            // so that the syntax highlight triggers only /once/ for the entire
+            // document, not twice.
+            formatCursor.beginEditBlock();
+            doc->setPlainText(text);
+            doc->setUndoRedoEnabled(false);
+            formatCursor.select(QTextCursor::Document);
+            formatCursor.setCharFormat(charFormatForInsertion);
+            formatCursor.endEditBlock();
+        } else {
+#ifndef QT_NO_TEXTHTMLPARSER
+            doc->setHtml(text);
+#else
+            doc->setPlainText(text);
+#endif
+            doc->setUndoRedoEnabled(false);
+        }
+        cursor = QTextCursor(doc);
+    } else {
+        doc->clear();
+    }
+    cursor.setCharFormat(charFormatForInsertion);
+
+    qmlobject_connect(doc, QTextDocument, SIGNAL(contentsChanged()), q, TextControl, SIGNAL(textChanged()));
+    emit q->textChanged();
+    doc->setUndoRedoEnabled(previousUndoRedoState);
+    _q_updateCurrentCharFormatAndSelection();
+    doc->setModified(false);
+
+    q->updateCursorRectangle(true);
+    if (cursor.position() != oldCursorPos)
+        emit q->cursorPositionChanged();
+}
+
+void TextControlPrivate::setCursorPosition(const QPointF &pos)
+{
+    Q_Q(TextControl);
+    const int cursorPos = q->hitTest(pos, Qt::FuzzyHit);
+    if (cursorPos == -1)
+        return;
+    cursor.setPosition(cursorPos);
+}
+
+void TextControlPrivate::setCursorPosition(int pos, QTextCursor::MoveMode mode)
+{
+    cursor.setPosition(pos, mode);
+
+    if (mode != QTextCursor::KeepAnchor) {
+        selectedWordOnDoubleClick = QTextCursor();
+        selectedBlockOnTripleClick = QTextCursor();
+    }
+}
+
+void TextControlPrivate::repaintCursor()
+{
+    Q_Q(TextControl);
+    emit q->updateCursorRequest();
+}
+
+void TextControlPrivate::repaintOldAndNewSelection(const QTextCursor &oldSelection)
+{
+    Q_Q(TextControl);
+    if (cursor.hasSelection()
+        && oldSelection.hasSelection()
+        && cursor.currentFrame() == oldSelection.currentFrame()
+        && !cursor.hasComplexSelection()
+        && !oldSelection.hasComplexSelection()
+        && cursor.anchor() == oldSelection.anchor()
+        ) {
+        QTextCursor differenceSelection(doc);
+        differenceSelection.setPosition(oldSelection.position());
+        differenceSelection.setPosition(cursor.position(), QTextCursor::KeepAnchor);
+        emit q->updateRequest();
+    } else {
+        if (!oldSelection.hasSelection() && !cursor.hasSelection()) {
+            if (!oldSelection.isNull())
+                emit q->updateCursorRequest();
+            emit q->updateCursorRequest();
+
+        } else {
+            if (!oldSelection.isNull())
+                emit q->updateRequest();
+            emit q->updateRequest();
+        }
+    }
+}
+
+void TextControlPrivate::selectionChanged(bool forceEmitSelectionChanged /*=false*/)
+{
+    Q_Q(TextControl);
+    if (forceEmitSelectionChanged) {
+#ifndef QT_NO_IM
+        if (hasFocus)
+            qGuiApp->inputMethod()->update(Qt::ImCurrentSelection);
+#endif
+        emit q->selectionChanged();
+    }
+
+    bool current = cursor.hasSelection();
+    int selectionStart = cursor.selectionStart();
+    int selectionEnd = cursor.selectionEnd();
+    if (current == lastSelectionState && (!current || (selectionStart == lastSelectionStart && selectionEnd == lastSelectionEnd)))
+        return;
+
+    if (lastSelectionState != current) {
+        lastSelectionState = current;
+        emit q->copyAvailable(current);
+    }
+
+    lastSelectionStart = selectionStart;
+    lastSelectionEnd = selectionEnd;
+
+    if (!forceEmitSelectionChanged) {
+#ifndef QT_NO_IM
+        if (hasFocus)
+            qGuiApp->inputMethod()->update(Qt::ImCurrentSelection);
+#endif
+        emit q->selectionChanged();
+    }
+}
+
+void TextControlPrivate::_q_updateCurrentCharFormatAndSelection()
+{
+    updateCurrentCharFormat();
+    selectionChanged();
+}
+
+#ifndef QT_NO_CLIPBOARD
+void TextControlPrivate::setClipboardSelection()
+{
+    QClipboard *clipboard = QGuiApplication::clipboard();
+    if (!cursor.hasSelection() || !clipboard->supportsSelection())
+        return;
+    Q_Q(TextControl);
+    QMimeData *data = q->createMimeDataFromSelection();
+    clipboard->setMimeData(data, QClipboard::Selection);
+}
+#endif
+
+void TextControlPrivate::_q_updateCursorPosChanged(const QTextCursor &someCursor)
+{
+    Q_Q(TextControl);
+    if (someCursor.isCopyOf(cursor)) {
+        emit q->cursorPositionChanged();
+        q->updateCursorRectangle(true);
+    }
+}
+
+void TextControlPrivate::setBlinkingCursorEnabled(bool enable)
+{
+    if (cursorBlinkingEnabled == enable)
+        return;
+
+    cursorBlinkingEnabled = enable;
+    updateCursorFlashTime();
+
+    if (enable)
+        connect(qApp->styleHints(), &QStyleHints::cursorFlashTimeChanged, this, &TextControlPrivate::updateCursorFlashTime);
+    else
+        disconnect(qApp->styleHints(), &QStyleHints::cursorFlashTimeChanged, this, &TextControlPrivate::updateCursorFlashTime);
+}
+
+void TextControlPrivate::updateCursorFlashTime()
+{
+    // Note: cursorOn represents the current blinking state controlled by a timer, and
+    // should not be confused with cursorVisible or cursorBlinkingEnabled. However, we
+    // interpretate a cursorFlashTime of 0 to mean "always on, never blink".
+    cursorOn = true;
+    int flashTime = QGuiApplication::styleHints()->cursorFlashTime();
+
+    if (cursorBlinkingEnabled && flashTime >= 2)
+        cursorBlinkTimer.start(flashTime / 2, q_func());
+    else
+        cursorBlinkTimer.stop();
+
+    repaintCursor();
+}
+
+void TextControlPrivate::extendWordwiseSelection(int suggestedNewPosition, qreal mouseXPosition)
+{
+    Q_Q(TextControl);
+
+    // if inside the initial selected word keep that
+    if (suggestedNewPosition >= selectedWordOnDoubleClick.selectionStart()
+        && suggestedNewPosition <= selectedWordOnDoubleClick.selectionEnd()) {
+        q->setTextCursor(selectedWordOnDoubleClick);
+        return;
+    }
+
+    QTextCursor curs = selectedWordOnDoubleClick;
+    curs.setPosition(suggestedNewPosition, QTextCursor::KeepAnchor);
+
+    if (!curs.movePosition(QTextCursor::StartOfWord))
+        return;
+    const int wordStartPos = curs.position();
+
+    const int blockPos = curs.block().position();
+    const QPointF blockCoordinates = q->blockBoundingRect(curs.block()).topLeft();
+
+    QTextLine line = currentTextLine(curs);
+    if (!line.isValid())
+        return;
+
+    const qreal wordStartX = line.cursorToX(curs.position() - blockPos) + blockCoordinates.x();
+
+    if (!curs.movePosition(QTextCursor::EndOfWord))
+        return;
+    const int wordEndPos = curs.position();
+
+    const QTextLine otherLine = currentTextLine(curs);
+    if (otherLine.textStart() != line.textStart()
+        || wordEndPos == wordStartPos)
+        return;
+
+    const qreal wordEndX = line.cursorToX(curs.position() - blockPos) + blockCoordinates.x();
+
+    if (!wordSelectionEnabled && (mouseXPosition < wordStartX || mouseXPosition > wordEndX))
+        return;
+
+    if (suggestedNewPosition < selectedWordOnDoubleClick.position()) {
+        cursor.setPosition(selectedWordOnDoubleClick.selectionEnd());
+        setCursorPosition(wordStartPos, QTextCursor::KeepAnchor);
+    } else {
+        cursor.setPosition(selectedWordOnDoubleClick.selectionStart());
+        setCursorPosition(wordEndPos, QTextCursor::KeepAnchor);
+    }
+
+    if (interactionFlags & Qt::TextSelectableByMouse) {
+#ifndef QT_NO_CLIPBOARD
+        setClipboardSelection();
+#endif
+        selectionChanged(true);
+    }
+}
+
+void TextControlPrivate::extendBlockwiseSelection(int suggestedNewPosition)
+{
+    Q_Q(TextControl);
+
+    // if inside the initial selected line keep that
+    if (suggestedNewPosition >= selectedBlockOnTripleClick.selectionStart()
+        && suggestedNewPosition <= selectedBlockOnTripleClick.selectionEnd()) {
+        q->setTextCursor(selectedBlockOnTripleClick);
+        return;
+    }
+
+    if (suggestedNewPosition < selectedBlockOnTripleClick.position()) {
+        cursor.setPosition(selectedBlockOnTripleClick.selectionEnd());
+        cursor.setPosition(suggestedNewPosition, QTextCursor::KeepAnchor);
+        cursor.movePosition(QTextCursor::StartOfBlock, QTextCursor::KeepAnchor);
+    } else {
+        cursor.setPosition(selectedBlockOnTripleClick.selectionStart());
+        cursor.setPosition(suggestedNewPosition, QTextCursor::KeepAnchor);
+        cursor.movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);
+        cursor.movePosition(QTextCursor::NextCharacter, QTextCursor::KeepAnchor);
+    }
+
+    if (interactionFlags & Qt::TextSelectableByMouse) {
+#ifndef QT_NO_CLIPBOARD
+        setClipboardSelection();
+#endif
+        selectionChanged(true);
+    }
+}
+
+void TextControl::undo()
+{
+    Q_D(TextControl);
+    d->repaintSelection();
+    const int oldCursorPos = d->cursor.position();
+    d->doc->undo(&d->cursor);
+    if (d->cursor.position() != oldCursorPos)
+        emit cursorPositionChanged();
+    updateCursorRectangle(true);
+}
+
+void TextControl::redo()
+{
+    Q_D(TextControl);
+    d->repaintSelection();
+    const int oldCursorPos = d->cursor.position();
+    d->doc->redo(&d->cursor);
+    if (d->cursor.position() != oldCursorPos)
+        emit cursorPositionChanged();
+    updateCursorRectangle(true);
+}
+
+void TextControl::clear()
+{
+    Q_D(TextControl);
+    d->cursor.select(QTextCursor::Document);
+    d->cursor.removeSelectedText();
+}
+
+TextControl::TextControl(QTextDocument *doc, QObject *parent)
+    : QObject(*new TextControlPrivate, parent)
+{
+    Q_D(TextControl);
+    Q_ASSERT(doc);
+
+    QAbstractTextDocumentLayout *layout = doc->documentLayout();
+    qmlobject_connect(layout, QAbstractTextDocumentLayout, SIGNAL(update(QRectF)), this, TextControl, SIGNAL(updateRequest()));
+    qmlobject_connect(layout, QAbstractTextDocumentLayout, SIGNAL(updateBlock(QTextBlock)), this, TextControl, SIGNAL(updateRequest()));
+    qmlobject_connect(doc, QTextDocument, SIGNAL(contentsChanged()), this, TextControl, SIGNAL(textChanged()));
+    qmlobject_connect(doc, QTextDocument, SIGNAL(contentsChanged()), this, TextControl, SLOT(_q_updateCurrentCharFormatAndSelection()));
+    qmlobject_connect(doc, QTextDocument, SIGNAL(cursorPositionChanged(QTextCursor)), this, TextControl, SLOT(_q_updateCursorPosChanged(QTextCursor)));
+    connect(doc, &QTextDocument::contentsChange, this, &TextControl::contentsChange);
+
+    layout->setProperty("cursorWidth", textCursorWidth);
+
+    d->doc = doc;
+    d->cursor = QTextCursor(doc);
+    d->lastCharFormat = d->cursor.charFormat();
+    doc->setPageSize(QSizeF(0, 0));
+    doc->setModified(false);
+    doc->setUndoRedoEnabled(true);
+}
+
+TextControl::~TextControl()
+{
+}
+
+QTextDocument *TextControl::document() const
+{
+    Q_D(const TextControl);
+    return d->doc;
+}
+
+void TextControl::updateCursorRectangle(bool force)
+{
+    Q_D(TextControl);
+    const bool update = d->cursorRectangleChanged || force;
+    d->cursorRectangleChanged = false;
+    if (update)
+        emit cursorRectangleChanged();
+}
+
+void TextControl::clearSelectionOnFocus(bool value){
+    Q_D(TextControl);
+    d->clearSelectionOnFocus = value;
+}
+
+void TextControl::setTextCursor(const QTextCursor &cursor)
+{
+    Q_D(TextControl);
+#ifndef QT_NO_IM
+    d->commitPreedit();
+#endif
+    d->cursorIsFocusIndicator = false;
+    const bool posChanged = cursor.position() != d->cursor.position();
+    const QTextCursor oldSelection = d->cursor;
+    d->cursor = cursor;
+    d->cursorOn = d->hasFocus && (d->interactionFlags & Qt::TextEditable);
+    d->_q_updateCurrentCharFormatAndSelection();
+    updateCursorRectangle(true);
+    d->repaintOldAndNewSelection(oldSelection);
+    if (posChanged)
+        emit cursorPositionChanged();
+}
+
+QTextCursor TextControl::textCursor() const
+{
+    Q_D(const TextControl);
+    return d->cursor;
+}
+
+#ifndef QT_NO_CLIPBOARD
+
+void TextControl::cut()
+{
+    Q_D(TextControl);
+    if (!(d->interactionFlags & Qt::TextEditable) || !d->cursor.hasSelection())
+        return;
+    copy();
+    d->cursor.removeSelectedText();
+}
+
+void TextControl::copy()
+{
+    Q_D(TextControl);
+    if (!d->cursor.hasSelection())
+        return;
+    QMimeData *data = createMimeDataFromSelection();
+    QGuiApplication::clipboard()->setMimeData(data);
+}
+
+void TextControl::paste(QClipboard::Mode mode)
+{
+    const QMimeData *md = QGuiApplication::clipboard()->mimeData(mode);
+    if (md)
+        insertFromMimeData(md);
+}
+#endif
+
+void TextControl::selectAll()
+{
+    Q_D(TextControl);
+    const int selectionLength = qAbs(d->cursor.position() - d->cursor.anchor());
+    d->cursor.select(QTextCursor::Document);
+    d->selectionChanged(selectionLength != qAbs(d->cursor.position() - d->cursor.anchor()));
+    d->cursorIsFocusIndicator = false;
+    emit updateRequest();
+}
+
+void TextControl::processEvent(QEvent *e, const QPointF &coordinateOffset)
+{
+    QMatrix m;
+    m.translate(coordinateOffset.x(), coordinateOffset.y());
+    processEvent(e, m);
+}
+
+void TextControl::processEvent(QEvent *e, const QMatrix &matrix)
+{
+    Q_D(TextControl);
+    if (d->interactionFlags == Qt::NoTextInteraction) {
+        e->ignore();
+        return;
+    }
+
+    // PALETTE
+    QMouseEvent *ev = nullptr;
+    if (e->type() == QEvent::MouseButtonPress || e->type() == QEvent::MouseMove ||
+            e->type() == QEvent::MouseButtonRelease || e->type() == QEvent::MouseButtonDblClick)
+    {
+        ev = static_cast<QMouseEvent *>(e);
+        QPointF mousePos = ev->localPos();
+        int oldy = mousePos.y();
+        mousePos.setY(d->textEdit->lineControl()->positionOffset(oldy));
+#if (QT_VERSION > QT_VERSION_CHECK(5,7,1))
+        ev->setLocalPos(mousePos);
+#else
+        ev = new QMouseEvent(ev->type(), mousePos, ev->windowPos(), ev->screenPos(), ev->button(), ev->buttons(), ev->modifiers(), ev->source());
+        e = ev;
+#endif
+    }
+
+    switch (e->type()) {
+        case QEvent::KeyPress:
+            d->keyPressEvent(static_cast<QKeyEvent *>(e));
+            break;
+        case QEvent::KeyRelease:
+            d->keyReleaseEvent(static_cast<QKeyEvent *>(e));
+            break;
+        case QEvent::MouseButtonPress: {
+            QMouseEvent *ev = static_cast<QMouseEvent *>(e);
+            d->mousePressEvent(ev, matrix.map(ev->localPos()));
+            break; }
+        case QEvent::MouseMove: {
+            QMouseEvent *ev = static_cast<QMouseEvent *>(e);
+            d->mouseMoveEvent(ev, matrix.map(ev->localPos()));
+            break; }
+        case QEvent::MouseButtonRelease: {
+            QMouseEvent *ev = static_cast<QMouseEvent *>(e);
+            d->mouseReleaseEvent(ev, matrix.map(ev->localPos()));
+            break; }
+        case QEvent::MouseButtonDblClick: {
+            QMouseEvent *ev = static_cast<QMouseEvent *>(e);
+            d->mouseDoubleClickEvent(ev, matrix.map(ev->localPos()));
+            break; }
+        case QEvent::HoverEnter:
+        case QEvent::HoverMove:
+        case QEvent::HoverLeave: {
+            QHoverEvent *ev = static_cast<QHoverEvent *>(e);
+            d->hoverEvent(ev, matrix.map(ev->posF()));
+            break; }
+#ifndef QT_NO_IM
+        case QEvent::InputMethod:
+            d->inputMethodEvent(static_cast<QInputMethodEvent *>(e));
+            break;
+#endif
+        case QEvent::FocusIn:
+        case QEvent::FocusOut:
+            d->focusEvent(static_cast<QFocusEvent *>(e));
+            break;
+
+        case QEvent::ShortcutOverride:
+            if (d->interactionFlags & Qt::TextEditable) {
+                QKeyEvent* ke = static_cast<QKeyEvent *>(e);
+                if (ke->modifiers() == Qt::NoModifier
+                    || ke->modifiers() == Qt::ShiftModifier
+                    || ke->modifiers() == Qt::KeypadModifier) {
+                    if (ke->key() < Qt::Key_Escape) {
+                        ke->accept();
+                    } else {
+                        switch (ke->key()) {
+                            case Qt::Key_Return:
+                            case Qt::Key_Enter:
+                            case Qt::Key_Delete:
+                            case Qt::Key_Home:
+                            case Qt::Key_End:
+                            case Qt::Key_Backspace:
+                            case Qt::Key_Left:
+                            case Qt::Key_Right:
+                            case Qt::Key_Up:
+                            case Qt::Key_Down:
+                            case Qt::Key_Tab:
+
+                            if (ke->key() == Qt::Key_Return)
+                            {
+				// TODO
+                                /*auto layout = d->textEdit->getDocumentLayout();
+                                std::pair<int, int> result(-1, -1);
+                                if (layout)
+                                {
+                                    result = layout->isFirstLineOfCollapsedSection(d->cursor.block().blockNumber());
+                                }
+                                if (layout && result.first != -1)
+                                {
+                                    layout->expandLines(result.first, result.second);
+                                }*/
+                            }
+                            ke->accept();
+                        default:
+                            break;
+                        }
+                    }
+#ifndef QT_NO_SHORTCUT
+                } else if (ke == QKeySequence::Copy
+                           || ke == QKeySequence::Paste
+                           || ke == QKeySequence::Cut
+                           || ke == QKeySequence::Redo
+                           || ke == QKeySequence::Undo
+                           || ke == QKeySequence::MoveToNextWord
+                           || ke == QKeySequence::MoveToPreviousWord
+                           || ke == QKeySequence::MoveToStartOfDocument
+                           || ke == QKeySequence::MoveToEndOfDocument
+                           || ke == QKeySequence::SelectNextWord
+                           || ke == QKeySequence::SelectPreviousWord
+                           || ke == QKeySequence::SelectStartOfLine
+                           || ke == QKeySequence::SelectEndOfLine
+                           || ke == QKeySequence::SelectStartOfBlock
+                           || ke == QKeySequence::SelectEndOfBlock
+                           || ke == QKeySequence::SelectStartOfDocument
+                           || ke == QKeySequence::SelectEndOfDocument
+                           || ke == QKeySequence::SelectAll
+                          ) {
+
+		    // TODO
+                    /*auto layout = d->textEdit->getDocumentLayout();
+                    std::pair<int, int> result(-1, -1);
+                    if (layout && ke == QKeySequence::Paste)
+                    {
+                        result = layout->isFirstLineOfCollapsedSection(d->cursor.block().blockNumber());
+                    }
+                    if (result.first != -1)
+                    {
+                        layout->expandLines(result.first, result.second);
+                    }*/
+
+                    ke->accept();
+#endif
+                }
+            }
+            break;
+        default:
+            break;
+    }
+
+#if (QT_VERSION <= QT_VERSION_CHECK(5,7,1))
+    if (ev) delete ev;
+#endif
+}
+
+bool TextControl::event(QEvent *e)
+{
+    return QObject::event(e);
+}
+
+void TextControl::timerEvent(QTimerEvent *e)
+{
+    Q_D(TextControl);
+    if (e->timerId() == d->cursorBlinkTimer.timerId()) {
+        d->cursorOn = !d->cursorOn;
+
+        d->repaintCursor();
+    } else if (e->timerId() == d->tripleClickTimer.timerId()) {
+        d->tripleClickTimer.stop();
+    }
+}
+
+void TextControl::setPlainText(const QString &text)
+{
+    Q_D(TextControl);
+    d->setContent(Qt::PlainText, text);
+}
+
+void TextControl::setHtml(const QString &text)
+{
+    Q_D(TextControl);
+    d->setContent(Qt::RichText, text);
+}
+
+
+void TextControlPrivate::keyReleaseEvent(QKeyEvent *e)
+{
+    if (e->key() == Qt::Key_Back) {
+         e->ignore();
+         return;
+    }
+    return;
+}
+
+void TextControlPrivate::keyPressEvent(QKeyEvent *e)
+{
+    Q_Q(TextControl);
+
+    if (e->key() == Qt::Key_Back) {
+         e->ignore();
+         return;
+    }
+
+#ifndef QT_NO_SHORTCUT
+    if (e == QKeySequence::SelectAll) {
+            e->accept();
+            q->selectAll();
+            return;
+    }
+#ifndef QT_NO_CLIPBOARD
+    else if (e == QKeySequence::Copy) {
+            e->accept();
+            q->copy();
+            return;
+    }
+#endif
+#endif // QT_NO_SHORTCUT
+
+    if (interactionFlags & Qt::TextSelectableByKeyboard
+        && cursorMoveKeyEvent(e))
+        goto accept;
+
+    if (!(interactionFlags & Qt::TextEditable)) {
+        e->ignore();
+        return;
+    }
+
+    if (e->key() == Qt::Key_Direction_L || e->key() == Qt::Key_Direction_R) {
+        QTextBlockFormat fmt;
+        fmt.setLayoutDirection((e->key() == Qt::Key_Direction_L) ? Qt::LeftToRight : Qt::RightToLeft);
+        cursor.mergeBlockFormat(fmt);
+        goto accept;
+    }
+
+    // schedule a repaint of the region of the cursor, as when we move it we
+    // want to make sure the old cursor disappears (not noticeable when moving
+    // only a few pixels but noticeable when jumping between cells in tables for
+    // example)
+    repaintSelection();
+
+    if (e->key() == Qt::Key_Backspace && !(e->modifiers() & ~Qt::ShiftModifier)) {
+        QTextBlockFormat blockFmt = cursor.blockFormat();
+        QTextList *list = cursor.currentList();
+        if (list && cursor.atBlockStart() && !cursor.hasSelection()) {
+            list->remove(cursor.block());
+        } else if (cursor.atBlockStart() && blockFmt.indent() > 0) {
+            blockFmt.setIndent(blockFmt.indent() - 1);
+            cursor.setBlockFormat(blockFmt);
+        } else {
+            QTextCursor localCursor = cursor;
+		// TODO
+            /*std::pair<int, int> result(-1, -1);
+            if (textEdit && textEdit->getDocumentLayout())
+            {
+                result = textEdit->getDocumentLayout()->isLineAfterCollapsedSection(localCursor.block().blockNumber());
+            }
+
+            if (result.first != -1 && localCursor.atBlockStart())
+            {
+                textEdit->manageExpandCollapse(result.first, false);
+            }
+            else {*/
+                localCursor.deletePreviousChar();
+            // }
+
+        }
+        goto accept;
+    }
+#ifndef QT_NO_SHORTCUT
+      else if (e == QKeySequence::InsertParagraphSeparator) {
+        cursor.insertBlock();
+        e->accept();
+        goto accept;
+    } else if (e == QKeySequence::InsertLineSeparator) {
+        cursor.insertText(QString(QChar::LineSeparator));
+        e->accept();
+        goto accept;
+    }
+#endif
+    if (false) {
+    }
+#ifndef QT_NO_SHORTCUT
+    else if (e == QKeySequence::Undo) {
+            q->undo();
+    }
+    else if (e == QKeySequence::Redo) {
+           q->redo();
+    }
+#ifndef QT_NO_CLIPBOARD
+    else if (e == QKeySequence::Cut) {
+           q->cut();
+    }
+    else if (e == QKeySequence::Paste) {
+        QClipboard::Mode mode = QClipboard::Clipboard;
+        q->paste(mode);
+    }
+#endif
+    else if (e == QKeySequence::Delete) {
+        QTextCursor localCursor = cursor;
+        localCursor.deleteChar();
+    }
+    else if (e == QKeySequence::DeleteEndOfWord) {
+        if (!cursor.hasSelection())
+            cursor.movePosition(QTextCursor::NextWord, QTextCursor::KeepAnchor);
+        cursor.removeSelectedText();
+    }
+    else if (e == QKeySequence::DeleteStartOfWord) {
+        if (!cursor.hasSelection())
+            cursor.movePosition(QTextCursor::PreviousWord, QTextCursor::KeepAnchor);
+        cursor.removeSelectedText();
+    }
+    else if (e == QKeySequence::DeleteEndOfLine) {
+        QTextBlock block = cursor.block();
+        if (cursor.position() == block.position() + block.length() - 2)
+            cursor.movePosition(QTextCursor::Right, QTextCursor::KeepAnchor);
+        else
+            cursor.movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);
+        cursor.removeSelectedText();
+    }
+#endif // QT_NO_SHORTCUT
+    else {
+        goto process;
+    }
+    goto accept;
+
+process:
+    {
+        QString text = e->text();
+        if (!text.isEmpty() && (text.at(0).isPrint() || text.at(0) == QLatin1Char('\t'))) {
+            cursor.insertText(text);
+            selectionChanged();
+        } else {
+            e->ignore();
+            return;
+        }
+    }
+
+ accept:
+
+    e->accept();
+    cursorOn = true;
+
+    q->updateCursorRectangle(true);
+    updateCurrentCharFormat();
+}
+
+QRectF TextControlPrivate::rectForPosition(int position) const
+{
+    Q_Q(const TextControl);
+    const QTextBlock block = doc->findBlock(position);
+    if (!block.isValid())
+        return QRectF();
+    const QTextLayout *layout = block.layout();
+    const QPointF layoutPos = q->blockBoundingRect(block).topLeft();
+    int relativePos = position - block.position();
+#ifndef QT_NO_IM
+    if (preeditCursor != 0) {
+        int preeditPos = layout->preeditAreaPosition();
+        if (relativePos == preeditPos)
+            relativePos += preeditCursor;
+        else if (relativePos > preeditPos)
+            relativePos += layout->preeditAreaText().length();
+    }
+#endif
+    QTextLine line = layout->lineForTextPosition(relativePos);
+
+    QRectF r;
+    // int offset = textEdit->getPaletteManager()->drawingOffset(block.blockNumber(), true);
+    int offset = 0;
+    if (textEdit && textEdit->lineControl())
+        offset = textEdit->lineControl()->drawingOffset(block.blockNumber(), true);
+    if (line.isValid()) {
+        qreal x = line.cursorToX(relativePos);
+        qreal w = 0;
+
+        r = QRectF(layoutPos.x() + x, layoutPos.y() + line.y() + offset, textCursorWidth + w, line.height());
+    } else {
+        r = QRectF(layoutPos.x(), layoutPos.y() + offset, textCursorWidth, 10); // #### correct height
+    }
+
+    return r;
+}
+
+void TextControlPrivate::mousePressEvent(QMouseEvent *e, const QPointF &pos)
+{
+    Q_Q(TextControl);
+
+    mousePressed = (interactionFlags & Qt::TextSelectableByMouse) && (e->button() & Qt::LeftButton);
+    mousePressPos = pos.toPoint();
+
+    if (sendMouseEventToInputContext(e, pos))
+        return;
+
+    if (interactionFlags & Qt::LinksAccessibleByMouse) {
+        anchorOnMousePress = q->anchorAt(pos);
+
+        if (cursorIsFocusIndicator) {
+            cursorIsFocusIndicator = false;
+            repaintSelection();
+            cursor.clearSelection();
+        }
+    }
+    if (e->button() & Qt::MiddleButton) {
+        return;
+    } else  if (!(e->button() & Qt::LeftButton)) {
+        e->ignore();
+        return;
+    } else if (!(interactionFlags & (Qt::TextSelectableByMouse | Qt::TextEditable))) {
+        if (!(interactionFlags & Qt::LinksAccessibleByMouse))
+            e->ignore();
+        return;
+    }
+
+    cursorIsFocusIndicator = false;
+    const QTextCursor oldSelection = cursor;
+    const int oldCursorPos = cursor.position();
+
+#ifndef QT_NO_IM
+    commitPreedit();
+#endif
+
+    if (tripleClickTimer.isActive()
+        && ((pos - tripleClickPoint).toPoint().manhattanLength() < QGuiApplication::styleHints()->startDragDistance())) {
+
+        cursor.movePosition(QTextCursor::StartOfBlock);
+        cursor.movePosition(QTextCursor::EndOfBlock, QTextCursor::KeepAnchor);
+        cursor.movePosition(QTextCursor::NextCharacter, QTextCursor::KeepAnchor);
+        selectedBlockOnTripleClick = cursor;
+
+        anchorOnMousePress = QString();
+
+        tripleClickTimer.stop();
+    } else {
+        int cursorPos = q->hitTest(pos, Qt::FuzzyHit);
+        if (cursorPos == -1) {
+            e->ignore();
+            return;
+        }
+
+        if (e->modifiers() == Qt::ShiftModifier && (interactionFlags & Qt::TextSelectableByMouse)) {
+            if (wordSelectionEnabled && !selectedWordOnDoubleClick.hasSelection()) {
+                selectedWordOnDoubleClick = cursor;
+                selectedWordOnDoubleClick.select(QTextCursor::WordUnderCursor);
+            }
+
+            if (selectedBlockOnTripleClick.hasSelection())
+                extendBlockwiseSelection(cursorPos);
+            else if (selectedWordOnDoubleClick.hasSelection())
+                extendWordwiseSelection(cursorPos, pos.x());
+            else if (!wordSelectionEnabled)
+                setCursorPosition(cursorPos, QTextCursor::KeepAnchor);
+        } else {
+            setCursorPosition(cursorPos);
+        }
+    }
+
+    if (cursor.position() != oldCursorPos) {
+        q->updateCursorRectangle(true);
+        emit q->cursorPositionChanged();
+    }
+    if (interactionFlags & Qt::TextEditable)
+        _q_updateCurrentCharFormatAndSelection();
+    else
+        selectionChanged();
+    repaintOldAndNewSelection(oldSelection);
+    hadSelectionOnMousePress = cursor.hasSelection();
+}
+
+void TextControlPrivate::mouseMoveEvent(QMouseEvent *e, const QPointF &mousePos)
+{
+    Q_Q(TextControl);
+
+    if ((e->buttons() & Qt::LeftButton)) {
+        const bool editable = interactionFlags & Qt::TextEditable;
+
+        if (!(mousePressed
+              || editable
+              || selectedWordOnDoubleClick.hasSelection()
+              || selectedBlockOnTripleClick.hasSelection()))
+            return;
+
+        const QTextCursor oldSelection = cursor;
+        const int oldCursorPos = cursor.position();
+
+        if (!mousePressed)
+            return;
+
+        const qreal mouseX = qreal(mousePos.x());
+
+        int newCursorPos = q->hitTest(mousePos, Qt::FuzzyHit);
+
+#ifndef QT_NO_IM
+        if (isPreediting()) {
+            // note: oldCursorPos not including preedit
+            int selectionStartPos = q->hitTest(mousePressPos, Qt::FuzzyHit);
+            if (newCursorPos != selectionStartPos) {
+                commitPreedit();
+                // commit invalidates positions
+                newCursorPos = q->hitTest(mousePos, Qt::FuzzyHit);
+                selectionStartPos = q->hitTest(mousePressPos, Qt::FuzzyHit);
+                setCursorPosition(selectionStartPos);
+            }
+        }
+#endif
+
+        if (newCursorPos == -1)
+            return;
+
+        if (wordSelectionEnabled && !selectedWordOnDoubleClick.hasSelection()) {
+            selectedWordOnDoubleClick = cursor;
+            selectedWordOnDoubleClick.select(QTextCursor::WordUnderCursor);
+        }
+
+        if (selectedBlockOnTripleClick.hasSelection())
+            extendBlockwiseSelection(newCursorPos);
+        else if (selectedWordOnDoubleClick.hasSelection())
+            extendWordwiseSelection(newCursorPos, mouseX);
+#ifndef QT_NO_IM
+        else if (!isPreediting())
+            setCursorPosition(newCursorPos, QTextCursor::KeepAnchor);
+#endif
+
+        if (interactionFlags & Qt::TextEditable) {
+            if (cursor.position() != oldCursorPos) {
+                emit q->cursorPositionChanged();
+                q->updateCursorRectangle(true);
+            }
+            _q_updateCurrentCharFormatAndSelection();
+#ifndef QT_NO_IM
+            if (qGuiApp)
+                qGuiApp->inputMethod()->update(Qt::ImQueryInput);
+#endif
+        } else if (cursor.position() != oldCursorPos) {
+            emit q->cursorPositionChanged();
+            q->updateCursorRectangle(true);
+        }
+        selectionChanged(true);
+        repaintOldAndNewSelection(oldSelection);
+    }
+
+    sendMouseEventToInputContext(e, mousePos);
+}
+
+void TextControlPrivate::mouseReleaseEvent(QMouseEvent *e, const QPointF &pos)
+{
+    Q_Q(TextControl);
+
+    if (sendMouseEventToInputContext(e, pos))
+        return;
+
+    const QTextCursor oldSelection = cursor;
+    const int oldCursorPos = cursor.position();
+
+    if (mousePressed) {
+        mousePressed = false;
+#ifndef QT_NO_CLIPBOARD
+        setClipboardSelection();
+        selectionChanged(true);
+    } else if (e->button() == Qt::MidButton
+               && (interactionFlags & Qt::TextEditable)
+               && QGuiApplication::clipboard()->supportsSelection()) {
+        setCursorPosition(pos);
+        const QMimeData *md = QGuiApplication::clipboard()->mimeData(QClipboard::Selection);
+        if (md)
+            q->insertFromMimeData(md);
+#endif
+    }
+
+    repaintOldAndNewSelection(oldSelection);
+
+    if (cursor.position() != oldCursorPos) {
+        emit q->cursorPositionChanged();
+        q->updateCursorRectangle(true);
+    }
+
+    if (interactionFlags & Qt::LinksAccessibleByMouse) {
+        if (!(e->button() & Qt::LeftButton))
+            return;
+
+        const QString anchor = q->anchorAt(pos);
+
+        if (anchor.isEmpty())
+            return;
+
+        if (!cursor.hasSelection()
+            || (anchor == anchorOnMousePress && hadSelectionOnMousePress)) {
+
+            const int anchorPos = q->hitTest(pos, Qt::ExactHit);
+            if (anchorPos != -1) {
+                cursor.setPosition(anchorPos);
+
+                QString anchor = anchorOnMousePress;
+                anchorOnMousePress = QString();
+                activateLinkUnderCursor(anchor);
+            }
+        }
+    }
+}
+
+void TextControlPrivate::mouseDoubleClickEvent(QMouseEvent *e, const QPointF &pos)
+{
+    Q_Q(TextControl);
+
+    if (e->button() == Qt::LeftButton && (interactionFlags & Qt::TextSelectableByMouse)) {
+#ifndef QT_NO_IM
+        commitPreedit();
+#endif
+
+        const QTextCursor oldSelection = cursor;
+        setCursorPosition(pos);
+        QTextLine line = currentTextLine(cursor);
+        bool doEmit = false;
+        if (line.isValid() && line.textLength()) {
+            cursor.select(QTextCursor::WordUnderCursor);
+            doEmit = true;
+        }
+        repaintOldAndNewSelection(oldSelection);
+
+        cursorIsFocusIndicator = false;
+        selectedWordOnDoubleClick = cursor;
+
+        tripleClickPoint = pos;
+        tripleClickTimer.start(QGuiApplication::styleHints()->mouseDoubleClickInterval(), q);
+        if (doEmit) {
+            selectionChanged();
+#ifndef QT_NO_CLIPBOARD
+            setClipboardSelection();
+#endif
+            emit q->cursorPositionChanged();
+            q->updateCursorRectangle(true);
+        }
+    } else if (!sendMouseEventToInputContext(e, pos)) {
+        e->ignore();
+    }
+}
+
+bool TextControlPrivate::sendMouseEventToInputContext(QMouseEvent *e, const QPointF &pos)
+{
+#if !defined(QT_NO_IM)
+    Q_Q(TextControl);
+
+    Q_UNUSED(e);
+
+    if (isPreediting()) {
+        QTextLayout *layout = cursor.block().layout();
+        int cursorPos = q->hitTest(pos, Qt::FuzzyHit) - cursor.position();
+
+        if (cursorPos >= 0 && cursorPos <= layout->preeditAreaText().length()) {
+            if (e->type() == QEvent::MouseButtonRelease) {
+                QGuiApplication::inputMethod()->invokeAction(QInputMethod::Click, cursorPos);
+            }
+
+            return true;
+        }
+    }
+#else
+    Q_UNUSED(e);
+    Q_UNUSED(pos);
+#endif
+    return false;
+}
+
+#ifndef QT_NO_IM
+void TextControlPrivate::inputMethodEvent(QInputMethodEvent *e)
+{
+    Q_Q(TextControl);
+    if (!(interactionFlags & Qt::TextEditable) || cursor.isNull()) {
+        e->ignore();
+        return;
+    }
+    bool isGettingInput = !e->commitString().isEmpty()
+            || e->preeditString() != cursor.block().layout()->preeditAreaText()
+            || e->replacementLength() > 0;
+    bool forceSelectionChanged = false;
+
+    cursor.beginEditBlock();
+    if (isGettingInput) {
+        cursor.removeSelectedText();
+    }
+
+    // insert commit string
+    if (!e->commitString().isEmpty() || e->replacementLength()) {
+        QTextCursor c = cursor;
+        c.setPosition(c.position() + e->replacementStart());
+        c.setPosition(c.position() + e->replacementLength(), QTextCursor::KeepAnchor);
+        c.insertText(e->commitString());
+    }
+
+    for (int i = 0; i < e->attributes().size(); ++i) {
+        const QInputMethodEvent::Attribute &a = e->attributes().at(i);
+        if (a.type == QInputMethodEvent::Selection) {
+            QTextCursor oldCursor = cursor;
+            int blockStart = a.start + cursor.block().position();
+            cursor.setPosition(blockStart, QTextCursor::MoveAnchor);
+            cursor.setPosition(blockStart + a.length, QTextCursor::KeepAnchor);
+            repaintOldAndNewSelection(oldCursor);
+            forceSelectionChanged = true;
+        }
+    }
+
+    QTextBlock block = cursor.block();
+    QTextLayout *layout = block.layout();
+    if (isGettingInput) {
+        layout->setPreeditArea(cursor.position() - block.position(), e->preeditString());
+        emit q->preeditTextChanged();
+    }
+    QVector<QTextLayout::FormatRange> overrides;
+    const int oldPreeditCursor = preeditCursor;
+    preeditCursor = e->preeditString().length();
+    hasImState = !e->preeditString().isEmpty();
+    cursorVisible = true;
+    for (int i = 0; i < e->attributes().size(); ++i) {
+        const QInputMethodEvent::Attribute &a = e->attributes().at(i);
+        if (a.type == QInputMethodEvent::Cursor) {
+            hasImState = true;
+            preeditCursor = a.start;
+            cursorVisible = a.length != 0;
+        } else if (a.type == QInputMethodEvent::TextFormat) {
+            hasImState = true;
+            QTextCharFormat f = qvariant_cast<QTextFormat>(a.value).toCharFormat();
+            if (f.isValid()) {
+                QTextLayout::FormatRange o;
+                o.start = a.start + cursor.position() - block.position();
+                o.length = a.length;
+                o.format = f;
+                overrides.append(o);
+            }
+        }
+    }
+    layout->setFormats(overrides);
+
+    cursor.endEditBlock();
+
+
+    // THIS IS TO BE REMOVED
+//    QTextCursorPrivate *cursor_d = QTextCursorPrivate::getPrivate(&cursor);
+//    if (cursor_d)
+//        cursor_d->setX();
+
+    // TO BE REMOVED
+
+
+    q->updateCursorRectangle(oldPreeditCursor != preeditCursor || forceSelectionChanged || isGettingInput);
+    selectionChanged(forceSelectionChanged);
+}
+
+QVariant TextControl::inputMethodQuery(Qt::InputMethodQuery property) const
+{
+    return inputMethodQuery(property, QVariant());
+}
+
+QVariant TextControl::inputMethodQuery(Qt::InputMethodQuery property, QVariant argument) const
+{
+    Q_D(const TextControl);
+    QTextBlock block = d->cursor.block();
+    switch (property) {
+    case Qt::ImCursorRectangle:
+        return cursorRect();
+    case Qt::ImAnchorRectangle:
+        return anchorRect();
+    case Qt::ImFont:
+        return QVariant(d->cursor.charFormat().font());
+    case Qt::ImCursorPosition: {
+        const QPointF pt = argument.toPointF();
+        if (!pt.isNull())
+            return QVariant(d->doc->documentLayout()->hitTest(pt, Qt::FuzzyHit) - block.position());
+        return QVariant(d->cursor.position() - block.position());
+    }
+    case Qt::ImSurroundingText:
+        return QVariant(block.text());
+    case Qt::ImCurrentSelection:
+        return QVariant(d->cursor.selectedText());
+    case Qt::ImMaximumTextLength:
+        return QVariant(); // No limit.
+    case Qt::ImAnchorPosition:
+        return QVariant(d->cursor.anchor() - block.position());
+    case Qt::ImAbsolutePosition:
+        return QVariant(d->cursor.anchor());
+    case Qt::ImTextAfterCursor:
+    {
+        int maxLength = argument.isValid() ? argument.toInt() : 1024;
+        QTextCursor tmpCursor = d->cursor;
+        int localPos = d->cursor.position() - block.position();
+        QString result = block.text().mid(localPos);
+        while (result.length() < maxLength) {
+            int currentBlock = tmpCursor.blockNumber();
+            tmpCursor.movePosition(QTextCursor::NextBlock);
+            if (tmpCursor.blockNumber() == currentBlock)
+                break;
+            result += QLatin1Char('\n') + tmpCursor.block().text();
+        }
+        return QVariant(result);
+    }
+    case Qt::ImTextBeforeCursor:
+    {
+        int maxLength = argument.isValid() ? argument.toInt() : 1024;
+        QTextCursor tmpCursor = d->cursor;
+        int localPos = d->cursor.position() - block.position();
+        int numBlocks = 0;
+        int resultLen = localPos;
+        while (resultLen < maxLength) {
+            int currentBlock = tmpCursor.blockNumber();
+            tmpCursor.movePosition(QTextCursor::PreviousBlock);
+            if (tmpCursor.blockNumber() == currentBlock)
+                break;
+            numBlocks++;
+            resultLen += tmpCursor.block().length();
+        }
+        QString result;
+        while (numBlocks) {
+            result += tmpCursor.block().text() + QLatin1Char('\n');
+            tmpCursor.movePosition(QTextCursor::NextBlock);
+            --numBlocks;
+        }
+        result += block.text().midRef(0,localPos);
+        return QVariant(result);
+    }
+    default:
+        return QVariant();
+    }
+}
+#endif // QT_NO_IM
+
+void TextControlPrivate::focusEvent(QFocusEvent *e)
+{
+    Q_Q(TextControl);
+    emit q->updateRequest();
+    hasFocus = e->gotFocus();
+    if (e->gotFocus()) {
+        setBlinkingCursorEnabled(interactionFlags & (Qt::TextEditable | Qt::TextSelectableByKeyboard));
+    } else {
+        setBlinkingCursorEnabled(false);
+
+        if (cursorIsFocusIndicator
+            && e->reason() != Qt::ActiveWindowFocusReason
+            && e->reason() != Qt::PopupFocusReason
+            && cursor.hasSelection() && clearSelectionOnFocus)
+        {
+            cursor.clearSelection();
+            emit q->selectionChanged();
+        }
+    }
+}
+
+void TextControlPrivate::hoverEvent(QHoverEvent *e, const QPointF &pos)
+{
+    Q_Q(TextControl);
+
+    QString link;
+    if (e->type() != QEvent::HoverLeave)
+        link = q->anchorAt(pos);
+
+    if (hoveredLink != link) {
+        hoveredLink = link;
+        emit q->linkHovered(link);
+    }
+}
+
+bool TextControl::hasImState() const
+{
+    Q_D(const TextControl);
+    return d->hasImState;
+}
+
+bool TextControl::cursorVisible() const
+{
+    Q_D(const TextControl);
+    return d->cursorVisible;
+}
+
+void TextControl::setCursorVisible(bool visible)
+{
+    Q_D(TextControl);
+    d->cursorVisible = visible;
+    d->setBlinkingCursorEnabled(d->cursorVisible
+            && (d->interactionFlags & (Qt::TextEditable | Qt::TextSelectableByKeyboard)));
+}
+
+QRectF TextControl::anchorRect() const
+{
+    Q_D(const TextControl);
+    QRectF rect;
+    QTextCursor cursor = d->cursor;
+    if (!cursor.isNull()) {
+        rect = d->rectForPosition(cursor.anchor());
+    }
+    return rect;
+}
+
+QRectF TextControl::cursorRect(const QTextCursor &cursor) const
+{
+    Q_D(const TextControl);
+    if (cursor.isNull())
+        return QRectF();
+
+    return d->rectForPosition(cursor.position());
+}
+
+QRectF TextControl::cursorRect() const
+{
+    Q_D(const TextControl);
+    return cursorRect(d->cursor);
+}
+
+QString TextControl::hoveredLink() const
+{
+    Q_D(const TextControl);
+    return d->hoveredLink;
+}
+
+QString TextControl::anchorAt(const QPointF &pos) const
+{
+    Q_D(const TextControl);
+    return d->doc->documentLayout()->anchorAt(pos);
+}
+
+void TextControl::setAcceptRichText(bool accept)
+{
+    Q_D(TextControl);
+    d->acceptRichText = accept;
+}
+
+void TextControl::moveCursor(QTextCursor::MoveOperation op, QTextCursor::MoveMode mode)
+{
+    Q_D(TextControl);
+    const QTextCursor oldSelection = d->cursor;
+    const bool moved = d->cursor.movePosition(op, mode);
+    d->_q_updateCurrentCharFormatAndSelection();
+    updateCursorRectangle(true);
+    d->repaintOldAndNewSelection(oldSelection);
+    if (moved)
+        emit cursorPositionChanged();
+}
+
+bool TextControl::canPaste() const
+{
+#ifndef QT_NO_CLIPBOARD
+    Q_D(const TextControl);
+    if (d->interactionFlags & Qt::TextEditable) {
+        const QMimeData *md = QGuiApplication::clipboard()->mimeData();
+        return md && canInsertFromMimeData(md);
+    }
+#endif
+    return false;
+}
+
+void TextControl::setCursorIsFocusIndicator(bool b)
+{
+    Q_D(TextControl);
+    d->cursorIsFocusIndicator = b;
+    d->repaintCursor();
+}
+
+void TextControl::setWordSelectionEnabled(bool enabled)
+{
+    Q_D(TextControl);
+    d->wordSelectionEnabled = enabled;
+}
+
+QMimeData *TextControl::createMimeDataFromSelection() const
+{
+    Q_D(const TextControl);
+    const QTextDocumentFragment fragment(d->cursor);
+    return new TextEditMimeData(fragment);
+}
+
+bool TextControl::canInsertFromMimeData(const QMimeData *source) const
+{
+    Q_D(const TextControl);
+    if (d->acceptRichText)
+        return source->hasText()
+            || source->hasHtml()
+            || source->hasFormat(QLatin1String("application/x-qrichtext"))
+            || source->hasFormat(QLatin1String("application/x-qt-richtext"));
+    else
+        return source->hasText();
+}
+
+void TextControl::insertFromMimeData(const QMimeData *source)
+{
+    Q_D(TextControl);
+    if (!(d->interactionFlags & Qt::TextEditable) || !source)
+        return;
+
+    bool hasData = false;
+    QTextDocumentFragment fragment;
+#ifndef QT_NO_TEXTHTMLPARSER
+    if (source->hasFormat(QLatin1String("application/x-qrichtext")) && d->acceptRichText) {
+        // x-qrichtext is always UTF-8 (taken from Qt3 since we don't use it anymore).
+        QString richtext = QString::fromUtf8(source->data(QLatin1String("application/x-qrichtext")));
+        richtext.prepend(QLatin1String("<meta name=\"qrichtext\" content=\"1\" />"));
+        fragment = QTextDocumentFragment::fromHtml(richtext, d->doc);
+        hasData = true;
+    } else if (source->hasHtml() && d->acceptRichText) {
+        fragment = QTextDocumentFragment::fromHtml(source->html(), d->doc);
+        hasData = true;
+    } else {
+        QString text = source->text();
+        if (!text.isNull()) {
+            fragment = QTextDocumentFragment::fromPlainText(text);
+            hasData = true;
+        }
+    }
+#else
+    fragment = QTextDocumentFragment::fromPlainText(source->text());
+#endif // QT_NO_TEXTHTMLPARSER
+
+    if (hasData)
+        d->cursor.insertFragment(fragment);
+    updateCursorRectangle(true);
+}
+
+void TextControlPrivate::activateLinkUnderCursor(QString href)
+{
+    QTextCursor oldCursor = cursor;
+
+    if (href.isEmpty()) {
+        QTextCursor tmp = cursor;
+        if (tmp.selectionStart() != tmp.position())
+            tmp.setPosition(tmp.selectionStart());
+        tmp.movePosition(QTextCursor::NextCharacter);
+        href = tmp.charFormat().anchorHref();
+    }
+    if (href.isEmpty())
+        return;
+
+    if (!cursor.hasSelection()) {
+        QTextBlock block = cursor.block();
+        const int cursorPos = cursor.position();
+
+        QTextBlock::Iterator it = block.begin();
+        QTextBlock::Iterator linkFragment;
+
+        for (; !it.atEnd(); ++it) {
+            QTextFragment fragment = it.fragment();
+            const int fragmentPos = fragment.position();
+            if (fragmentPos <= cursorPos &&
+                fragmentPos + fragment.length() > cursorPos) {
+                linkFragment = it;
+                break;
+            }
+        }
+
+        if (!linkFragment.atEnd()) {
+            it = linkFragment;
+            cursor.setPosition(it.fragment().position());
+            if (it != block.begin()) {
+                do {
+                    --it;
+                    QTextFragment fragment = it.fragment();
+                    if (fragment.charFormat().anchorHref() != href)
+                        break;
+                    cursor.setPosition(fragment.position());
+                } while (it != block.begin());
+            }
+
+            for (it = linkFragment; !it.atEnd(); ++it) {
+                QTextFragment fragment = it.fragment();
+                if (fragment.charFormat().anchorHref() != href)
+                    break;
+                cursor.setPosition(fragment.position() + fragment.length(), QTextCursor::KeepAnchor);
+            }
+        }
+    }
+
+    if (hasFocus) {
+        cursorIsFocusIndicator = true;
+    } else {
+        cursorIsFocusIndicator = false;
+        cursor.clearSelection();
+    }
+    repaintOldAndNewSelection(oldCursor);
+
+    emit q_func()->linkActivated(href);
+}
+
+#ifndef QT_NO_IM
+bool TextControlPrivate::isPreediting() const
+{
+    QTextLayout *layout = cursor.block().layout();
+    if (layout && !layout->preeditAreaText().isEmpty())
+        return true;
+
+    return false;
+}
+
+void TextControlPrivate::commitPreedit()
+{
+    Q_Q(TextControl);
+
+    if (!hasImState)
+        return;
+
+    QGuiApplication::inputMethod()->commit();
+
+    if (!hasImState)
+        return;
+
+    QInputMethodEvent event;
+    QCoreApplication::sendEvent(q->parent(), &event);
+}
+
+void TextControlPrivate::cancelPreedit()
+{
+    Q_Q(TextControl);
+
+    if (!hasImState)
+        return;
+
+    QGuiApplication::inputMethod()->reset();
+
+    QInputMethodEvent event;
+    QCoreApplication::sendEvent(q->parent(), &event);
+}
+#endif // QT_NO_IM
+
+void TextControl::setTextEdit(TextEdit* te)
+{
+    Q_D(TextControl);
+    d->textEdit = te;
+}
+
+void TextControl::setTextInteractionFlags(Qt::TextInteractionFlags flags)
+{
+    Q_D(TextControl);
+    if (flags == d->interactionFlags)
+        return;
+    d->interactionFlags = flags;
+
+    if (d->hasFocus)
+        d->setBlinkingCursorEnabled(flags & (Qt::TextEditable | Qt::TextSelectableByKeyboard));
+}
+
+Qt::TextInteractionFlags TextControl::textInteractionFlags() const
+{
+    Q_D(const TextControl);
+    return d->interactionFlags;
+}
+
+QString TextControl::toPlainText() const
+{
+    return document()->toPlainText();
+}
+
+#ifndef QT_NO_TEXTHTMLPARSER
+QString TextControl::toHtml() const
+{
+    return document()->toHtml();
+}
+#endif
+
+bool TextControl::cursorOn() const
+{
+    Q_D(const TextControl);
+    return d->cursorOn;
+}
+
+int TextControl::hitTest(const QPointF &point, Qt::HitTestAccuracy accuracy) const
+{
+    Q_D(const TextControl);
+    return d->doc->documentLayout()->hitTest(point, accuracy);
+}
+
+QRectF TextControl::blockBoundingRect(const QTextBlock &block) const
+{
+    Q_D(const TextControl);
+    return d->doc->documentLayout()->blockBoundingRect(block);
+}
+
+QString TextControl::preeditText() const
+{
+#ifndef QT_NO_IM
+    Q_D(const TextControl);
+    QTextLayout *layout = d->cursor.block().layout();
+    if (!layout)
+        return QString();
+
+    return layout->preeditAreaText();
+#else
+    return QString();
+#endif
+}
+
+
+QStringList TextEditMimeData::formats() const
+{
+    if (!fragment.isEmpty())
+        return QStringList() << QString::fromLatin1("text/plain") << QString::fromLatin1("text/html")
+#ifndef QT_NO_TEXTODFWRITER
+            << QString::fromLatin1("application/vnd.oasis.opendocument.text")
+#endif
+        ;
+    else
+        return QMimeData::formats();
+}
+
+QVariant TextEditMimeData::retrieveData(const QString &mimeType, QVariant::Type type) const
+{
+    if (!fragment.isEmpty())
+        setup();
+    return QMimeData::retrieveData(mimeType, type);
+}
+
+void TextEditMimeData::setup() const
+{
+    TextEditMimeData *that = const_cast<TextEditMimeData *>(this);
+#ifndef QT_NO_TEXTHTMLPARSER
+    that->setData(QLatin1String("text/html"), fragment.toHtml("utf-8").toUtf8());
+#endif
+#ifndef QT_NO_TEXTODFWRITER
+    {
+        QBuffer buffer;
+        QTextDocumentWriter writer(&buffer, "ODF");
+        writer.write(fragment);
+        buffer.close();
+        that->setData(QLatin1String("application/vnd.oasis.opendocument.text"), buffer.data());
+    }
+#endif
+    that->setText(fragment.toPlainText());
+    fragment = QTextDocumentFragment();
+}
+
+
+}
+
+#include "moc_textcontrol_p.cpp"
+
+#endif // QT_NO_TEXTCONTROL
diff --git a/lib/lveditor/3rdparty/textdocumentlayout.cpp b/lib/lveditor/3rdparty/textdocumentlayout.cpp
index d5128ae..5eaf1b6 100644
--- a/lib/lveditor/3rdparty/textdocumentlayout.cpp
+++ b/lib/lveditor/3rdparty/textdocumentlayout.cpp
@@ -1,2457 +1,2368 @@
-/****************************************************************************
-**
-** Copyright (C) 2016 The Qt Company Ltd.
-** Contact: https://www.qt.io/licensing/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and The Qt Company. For licensing terms
-** and conditions see https://www.qt.io/terms-conditions. For further
-** information use the contact form at https://www.qt.io/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 2.0 or (at your option) the GNU General
-** Public license version 3 or any later version approved by the KDE Free
-** Qt Foundation. The licenses are as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
-** included in the packaging of this file. Please review the following
-** information to ensure the GNU General Public License requirements will
-** be met: https://www.gnu.org/licenses/gpl-2.0.html and
-** https://www.gnu.org/licenses/gpl-3.0.html.
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "textdocumentlayout.h"
-#include "qtextlist.h"
-#include "private/qtextengine_p.h"
-#include "private/qabstracttextdocumentlayout_p.h"
-
-#include <qpainter.h>
-#include <qmath.h>
-#include <qrect.h>
-#include <qpalette.h>
-#include <qdebug.h>
-#include <qvarlengtharray.h>
-#include <limits.h>
-#include <qbasictimer.h>
-
-#include <algorithm>
-#include "linemanager.h"
-
-#ifdef LAYOUT_DEBUG
-#define LDEBUG qDebug()
-#define INC_INDENT debug_indent += "  "
-#define DEC_INDENT debug_indent = debug_indent.left(debug_indent.length()-2)
-#else
-#define LDEBUG if(0) qDebug()
-#define INC_INDENT do {} while(0)
-#define DEC_INDENT do {} while(0)
-#endif
-
-
-
-class QTextFrameIterator {
-    QTextFrame *f;
-    int b;
-    int e;
-    QTextFrame *cf;
-    int cb;
-
-    friend class QTextFrame;
-    friend class lv::TextDocumentLayoutPrivate;
-    QTextFrameIterator(QTextFrame *frame, int block, int begin, int end)
-    {
-        f = frame;
-        b = begin;
-        e = end;
-        cf = nullptr;
-        cb = block;
-    }
-public:
-    static QTextFrameIterator findFrameBeginning(const QTextFrame *frame);
-    QTextFrameIterator(){
-        f = nullptr;
-        b = 0;
-        e = 0;
-        cf = nullptr;
-        cb = 0;
-    }
-#if QT_VERSION < QT_VERSION_CHECK(6,0,0)
-    QTextFrameIterator(const QTextFrameIterator &other) Q_DECL_NOTHROW
-    {
-        f = other.f;
-        b = other.b;
-        e = other.e;
-        cf = other.cf;
-        cb = other.cb;
-    } // = default
-    QTextFrameIterator &operator=(const QTextFrameIterator &other) Q_DECL_NOTHROW
-    {
-        f = other.f;
-        b = other.b;
-        e = other.e;
-        cf = other.cf;
-        cb = other.cb;
-        return *this;
-    } // = default
-    QTextFrameIterator(QTextFrameIterator &&other) Q_DECL_NOTHROW // = default
-    { memcpy(static_cast<void *>(this), static_cast<void *>(&other), sizeof(QTextFrameIterator)); }
-    QTextFrameIterator &operator=(QTextFrameIterator &&other) Q_DECL_NOTHROW // = default
-    { memcpy(static_cast<void *>(this), static_cast<void *>(&other), sizeof(QTextFrameIterator)); return *this; }
-#endif
-
-    QTextFrame *parentFrame() const { return f; }
-
-    QTextFrame *currentFrame() const
-    {
-        return cf;
-    }
-    QTextBlock currentBlock() const
-    {
-        if (!f)
-            return QTextBlock();
-        return QTextBlock(f->docHandle(), cb);
-    }
-
-    bool atEnd() const { return !cf && cb == e; }
-
-    inline bool operator==(const QTextFrameIterator &o) const { return f == o.f && cf == o.cf && cb == o.cb; }
-    inline bool operator!=(const QTextFrameIterator &o) const { return f != o.f || cf != o.cf || cb != o.cb; }
-    QTextFrameIterator &operator++()
-    {
-        const QTextDocumentPrivate *priv = f->docHandle();
-        QTextDocument* document = f->document();
-        const QTextDocumentPrivate::BlockMap &map = priv->blockMap();
-        if (cf) {
-            int end = cf->lastPosition() + 1;
-            cb = map.findNode(end);
-            cf = 0;
-        } else if (cb) {
-            cb = map.next(cb);
-            if (cb == e)
-                return *this;
-
-            if (!f->childFrames().isEmpty()) {
-                int pos = map.position(cb);
-                // check if we entered a frame
-                QTextDocumentPrivate::FragmentIterator frag = priv->find(pos-1);
-                if (priv->buffer().at(frag->stringPosition) != QChar::ParagraphSeparator) {
-
-                    auto formats = priv->formatCollection();
-                    int objectIndex = formats->format(frag->format).objectIndex();
-
-                    QTextFrame *nf = qobject_cast<QTextFrame *>(document->object(objectIndex));
-                    if (nf) {
-                        if (priv->buffer().at(frag->stringPosition) == QTextBeginningOfFrame && nf != f) {
-                            cf = nf;
-                            cb = 0;
-                        } else {
-                            Q_ASSERT(priv->buffer().at(frag->stringPosition) != QTextEndOfFrame);
-                        }
-                    }
-                }
-            }
-        }
-        return *this;
-    }
-    inline QTextFrameIterator operator++(int) { QTextFrameIterator tmp = *this; operator++(); return tmp; }
-    QTextFrameIterator &operator--()
-    {
-        const QTextDocumentPrivate *priv = f->docHandle();
-        QTextDocument* document = f->document();
-        const QTextDocumentPrivate::BlockMap &map = priv->blockMap();
-        if (cf) {
-            int start = cf->firstPosition() - 1;
-            cb = map.findNode(start);
-            cf = 0;
-        } else {
-            if (cb == b)
-                goto end;
-            if (cb != e) {
-                int pos = map.position(cb);
-                // check if we have to enter a frame
-                QTextDocumentPrivate::FragmentIterator frag = priv->find(pos-1);
-                if (priv->buffer().at(frag->stringPosition) != QChar::ParagraphSeparator) {
-
-                    auto formats = priv->formatCollection();
-                    int objectIndex = formats->format(frag->format).objectIndex();
-
-                    QTextFrame *pf = qobject_cast<QTextFrame *>(document->object(objectIndex));
-
-                    if (pf) {
-                        if (priv->buffer().at(frag->stringPosition) == QTextBeginningOfFrame) {
-                            Q_ASSERT(pf == f);
-                        } else if (priv->buffer().at(frag->stringPosition) == QTextEndOfFrame) {
-                            Q_ASSERT(pf != f);
-                            cf = pf;
-                            cb = 0;
-                            goto end;
-                        }
-                    }
-                }
-            }
-            cb = map.previous(cb);
-        }
-     end:
-        return *this;
-    }
-    inline QTextFrameIterator operator--(int) { QTextFrameIterator tmp = *this; operator--(); return tmp; }
-};
-
-inline QTextFrameIterator QTextFrameIterator::findFrameBeginning(const QTextFrame *frame)
-{
-    const QTextDocumentPrivate *priv = frame->docHandle();
-    int b = priv->blockMap().findNode(frame->firstPosition());
-    int e = priv->blockMap().findNode(frame->lastPosition()+1);
-    return QTextFrameIterator(const_cast<QTextFrame *>(frame), b, b, e);
-}
-
-Q_DECLARE_TYPEINFO(QTextFrameIterator, Q_MOVABLE_TYPE);
-
-// ################ should probably add frameFormatChange notification!
-
-struct TextLayoutStruct;
-
-class TextFrameData : public QTextFrameLayoutData
-{
-public:
-    TextFrameData();
-
-    // relative to parent frame
-    QFixedPoint position;
-    QFixedSize size;
-
-    // contents starts at (margin+border/margin+border)
-    QFixed topMargin;
-    QFixed bottomMargin;
-    QFixed leftMargin;
-    QFixed rightMargin;
-    QFixed border;
-    QFixed padding;
-    QFixed contentsWidth;
-    QFixed contentsHeight;
-    QFixed oldContentsWidth;
-
-    // accumulated margins
-    QFixed effectiveTopMargin;
-    QFixed effectiveBottomMargin;
-
-    QFixed minimumWidth;
-    QFixed maximumWidth;
-
-    TextLayoutStruct *currentLayoutStruct;
-
-    bool sizeDirty;
-    bool layoutDirty;
-
-    QVector<QPointer<QTextFrame> > floats;
-};
-
-TextFrameData::TextFrameData()
-    : maximumWidth(QFIXED_MAX),
-      currentLayoutStruct(0), sizeDirty(true), layoutDirty(true)
-{
-}
-
-struct TextLayoutStruct {
-    TextLayoutStruct() : maximumWidth(QFIXED_MAX), fullLayout(false)
-    {}
-    QTextFrame *frame;
-    QFixed x_left;
-    QFixed x_right;
-    QFixed frameY; // absolute y position of the current frame
-    QFixed y; // always relative to the current frame
-    QFixed contentsWidth;
-    QFixed minimumWidth;
-    QFixed maximumWidth;
-    bool fullLayout;
-    QList<QTextFrame *> pendingFloats;
-    QFixed pageHeight;
-    QFixed pageBottom;
-    QFixed pageTopMargin;
-    QFixed pageBottomMargin;
-    QRectF updateRect;
-    QRectF updateRectForFloats;
-
-    inline void addUpdateRectForFloat(const QRectF &rect) {
-        if (updateRectForFloats.isValid())
-            updateRectForFloats |= rect;
-        else
-            updateRectForFloats = rect;
-    }
-
-    inline QFixed absoluteY() const
-    { return frameY + y; }
-
-    inline int currentPage() const
-    { return pageHeight == 0 ? 0 : (absoluteY() / pageHeight).truncate(); }
-
-    inline void newPage()
-    { if (pageHeight == QFIXED_MAX) return; pageBottom += pageHeight; y = pageBottom - pageHeight + pageBottomMargin + pageTopMargin - frameY; }
-};
-
-static TextFrameData *createData(QTextFrame *f)
-{
-    TextFrameData *data = new TextFrameData;
-    f->setLayoutData(data);
-    return data;
-}
-
-static inline TextFrameData *data(QTextFrame *f)
-{
-    TextFrameData *data = static_cast<TextFrameData *>(f->layoutData());
-    if (!data)
-        data = createData(f);
-    return data;
-}
-
-static bool isFrameFromInlineObject(QTextFrame *f)
-{
-    return f->firstPosition() > f->lastPosition();
-}
-
-struct CheckPoint
-{
-    QFixed y;
-    QFixed frameY; // absolute y position of the current frame
-    int positionInFrame;
-    QFixed minimumWidth;
-    QFixed maximumWidth;
-    QFixed contentsWidth;
-};
-Q_DECLARE_TYPEINFO(CheckPoint, Q_PRIMITIVE_TYPE);
-
-static bool operator<(const CheckPoint &checkPoint, QFixed y)
-{
-    return checkPoint.y < y;
-}
-
-static bool operator<(const CheckPoint &checkPoint, int pos)
-{
-    return checkPoint.positionInFrame < pos;
-}
-
-#if defined(Q_CC_MSVC) && _MSC_VER < 1600
-//The STL implementation of MSVC 2008 requires the definitions
-
-static bool operator<(const CheckPoint &checkPoint1, const CheckPoint &checkPoint2)
-{
-    return checkPoint1.y < checkPoint2.y;
-}
-
-static bool operator<(QFixed y, const CheckPoint &checkPoint)
-{
-    return y < checkPoint.y;
-}
-
-static bool operator<(int pos, const CheckPoint &checkPoint)
-{
-    return pos < checkPoint.positionInFrame;
-}
-
-#endif
-
-static void fillBackground(QPainter *p, const QRectF &rect, QBrush brush, const QPointF &origin, const QRectF &gradientRect = QRectF())
-{
-    p->save();
-    if (brush.style() >= Qt::LinearGradientPattern && brush.style() <= Qt::ConicalGradientPattern) {
-        if (!gradientRect.isNull()) {
-            QTransform m;
-            m.translate(gradientRect.left(), gradientRect.top());
-            m.scale(gradientRect.width(), gradientRect.height());
-            brush.setTransform(m);
-            const_cast<QGradient *>(brush.gradient())->setCoordinateMode(QGradient::LogicalMode);
-        }
-    } else {
-        p->setBrushOrigin(origin);
-    }
-    p->fillRect(rect, brush);
-    p->restore();
-}
-
-namespace lv {
-
-class TextDocumentLayoutPrivate : public QAbstractTextDocumentLayoutPrivate
-{
-    Q_DECLARE_PUBLIC(TextDocumentLayout)
-public:
-    TextDocumentLayoutPrivate();
-
-    QTextOption::WrapMode wordWrapMode;
-#ifdef LAYOUT_DEBUG
-    mutable QString debug_indent;
-#endif
-
-    int fixedColumnWidth;
-    int cursorWidth;
-
-    QSizeF lastReportedSize;
-    QRectF viewportRect;
-    QRectF clipRect;
-
-    mutable int currentLazyLayoutPosition;
-    mutable int lazyLayoutStepSize;
-    QBasicTimer layoutTimer;
-    mutable QBasicTimer sizeChangedTimer;
-    uint showLayoutProgress : 1;
-    uint insideDocumentChange : 1;
-
-    int lastPageCount;
-    qreal idealWidth;
-    bool contentHasAlignment;
-
-    LineManager* lineManager;
-
-    QFixed blockIndent(const QTextBlockFormat &blockFormat) const;
-
-    void drawFrame(const QPointF &offset, QPainter *painter, const QAbstractTextDocumentLayout::PaintContext &context,
-                   QTextFrame *f) const;
-    void drawFlow(const QPointF &offset, QPainter *painter, const QAbstractTextDocumentLayout::PaintContext &context,
-                  QTextFrameIterator it, const QList<QTextFrame *> &floats, QTextBlock *cursorBlockNeedingRepaint) const;
-    void drawBlock(const QPointF &offset, QPainter *painter, const QAbstractTextDocumentLayout::PaintContext &context,
-                   const QTextBlock &bl, bool inRootFrame) const;
-    void drawListItem(const QPointF &offset, QPainter *painter, const QAbstractTextDocumentLayout::PaintContext &context,
-                      const QTextBlock &bl, const QTextCharFormat *selectionFormat) const;
-    void drawBorder(QPainter *painter, const QRectF &rect, qreal topMargin, qreal bottomMargin, qreal border,
-                    const QBrush &brush, QTextFrameFormat::BorderStyle style) const;
-    void drawFrameDecoration(QPainter *painter, QTextFrame *frame, TextFrameData *fd, const QRectF &clip, const QRectF &rect) const;
-
-    enum HitPoint {
-        PointBefore,
-        PointAfter,
-        PointInside,
-        PointExact
-    };
-    HitPoint hitTest(QTextFrame *frame, const QFixedPoint &point, int *position, QTextLayout **l, Qt::HitTestAccuracy accuracy) const;
-    HitPoint hitTest(QTextFrameIterator it, HitPoint hit, const QFixedPoint &p,
-                     int *position, QTextLayout **l, Qt::HitTestAccuracy accuracy) const;
-    HitPoint hitTest(const QTextBlock &bl, const QFixedPoint &point, int *position, QTextLayout **l, Qt::HitTestAccuracy accuracy) const;
-
-    void positionFloat(QTextFrame *frame, QTextLine *currentLine = 0);
-
-    // calls the next one
-    QRectF layoutFrame(QTextFrame *f, int layoutFrom, int layoutTo, QFixed parentY = 0);
-    QRectF layoutFrame(QTextFrame *f, int layoutFrom, int layoutTo, QFixed frameWidth, QFixed frameHeight, QFixed parentY = 0);
-
-    void layoutBlock(const QTextBlock &bl, int blockPosition, const QTextBlockFormat &blockFormat,
-                     TextLayoutStruct *layoutStruct, int layoutFrom, int layoutTo, const QTextBlockFormat *previousBlockFormat);
-    void layoutFlow(QTextFrameIterator it, TextLayoutStruct *layoutStruct, int layoutFrom, int layoutTo, QFixed width = 0);
-
-    void floatMargins(const QFixed &y, const TextLayoutStruct *layoutStruct, QFixed *left, QFixed *right) const;
-    QFixed findY(QFixed yFrom, const TextLayoutStruct *layoutStruct, QFixed requiredWidth) const;
-
-    QVector<CheckPoint> checkPoints;
-
-    QTextFrameIterator frameIteratorForYPosition(QFixed y) const;
-    QTextFrameIterator frameIteratorForTextPosition(int position) const;
-
-    void ensureLayouted(QFixed y) const;
-    void ensureLayoutedByPosition(int position) const;
-    inline void ensureLayoutFinished() const
-    { ensureLayoutedByPosition(INT_MAX); }
-    void layoutStep() const;
-
-    QRectF frameBoundingRectInternal(QTextFrame *frame) const;
-
-    qreal scaleToDevice(qreal value) const;
-    QFixed scaleToDevice(QFixed value) const;
-};
-
-TextDocumentLayoutPrivate::TextDocumentLayoutPrivate()
-    : fixedColumnWidth(-1),
-      cursorWidth(1),
-      currentLazyLayoutPosition(-1),
-      lazyLayoutStepSize(1000),
-      lastPageCount(-1),
-      lineManager(nullptr)
-{
-    showLayoutProgress = true;
-    insideDocumentChange = false;
-    idealWidth = 0;
-    contentHasAlignment = false;
-}
-
-
-QTextFrameIterator TextDocumentLayoutPrivate::frameIteratorForYPosition(QFixed y) const
-{
-    QTextFrame *rootFrame = document->rootFrame();
-
-    if (checkPoints.isEmpty()
-        || y < 0 || y > data(rootFrame)->size.height)
-    {
-        return QTextFrameIterator::findFrameBeginning(rootFrame);
-    }
-
-    QVector<CheckPoint>::ConstIterator checkPoint = std::lower_bound(checkPoints.begin(), checkPoints.end(), y);
-    if (checkPoint == checkPoints.end())
-    {
-        return QTextFrameIterator::findFrameBeginning(rootFrame);
-    }
-
-    if (checkPoint != checkPoints.begin())
-        --checkPoint;
-
-    const int position = rootFrame->firstPosition() + checkPoint->positionInFrame;
-    return frameIteratorForTextPosition(position);
-}
-
-QTextFrameIterator TextDocumentLayoutPrivate::frameIteratorForTextPosition(int position) const
-{
-    QTextFrame *rootFrame = document->rootFrame();
-
-    const QTextDocumentPrivate::BlockMap &map = docPrivate->blockMap();
-    const int begin = map.findNode(rootFrame->firstPosition());
-    const int end = map.findNode(rootFrame->lastPosition()+1);
-
-    const int block = map.findNode(position);
-    const int blockPos = map.position(block);
-
-    QTextFrameIterator it(rootFrame, block, begin, end);
-
-    QTextFrame *containingFrame = document->frameAt(blockPos);
-    if (containingFrame != rootFrame) {
-        while (containingFrame->parentFrame() != rootFrame) {
-            containingFrame = containingFrame->parentFrame();
-            Q_ASSERT(containingFrame);
-        }
-
-        it.cf = containingFrame;
-        it.cb = 0;
-    }
-
-    return it;
-}
-
-TextDocumentLayoutPrivate::HitPoint
-TextDocumentLayoutPrivate::hitTest(QTextFrame *frame, const QFixedPoint &point, int *position, QTextLayout **l, Qt::HitTestAccuracy accuracy) const
-{
-    TextFrameData *fd = data(frame);
-    // #########
-    if (fd->layoutDirty)
-        return PointAfter;
-    Q_ASSERT(!fd->layoutDirty);
-    Q_ASSERT(!fd->sizeDirty);
-    const QFixedPoint relativePoint(point.x - fd->position.x, point.y - fd->position.y);
-
-    QTextFrame *rootFrame = document->rootFrame();
-
-//     LDEBUG << "checking frame" << frame->firstPosition() << "point=" << point
-//            << "position" << fd->position << "size" << fd->size;
-    if (frame != rootFrame) {
-        if (relativePoint.y < 0 || relativePoint.x < 0) {
-            *position = frame->firstPosition() - 1;
-//             LDEBUG << "before pos=" << *position;
-            return PointBefore;
-        } else if (relativePoint.y > fd->size.height || relativePoint.x > fd->size.width) {
-            *position = frame->lastPosition() + 1;
-//             LDEBUG << "after pos=" << *position;
-            return PointAfter;
-        }
-    }
-
-    if (isFrameFromInlineObject(frame)) {
-        *position = frame->firstPosition() - 1;
-        return PointExact;
-    }
-
-    const QList<QTextFrame *> childFrames = frame->childFrames();
-    for (int i = 0; i < childFrames.size(); ++i) {
-        QTextFrame *child = childFrames.at(i);
-        if (isFrameFromInlineObject(child)
-            && child->frameFormat().position() != QTextFrameFormat::InFlow
-            && hitTest(child, relativePoint, position, l, accuracy) == PointExact)
-        {
-            return PointExact;
-        }
-    }
-
-    QTextFrameIterator it = QTextFrameIterator::findFrameBeginning(frame);
-
-    if (frame == rootFrame) {
-        it = frameIteratorForYPosition(relativePoint.y);
-
-        Q_ASSERT(it.parentFrame() == frame);
-    }
-
-    if (it.currentFrame())
-        *position = it.currentFrame()->firstPosition();
-    else
-        *position = it.currentBlock().position();
-
-    return hitTest(it, PointBefore, relativePoint, position, l, accuracy);
-}
-
-TextDocumentLayoutPrivate::HitPoint
-TextDocumentLayoutPrivate::hitTest(QTextFrameIterator it, HitPoint hit, const QFixedPoint &p,
-                                    int *position, QTextLayout **l, Qt::HitTestAccuracy accuracy) const
-{
-    INC_INDENT;
-
-    for (; !it.atEnd(); ++it) {
-        QTextFrame *c = it.currentFrame();
-        HitPoint hp;
-        int pos = -1;
-        if (c) {
-            hp = hitTest(c, p, &pos, l, accuracy);
-        } else {
-            hp = hitTest(it.currentBlock(), p, &pos, l, accuracy);
-        }
-        if (hp >= PointInside) {
-            hit = hp;
-            *position = pos;
-            break;
-        }
-        if (hp == PointBefore && pos < *position) {
-            *position = pos;
-            hit = hp;
-        } else if (hp == PointAfter && pos > *position) {
-            *position = pos;
-            hit = hp;
-        }
-    }
-
-    DEC_INDENT;
-//     LDEBUG << "inside=" << hit << " pos=" << *position;
-    return hit;
-}
-
-TextDocumentLayoutPrivate::HitPoint
-TextDocumentLayoutPrivate::hitTest(const QTextBlock &bl, const QFixedPoint &point, int *position, QTextLayout **l,
-                                    Qt::HitTestAccuracy accuracy) const
-{
-    QTextLayout *tl = bl.layout();
-    QRectF textrect = tl->boundingRect();
-    textrect.translate(tl->position());
-//     LDEBUG << "    checking block" << bl.position() << "point=" << point
-//            << "    tlrect" << textrect;
-    *position = bl.position();
-    if (point.y.toReal() < textrect.top()) {
-//             LDEBUG << "    before pos=" << *position;
-        return PointBefore;
-    } else if (point.y.toReal() > textrect.bottom()) {
-        *position += bl.length();
-//             LDEBUG << "    after pos=" << *position;
-        return PointAfter;
-    }
-
-    QPointF pos = point.toPointF() - tl->position();
-
-    // ### rtl?
-
-    HitPoint hit = PointInside;
-    *l = tl;
-    int off = 0;
-    for (int i = 0; i < tl->lineCount(); ++i) {
-        QTextLine line = tl->lineAt(i);
-        const QRectF lr = line.naturalTextRect();
-        if (lr.top() > pos.y()) {
-            off = qMin(off, line.textStart());
-        } else if (lr.bottom() <= pos.y()) {
-            off = qMax(off, line.textStart() + line.textLength());
-        } else {
-            if (lr.left() <= pos.x() && lr.right() >= pos.x())
-                hit = PointExact;
-            // when trying to hit an anchor we want it to hit not only in the left
-            // half
-            if (accuracy == Qt::ExactHit)
-                off = line.xToCursor(pos.x(), QTextLine::CursorOnCharacter);
-            else
-                off = line.xToCursor(pos.x(), QTextLine::CursorBetweenCharacters);
-            break;
-        }
-    }
-    *position += off;
-
-//     LDEBUG << "    inside=" << hit << " pos=" << *position;
-    return hit;
-}
-
-// ### could be moved to QTextBlock
-QFixed TextDocumentLayoutPrivate::blockIndent(const QTextBlockFormat &blockFormat) const
-{
-    qreal indent = blockFormat.indent();
-
-    QTextObject *object = document->objectForFormat(blockFormat);
-    if (object)
-        indent += object->format().toListFormat().indent();
-
-    if (qIsNull(indent))
-        return 0;
-
-    qreal scale = 1;
-    if (paintDevice) {
-        scale = qreal(paintDevice->logicalDpiY()) / qreal(qt_defaultDpi());
-    }
-
-    return QFixed::fromReal(indent * scale * document->indentWidth());
-}
-
-void TextDocumentLayoutPrivate::drawBorder(QPainter *painter, const QRectF &rect, qreal topMargin, qreal bottomMargin,
-                                            qreal border, const QBrush &brush, QTextFrameFormat::BorderStyle style) const
-{
-    const qreal pageHeight = document->pageSize().height();
-    const int topPage = pageHeight > 0 ? static_cast<int>(rect.top() / pageHeight) : 0;
-    const int bottomPage = pageHeight > 0 ? static_cast<int>((rect.bottom() + border) / pageHeight) : 0;
-
-    Q_UNUSED(style);
-
-    bool turn_off_antialiasing = !(painter->renderHints() & QPainter::Antialiasing);
-    painter->setRenderHint(QPainter::Antialiasing);
-
-    for (int i = topPage; i <= bottomPage; ++i) {
-        QRectF clipped = rect.toRect();
-
-        if (topPage != bottomPage) {
-            clipped.setTop(qMax(clipped.top(), i * pageHeight + topMargin - border));
-            clipped.setBottom(qMin(clipped.bottom(), (i + 1) * pageHeight - bottomMargin));
-
-            if (clipped.bottom() <= clipped.top())
-                continue;
-        }
-
-        painter->save();
-        painter->setPen(Qt::NoPen);
-        painter->setBrush(brush);
-        painter->drawRect(QRectF(clipped.left(), clipped.top(), clipped.left() + border, clipped.bottom() + border));
-        painter->drawRect(QRectF(clipped.left() + border, clipped.top(), clipped.right() + border, clipped.top() + border));
-        painter->drawRect(QRectF(clipped.right(), clipped.top() + border, clipped.right() + border, clipped.bottom()));
-        painter->drawRect(QRectF(clipped.left() + border, clipped.bottom(), clipped.right() + border, clipped.bottom() + border));
-        painter->restore();
-    }
-    if (turn_off_antialiasing)
-        painter->setRenderHint(QPainter::Antialiasing, false);
-}
-
-void TextDocumentLayoutPrivate::drawFrameDecoration(QPainter *painter, QTextFrame *frame, TextFrameData *fd, const QRectF &clip, const QRectF &rect) const
-{
-
-    const QBrush bg = frame->frameFormat().background();
-    if (bg != Qt::NoBrush) {
-        QRectF bgRect = rect;
-        bgRect.adjust((fd->leftMargin + fd->border).toReal(),
-                      (fd->topMargin + fd->border).toReal(),
-                      - (fd->rightMargin + fd->border).toReal(),
-                      - (fd->bottomMargin + fd->border).toReal());
-
-        QRectF gradientRect; // invalid makes it default to bgRect
-        QPointF origin = bgRect.topLeft();
-        if (!frame->parentFrame()) {
-            bgRect = clip;
-            gradientRect.setWidth(painter->device()->width());
-            gradientRect.setHeight(painter->device()->height());
-        }
-        fillBackground(painter, bgRect, bg, origin, gradientRect);
-    }
-    if (fd->border != 0) {
-        painter->save();
-        painter->setBrush(Qt::lightGray);
-        painter->setPen(Qt::NoPen);
-
-        const qreal leftEdge = rect.left() + fd->leftMargin.toReal();
-        const qreal border = fd->border.toReal();
-        const qreal topMargin = fd->topMargin.toReal();
-        const qreal leftMargin = fd->leftMargin.toReal();
-        const qreal bottomMargin = fd->bottomMargin.toReal();
-        const qreal rightMargin = fd->rightMargin.toReal();
-        const qreal w = rect.width() - 2 * border - leftMargin - rightMargin;
-        const qreal h = rect.height() - 2 * border - topMargin - bottomMargin;
-
-        drawBorder(painter, QRectF(leftEdge, rect.top() + topMargin, w + border, h + border),
-                   fd->effectiveTopMargin.toReal(), fd->effectiveBottomMargin.toReal(),
-                   border, frame->frameFormat().borderBrush(), frame->frameFormat().borderStyle());
-
-        painter->restore();
-    }
-}
-
-void TextDocumentLayoutPrivate::drawFrame(const QPointF &offset, QPainter *painter,
-                                           const QAbstractTextDocumentLayout::PaintContext &context,
-                                           QTextFrame *frame) const
-{
-    TextFrameData *fd = data(frame);
-    // #######
-    if (fd->layoutDirty)
-        return;
-    Q_ASSERT(!fd->sizeDirty);
-    Q_ASSERT(!fd->layoutDirty);
-
-    const QPointF off = offset + fd->position.toPointF();
-    if (context.clip.isValid()
-        && (off.y() > context.clip.bottom() || off.y() + fd->size.height.toReal() < context.clip.top()
-            || off.x() > context.clip.right() || off.x() + fd->size.width.toReal() < context.clip.left()))
-        return;
-
-//     LDEBUG << debug_indent << "drawFrame" << frame->firstPosition() << "--" << frame->lastPosition() << "at" << offset;
-//     INC_INDENT;
-    QTextBlock cursorBlockNeedingRepaint;
-    QPointF offsetOfRepaintedCursorBlock = off;
-
-    const QRectF frameRect(off, fd->size.toSizeF());
-
-    drawFrameDecoration(painter, frame, fd, context.clip, frameRect);
-
-    QTextFrameIterator it = QTextFrameIterator::findFrameBeginning(frame);
-
-    if (frame == document->rootFrame())
-        it = frameIteratorForYPosition(QFixed::fromReal(context.clip.top()));
-
-    QList<QTextFrame *> floats;
-    const int numFloats = fd->floats.count();
-    floats.reserve(numFloats);
-    for (int i = 0; i < numFloats; ++i)
-        floats.append(fd->floats.at(i));
-
-    drawFlow(off, painter, context, it, floats, &cursorBlockNeedingRepaint);
-
-
-    if (cursorBlockNeedingRepaint.isValid()) {
-        const QPen oldPen = painter->pen();
-        painter->setPen(context.palette.color(QPalette::Text));
-        const int cursorPos = context.cursorPosition - cursorBlockNeedingRepaint.position();
-        cursorBlockNeedingRepaint.layout()->drawCursor(painter, offsetOfRepaintedCursorBlock,
-                                                       cursorPos, cursorWidth);
-        painter->setPen(oldPen);
-    }
-
-//     DEC_INDENT;
-
-    return;
-}
-
-void TextDocumentLayoutPrivate::drawFlow(const QPointF &offset, QPainter *painter, const QAbstractTextDocumentLayout::PaintContext &context,
-                                          QTextFrameIterator it, const QList<QTextFrame *> &floats, QTextBlock *cursorBlockNeedingRepaint) const
-{
-    Q_Q(const TextDocumentLayout);
-    const bool inRootFrame = (!it.atEnd() && it.parentFrame() && it.parentFrame()->parentFrame() == 0);
-
-    QVector<CheckPoint>::ConstIterator lastVisibleCheckPoint = checkPoints.end();
-    if (inRootFrame && context.clip.isValid()) {
-        lastVisibleCheckPoint = std::lower_bound(checkPoints.begin(), checkPoints.end(), QFixed::fromReal(context.clip.bottom()));
-    }
-
-    QTextBlock previousBlock;
-    QTextFrame *previousFrame = 0;
-
-    for (; !it.atEnd(); ++it) {
-        QTextFrame *c = it.currentFrame();
-
-        if (inRootFrame && !checkPoints.isEmpty()) {
-            int currentPosInDoc;
-            if (c)
-                currentPosInDoc = c->firstPosition();
-            else
-                currentPosInDoc = it.currentBlock().position();
-
-            // if we're past what is already laid out then we're better off
-            // not trying to draw things that may not be positioned correctly yet
-            if (currentPosInDoc >= checkPoints.constLast().positionInFrame)
-                break;
-
-            if (lastVisibleCheckPoint != checkPoints.end()
-                && context.clip.isValid()
-                && currentPosInDoc >= lastVisibleCheckPoint->positionInFrame
-               )
-                break;
-        }
-
-        if (c)
-            drawFrame(offset, painter, context, c);
-        else {
-            QAbstractTextDocumentLayout::PaintContext pc = context;
-            drawBlock(offset, painter, pc, it.currentBlock(), inRootFrame);
-        }
-
-        previousBlock = it.currentBlock();
-        previousFrame = c;
-    }
-
-    for (int i = 0; i < floats.count(); ++i) {
-        QTextFrame *frame = floats.at(i);
-        if (!isFrameFromInlineObject(frame)
-            || frame->frameFormat().position() == QTextFrameFormat::InFlow)
-            continue;
-
-        const int pos = frame->firstPosition() - 1;
-        QTextCharFormat format = const_cast<TextDocumentLayout *>(q)->format(pos);
-        QTextObjectInterface *handler = q->handlerForObject(format.objectType());
-        if (handler) {
-            QRectF rect = frameBoundingRectInternal(frame);
-            handler->drawObject(painter, rect, document, pos, format);
-        }
-    }
-}
-
-void TextDocumentLayoutPrivate::drawBlock(const QPointF &offset, QPainter *painter,
-                                           const QAbstractTextDocumentLayout::PaintContext &context,
-                                           const QTextBlock &bl, bool inRootFrame) const
-{
-    const QTextLayout *tl = bl.layout();
-    QRectF r = tl->boundingRect();
-    r.translate(offset + tl->position());
-    if (!bl.isVisible() || (context.clip.isValid() && (r.bottom() < context.clip.y() || r.top() > context.clip.bottom())))
-        return;
-//      LDEBUG << debug_indent << "drawBlock" << bl.position() << "at" << offset << "br" << tl->boundingRect();
-
-    QTextBlockFormat blockFormat = bl.blockFormat();
-
-    QBrush bg = blockFormat.background();
-    if (bg != Qt::NoBrush) {
-        QRectF rect = r;
-
-        // extend the background rectangle if we're in the root frame with NoWrap,
-        // as the rect of the text block will then be only the width of the text
-        // instead of the full page width
-        if (inRootFrame && document->pageSize().width() <= 0) {
-            const TextFrameData *fd = data(document->rootFrame());
-            rect.setRight((fd->size.width - fd->rightMargin).toReal());
-        }
-
-        fillBackground(painter, rect, bg, r.topLeft());
-    }
-
-    QVector<QTextLayout::FormatRange> selections;
-    int blpos = bl.position();
-    int bllen = bl.length();
-    const QTextCharFormat *selFormat = 0;
-    for (int i = 0; i < context.selections.size(); ++i) {
-        const QAbstractTextDocumentLayout::Selection &range = context.selections.at(i);
-        const int selStart = range.cursor.selectionStart() - blpos;
-        const int selEnd = range.cursor.selectionEnd() - blpos;
-        if (selStart < bllen && selEnd > 0
-             && selEnd > selStart) {
-            QTextLayout::FormatRange o;
-            o.start = selStart;
-            o.length = selEnd - selStart;
-            o.format = range.format;
-            selections.append(o);
-        } else if (! range.cursor.hasSelection() && range.format.hasProperty(QTextFormat::FullWidthSelection)
-                   && bl.contains(range.cursor.position())) {
-            // for full width selections we don't require an actual selection, just
-            // a position to specify the line. that's more convenience in usage.
-            QTextLayout::FormatRange o;
-            QTextLine l = tl->lineForTextPosition(range.cursor.position() - blpos);
-            o.start = l.textStart();
-            o.length = l.textLength();
-            if (o.start + o.length == bllen - 1)
-                ++o.length; // include newline
-            o.format = range.format;
-            selections.append(o);
-       }
-        if (selStart < 0 && selEnd >= 1)
-            selFormat = &range.format;
-    }
-
-    QTextObject *object = document->objectForFormat(bl.blockFormat());
-    if (object && object->format().toListFormat().style() != QTextListFormat::ListStyleUndefined)
-        drawListItem(offset, painter, context, bl, selFormat);
-
-    QPen oldPen = painter->pen();
-    painter->setPen(context.palette.color(QPalette::Text));
-
-    tl->draw(painter, offset, selections, context.clip.isValid() ? (context.clip & clipRect) : clipRect);
-
-    if ((context.cursorPosition >= blpos && context.cursorPosition < blpos + bllen)
-        || (context.cursorPosition < -1 && !tl->preeditAreaText().isEmpty())) {
-        int cpos = context.cursorPosition;
-        if (cpos < -1)
-            cpos = tl->preeditAreaPosition() - (cpos + 2);
-        else
-            cpos -= blpos;
-        tl->drawCursor(painter, offset, cpos, cursorWidth);
-    }
-
-    if (blockFormat.hasProperty(QTextFormat::BlockTrailingHorizontalRulerWidth)) {
-        const qreal width = blockFormat.lengthProperty(QTextFormat::BlockTrailingHorizontalRulerWidth).value(r.width());
-        painter->setPen(context.palette.color(QPalette::Dark));
-        qreal y = r.bottom();
-        if (bl.length() == 1)
-            y = r.top() + r.height() / 2;
-
-        const qreal middleX = r.left() + r.width() / 2;
-        painter->drawLine(QLineF(middleX - width / 2, y, middleX + width / 2, y));
-    }
-
-    painter->setPen(oldPen);
-}
-
-
-void TextDocumentLayoutPrivate::drawListItem(const QPointF &offset, QPainter *painter,
-                                              const QAbstractTextDocumentLayout::PaintContext &context,
-                                              const QTextBlock &bl, const QTextCharFormat *selectionFormat) const
-{
-    Q_Q(const TextDocumentLayout);
-    const QTextBlockFormat blockFormat = bl.blockFormat();
-    const QTextCharFormat charFormat = QTextCursor(bl).charFormat();
-    QFont font(charFormat.font());
-    if (q->paintDevice())
-        font = QFont(font, q->paintDevice());
-
-    const QFontMetrics fontMetrics(font);
-    QTextObject * const object = document->objectForFormat(blockFormat);
-    const QTextListFormat lf = object->format().toListFormat();
-    int style = lf.style();
-    QString itemText;
-    QSizeF size;
-
-    if (blockFormat.hasProperty(QTextFormat::ListStyle))
-        style = QTextListFormat::Style(blockFormat.intProperty(QTextFormat::ListStyle));
-
-    QTextLayout *layout = bl.layout();
-    if (layout->lineCount() == 0)
-        return;
-    QTextLine firstLine = layout->lineAt(0);
-    Q_ASSERT(firstLine.isValid());
-    QPointF pos = (offset + layout->position()).toPoint();
-    Qt::LayoutDirection dir = bl.textDirection();
-    {
-        QRectF textRect = firstLine.naturalTextRect();
-        pos += textRect.topLeft().toPoint();
-        if (dir == Qt::RightToLeft)
-            pos.rx() += textRect.width();
-    }
-
-    switch (style) {
-    case QTextListFormat::ListDecimal:
-    case QTextListFormat::ListLowerAlpha:
-    case QTextListFormat::ListUpperAlpha:
-    case QTextListFormat::ListLowerRoman:
-    case QTextListFormat::ListUpperRoman:
-        itemText = static_cast<QTextList *>(object)->itemText(bl);
-#if (QT_VERSION >= QT_VERSION_CHECK(5,10,0))
-        size.setWidth(fontMetrics.horizontalAdvance(itemText));
-#else
-        size.setWidth(fontMetrics.width(itemText));
-#endif
-        size.setHeight(fontMetrics.height());
-        break;
-
-    case QTextListFormat::ListSquare:
-    case QTextListFormat::ListCircle:
-    case QTextListFormat::ListDisc:
-        size.setWidth(fontMetrics.lineSpacing() / 3);
-        size.setHeight(size.width());
-        break;
-
-    case QTextListFormat::ListStyleUndefined:
-        return;
-    default: return;
-    }
-
-    QRectF r(pos, size);
-#if (QT_VERSION > QT_VERSION_CHECK(5,10,0))
-    qreal xoff = fontMetrics.horizontalAdvance(QLatin1Char(' '));
-#else
-    qreal xoff = fontMetrics.width(QLatin1Char(' '));
-#endif
-    if (dir == Qt::LeftToRight)
-        xoff = -xoff - size.width();
-    r.translate( xoff, (fontMetrics.height() / 2) - (size.height() / 2));
-
-    painter->save();
-
-    painter->setRenderHint(QPainter::Antialiasing);
-
-    if (selectionFormat) {
-        painter->setPen(QPen(selectionFormat->foreground(), 0));
-        painter->fillRect(r, selectionFormat->background());
-    } else {
-        QBrush fg = charFormat.foreground();
-        if (fg == Qt::NoBrush)
-            fg = context.palette.text();
-        painter->setPen(QPen(fg, 0));
-    }
-
-    QBrush brush = context.palette.brush(QPalette::Text);
-
-    switch (style) {
-    case QTextListFormat::ListDecimal:
-    case QTextListFormat::ListLowerAlpha:
-    case QTextListFormat::ListUpperAlpha:
-    case QTextListFormat::ListLowerRoman:
-    case QTextListFormat::ListUpperRoman: {
-        QTextLayout layout(itemText, font, q->paintDevice());
-        layout.setCacheEnabled(true);
-        QTextOption option(Qt::AlignLeft | Qt::AlignAbsolute);
-        option.setTextDirection(dir);
-        layout.setTextOption(option);
-        layout.beginLayout();
-        QTextLine line = layout.createLine();
-        if (line.isValid())
-            line.setLeadingIncluded(true);
-        layout.endLayout();
-        layout.draw(painter, QPointF(r.left(), pos.y()));
-        break;
-    }
-    case QTextListFormat::ListSquare:
-        painter->fillRect(r, brush);
-        break;
-    case QTextListFormat::ListCircle:
-        painter->setPen(QPen(brush, 0));
-        painter->drawEllipse(r.translated(0.5, 0.5)); // pixel align for sharper rendering
-        break;
-    case QTextListFormat::ListDisc:
-        painter->setBrush(brush);
-        painter->setPen(Qt::NoPen);
-        painter->drawEllipse(r);
-        break;
-    case QTextListFormat::ListStyleUndefined:
-        break;
-    default:
-        break;
-    }
-
-    painter->restore();
-}
-
-static QFixed flowPosition(const QTextFrameIterator &it)
-{
-    if (it.atEnd())
-        return 0;
-
-    if (it.currentFrame()) {
-        return data(it.currentFrame())->position.y;
-    } else {
-        QTextBlock block = it.currentBlock();
-        QTextLayout *layout = block.layout();
-        if (layout->lineCount() == 0)
-            return QFixed::fromReal(layout->position().y());
-        else
-            return QFixed::fromReal(layout->position().y() + layout->lineAt(0).y());
-    }
-}
-
-static QFixed firstChildPos(const QTextFrame *f)
-{
-    return flowPosition(QTextFrameIterator::findFrameBeginning(f));
-}
-
-void TextDocumentLayoutPrivate::positionFloat(QTextFrame *frame, QTextLine *currentLine)
-{
-    TextFrameData *fd = data(frame);
-
-    QTextFrame *parent = frame->parentFrame();
-    Q_ASSERT(parent);
-    TextFrameData *pd = data(parent);
-    Q_ASSERT(pd && pd->currentLayoutStruct);
-
-    TextLayoutStruct *layoutStruct = pd->currentLayoutStruct;
-
-    if (!pd->floats.contains(frame))
-        pd->floats.append(frame);
-    fd->layoutDirty = true;
-    Q_ASSERT(!fd->sizeDirty);
-
-    QFixed y = layoutStruct->y;
-    if (currentLine) {
-        QFixed left, right;
-        floatMargins(y, layoutStruct, &left, &right);
-        if (right - left < QFixed::fromReal(currentLine->naturalTextWidth()) + fd->size.width) {
-            layoutStruct->pendingFloats.append(frame);
-            return;
-        }
-    }
-
-    bool frameSpansIntoNextPage = (y + layoutStruct->frameY + fd->size.height > layoutStruct->pageBottom);
-    if (frameSpansIntoNextPage && fd->size.height <= layoutStruct->pageHeight) {
-        layoutStruct->newPage();
-        y = layoutStruct->y;
-
-        frameSpansIntoNextPage = false;
-    }
-
-    y = findY(y, layoutStruct, fd->size.width);
-
-    QFixed left, right;
-    floatMargins(y, layoutStruct, &left, &right);
-
-    if (frame->frameFormat().position() == QTextFrameFormat::FloatLeft) {
-        fd->position.x = left;
-        fd->position.y = y;
-    } else {
-        fd->position.x = right - fd->size.width;
-        fd->position.y = y;
-    }
-
-    layoutStruct->minimumWidth = qMax(layoutStruct->minimumWidth, fd->minimumWidth);
-    layoutStruct->maximumWidth = qMin(layoutStruct->maximumWidth, fd->maximumWidth);
-
-    fd->layoutDirty = false;
-
-}
-
-QRectF TextDocumentLayoutPrivate::layoutFrame(QTextFrame *f, int layoutFrom, int layoutTo, QFixed parentY)
-{
-    LDEBUG << "layoutFrame (pre)";
-    Q_ASSERT(data(f)->sizeDirty);
-
-    QTextFrameFormat fformat = f->frameFormat();
-
-    QTextFrame *parent = f->parentFrame();
-    const TextFrameData *pd = parent ? data(parent) : 0;
-
-    const qreal maximumWidth = qMax(qreal(0), pd ? pd->contentsWidth.toReal() : document->pageSize().width());
-    QFixed width = QFixed::fromReal(fformat.width().value(maximumWidth));
-    if (fformat.width().type() == QTextLength::FixedLength)
-        width = scaleToDevice(width);
-
-    const QFixed maximumHeight = pd ? pd->contentsHeight : -1;
-    const QFixed height = (maximumHeight != -1 || fformat.height().type() != QTextLength::PercentageLength)
-                            ? QFixed::fromReal(fformat.height().value(maximumHeight.toReal()))
-                            : -1;
-
-    return layoutFrame(f, layoutFrom, layoutTo, width, height, parentY);
-}
-
-QRectF TextDocumentLayoutPrivate::layoutFrame(QTextFrame *f, int layoutFrom, int layoutTo, QFixed frameWidth, QFixed frameHeight, QFixed parentY)
-{
-    LDEBUG << "layoutFrame from=" << layoutFrom << "to=" << layoutTo;
-    Q_ASSERT(data(f)->sizeDirty);
-
-    TextFrameData *fd = data(f);
-    QFixed newContentsWidth;
-
-    bool fullLayout = false;
-    {
-        QTextFrameFormat fformat = f->frameFormat();
-        // set sizes of this frame from the format
-        QFixed tm = QFixed::fromReal(fformat.topMargin());
-        if (tm != fd->topMargin) {
-            fd->topMargin = tm;
-            fullLayout = true;
-        }
-        QFixed bm = QFixed::fromReal(fformat.bottomMargin());
-        if (bm != fd->bottomMargin) {
-            fd->bottomMargin = bm;
-            fullLayout = true;
-        }
-        fd->leftMargin = QFixed::fromReal(fformat.leftMargin());
-        fd->rightMargin = QFixed::fromReal(fformat.rightMargin());
-        QFixed b = QFixed::fromReal(fformat.border());
-        if (b != fd->border) {
-            fd->border = b;
-            fullLayout = true;
-        }
-        QFixed p = QFixed::fromReal(fformat.padding());
-        if (p != fd->padding) {
-            fd->padding = p;
-            fullLayout = true;
-        }
-
-        QTextFrame *parent = f->parentFrame();
-        const TextFrameData *pd = parent ? data(parent) : 0;
-
-        // accumulate top and bottom margins
-        if (parent) {
-            fd->effectiveTopMargin = pd->effectiveTopMargin + fd->topMargin + fd->border + fd->padding;
-            fd->effectiveBottomMargin = pd->effectiveBottomMargin + fd->topMargin + fd->border + fd->padding;
-        } else {
-            fd->effectiveTopMargin = fd->topMargin + fd->border + fd->padding;
-            fd->effectiveBottomMargin = fd->bottomMargin + fd->border + fd->padding;
-        }
-
-        newContentsWidth = frameWidth - 2*(fd->border + fd->padding)
-                           - fd->leftMargin - fd->rightMargin;
-
-        if (frameHeight != -1) {
-            fd->contentsHeight = frameHeight - 2*(fd->border + fd->padding)
-                                 - fd->topMargin - fd->bottomMargin;
-        } else {
-            fd->contentsHeight = frameHeight;
-        }
-    }
-
-    if (isFrameFromInlineObject(f)) {
-        // never reached, handled in resizeInlineObject/positionFloat instead
-        return QRectF();
-    }
-
-    // set fd->contentsWidth temporarily, so that layoutFrame for the children
-    // picks the right width. We'll initialize it properly at the end of this
-    // function.
-    fd->contentsWidth = newContentsWidth;
-
-    TextLayoutStruct layoutStruct;
-    layoutStruct.frame = f;
-    layoutStruct.x_left = fd->leftMargin + fd->border + fd->padding;
-    layoutStruct.x_right = layoutStruct.x_left + newContentsWidth;
-    layoutStruct.y = fd->topMargin + fd->border + fd->padding;
-    layoutStruct.frameY = parentY + fd->position.y;
-    layoutStruct.contentsWidth = 0;
-    layoutStruct.minimumWidth = 0;
-    layoutStruct.maximumWidth = QFIXED_MAX;
-    layoutStruct.fullLayout = fullLayout || (fd->oldContentsWidth != newContentsWidth);
-    layoutStruct.updateRect = QRectF(QPointF(0, 0), QSizeF(qreal(INT_MAX), qreal(INT_MAX)));
-    LDEBUG << "layoutStruct: x_left" << layoutStruct.x_left << "x_right" << layoutStruct.x_right
-           << "fullLayout" << layoutStruct.fullLayout;
-    fd->oldContentsWidth = newContentsWidth;
-
-    layoutStruct.pageHeight = QFixed::fromReal(document->pageSize().height());
-    if (layoutStruct.pageHeight < 0)
-        layoutStruct.pageHeight = QFIXED_MAX;
-
-    const int currentPage = layoutStruct.pageHeight == 0 ? 0 : (layoutStruct.frameY / layoutStruct.pageHeight).truncate();
-    layoutStruct.pageTopMargin = fd->effectiveTopMargin;
-    layoutStruct.pageBottomMargin = fd->effectiveBottomMargin;
-    layoutStruct.pageBottom = (currentPage + 1) * layoutStruct.pageHeight - layoutStruct.pageBottomMargin;
-
-    if (!f->parentFrame())
-        idealWidth = 0; // reset
-
-    QTextFrameIterator it = QTextFrameIterator::findFrameBeginning(f);
-    layoutFlow(it, &layoutStruct, layoutFrom, layoutTo);
-
-    QFixed maxChildFrameWidth = 0;
-    QList<QTextFrame *> children = f->childFrames();
-    for (int i = 0; i < children.size(); ++i) {
-        QTextFrame *c = children.at(i);
-        TextFrameData *cd = data(c);
-        maxChildFrameWidth = qMax(maxChildFrameWidth, cd->size.width);
-    }
-
-    const QFixed marginWidth = 2*(fd->border + fd->padding) + fd->leftMargin + fd->rightMargin;
-    if (!f->parentFrame()) {
-        idealWidth = qMax(maxChildFrameWidth, layoutStruct.contentsWidth).toReal();
-        idealWidth += marginWidth.toReal();
-    }
-
-    QFixed actualWidth = qMax(newContentsWidth, qMax(maxChildFrameWidth, layoutStruct.contentsWidth));
-    fd->contentsWidth = actualWidth;
-    if (newContentsWidth <= 0) { // nowrap layout?
-        fd->contentsWidth = newContentsWidth;
-    }
-
-    fd->minimumWidth = layoutStruct.minimumWidth;
-    fd->maximumWidth = layoutStruct.maximumWidth;
-
-    fd->size.height = fd->contentsHeight == -1
-                 ? layoutStruct.y + fd->border + fd->padding + fd->bottomMargin
-                 : fd->contentsHeight + 2*(fd->border + fd->padding) + fd->topMargin + fd->bottomMargin;
-    fd->size.width = actualWidth + marginWidth;
-    fd->sizeDirty = false;
-    if (layoutStruct.updateRectForFloats.isValid())
-        layoutStruct.updateRect |= layoutStruct.updateRectForFloats;
-    return layoutStruct.updateRect;
-}
-
-void TextDocumentLayoutPrivate::layoutFlow(QTextFrameIterator it, TextLayoutStruct *layoutStruct,
-                                            int layoutFrom, int layoutTo, QFixed width)
-{
-    LDEBUG << "layoutFlow from=" << layoutFrom << "to=" << layoutTo;
-    TextFrameData *fd = data(layoutStruct->frame);
-
-    fd->currentLayoutStruct = layoutStruct;
-
-    QTextFrameIterator previousIt;
-
-    const bool inRootFrame = (it.parentFrame() == document->rootFrame());
-    if (inRootFrame) {
-        bool redoCheckPoints = layoutStruct->fullLayout || checkPoints.isEmpty();
-
-        if (!redoCheckPoints) {
-            QVector<CheckPoint>::Iterator checkPoint = std::lower_bound(checkPoints.begin(), checkPoints.end(), layoutFrom);
-            if (checkPoint != checkPoints.end()) {
-                if (checkPoint != checkPoints.begin())
-                    --checkPoint;
-
-                layoutStruct->y = checkPoint->y;
-                layoutStruct->frameY = checkPoint->frameY;
-                layoutStruct->minimumWidth = checkPoint->minimumWidth;
-                layoutStruct->maximumWidth = checkPoint->maximumWidth;
-                layoutStruct->contentsWidth = checkPoint->contentsWidth;
-
-                if (layoutStruct->pageHeight > 0) {
-                    int page = layoutStruct->currentPage();
-                    layoutStruct->pageBottom = (page + 1) * layoutStruct->pageHeight - layoutStruct->pageBottomMargin;
-                }
-
-                it = frameIteratorForTextPosition(checkPoint->positionInFrame);
-                checkPoints.resize(checkPoint - checkPoints.begin() + 1);
-
-                if (checkPoint != checkPoints.begin()) {
-                    previousIt = it;
-                    --previousIt;
-                }
-            } else {
-                redoCheckPoints = true;
-            }
-        }
-
-        if (redoCheckPoints) {
-            checkPoints.clear();
-            CheckPoint cp;
-            cp.y = layoutStruct->y;
-            cp.frameY = layoutStruct->frameY;
-            cp.positionInFrame = 0;
-            cp.minimumWidth = layoutStruct->minimumWidth;
-            cp.maximumWidth = layoutStruct->maximumWidth;
-            cp.contentsWidth = layoutStruct->contentsWidth;
-            checkPoints.append(cp);
-        }
-    }
-
-    QTextBlockFormat previousBlockFormat = previousIt.currentBlock().blockFormat();
-
-    QFixed maximumBlockWidth = 0;
-    while (!it.atEnd()) {
-        QTextFrame *c = it.currentFrame();
-
-        int docPos;
-        if (it.currentFrame())
-            docPos = it.currentFrame()->firstPosition();
-        else
-            docPos = it.currentBlock().position();
-
-        if (inRootFrame) {
-            if (qAbs(layoutStruct->y - checkPoints.constLast().y) > 2000) {
-                QFixed left, right;
-                floatMargins(layoutStruct->y, layoutStruct, &left, &right);
-                if (left == layoutStruct->x_left && right == layoutStruct->x_right) {
-                    CheckPoint p;
-                    p.y = layoutStruct->y;
-                    p.frameY = layoutStruct->frameY;
-                    p.positionInFrame = docPos;
-                    p.minimumWidth = layoutStruct->minimumWidth;
-                    p.maximumWidth = layoutStruct->maximumWidth;
-                    p.contentsWidth = layoutStruct->contentsWidth;
-                    checkPoints.append(p);
-
-                    if (currentLazyLayoutPosition != -1
-                        && docPos > currentLazyLayoutPosition + lazyLayoutStepSize)
-                        break;
-
-                }
-            }
-        }
-
-        if (c) {
-            // position child frame
-            TextFrameData *cd = data(c);
-
-            QTextFrameFormat fformat = c->frameFormat();
-
-            if (fformat.position() == QTextFrameFormat::InFlow) {
-                if (fformat.pageBreakPolicy() & QTextFormat::PageBreak_AlwaysBefore)
-                    layoutStruct->newPage();
-
-                QFixed left, right;
-                floatMargins(layoutStruct->y, layoutStruct, &left, &right);
-                left = qMax(left, layoutStruct->x_left);
-                right = qMin(right, layoutStruct->x_right);
-
-                if (right - left < cd->size.width) {
-                    layoutStruct->y = findY(layoutStruct->y, layoutStruct, cd->size.width);
-                    floatMargins(layoutStruct->y, layoutStruct, &left, &right);
-                }
-
-                QFixedPoint pos(left, layoutStruct->y);
-
-                Qt::Alignment align = Qt::AlignLeft;
-
-                // detect whether we have any alignment in the document that disallows optimizations,
-                // such as not laying out the document again in a textedit with wrapping disabled.
-                if (inRootFrame && !(align & Qt::AlignLeft))
-                    contentHasAlignment = true;
-
-                cd->position = pos;
-
-                if (document->pageSize().height() > 0.0f)
-                    cd->sizeDirty = true;
-
-                if (cd->sizeDirty) {
-                    if (width != 0)
-                        layoutFrame(c, layoutFrom, layoutTo, width, -1, layoutStruct->frameY);
-                    else
-                        layoutFrame(c, layoutFrom, layoutTo, layoutStruct->frameY);
-
-                    QFixed absoluteChildPos = pos.y + firstChildPos(c);
-                    absoluteChildPos += layoutStruct->frameY;
-
-                    // drop entire frame to next page if first child of frame is on next page
-                    if (absoluteChildPos > layoutStruct->pageBottom) {
-                        layoutStruct->newPage();
-                        pos.y = layoutStruct->y;
-
-                        cd->position = pos;
-                        cd->sizeDirty = true;
-
-                        if (width != 0)
-                            layoutFrame(c, layoutFrom, layoutTo, width, -1, layoutStruct->frameY);
-                        else
-                            layoutFrame(c, layoutFrom, layoutTo, layoutStruct->frameY);
-                    }
-                }
-
-                // align only if there is space for alignment
-                if (right - left > cd->size.width) {
-                    if (align & Qt::AlignRight)
-                        pos.x += layoutStruct->x_right - cd->size.width;
-                    else if (align & Qt::AlignHCenter)
-                        pos.x += (layoutStruct->x_right - cd->size.width) / 2;
-                }
-
-                cd->position = pos;
-
-                layoutStruct->y += cd->size.height;
-                const int page = layoutStruct->currentPage();
-                layoutStruct->pageBottom = (page + 1) * layoutStruct->pageHeight - layoutStruct->pageBottomMargin;
-
-                cd->layoutDirty = false;
-
-                if (c->frameFormat().pageBreakPolicy() & QTextFormat::PageBreak_AlwaysAfter)
-                    layoutStruct->newPage();
-            } else {
-                QRectF oldFrameRect(cd->position.toPointF(), cd->size.toSizeF());
-                QRectF updateRect;
-
-                if (cd->sizeDirty)
-                    updateRect = layoutFrame(c, layoutFrom, layoutTo);
-
-                positionFloat(c);
-
-                // If the size was made dirty when the position was set, layout again
-                if (cd->sizeDirty)
-                    updateRect = layoutFrame(c, layoutFrom, layoutTo);
-
-                QRectF frameRect(cd->position.toPointF(), cd->size.toSizeF());
-
-                if (frameRect == oldFrameRect && updateRect.isValid())
-                    updateRect.translate(cd->position.toPointF());
-                else
-                    updateRect = frameRect;
-
-                layoutStruct->addUpdateRectForFloat(updateRect);
-                if (oldFrameRect.isValid())
-                    layoutStruct->addUpdateRectForFloat(oldFrameRect);
-            }
-
-            layoutStruct->minimumWidth = qMax(layoutStruct->minimumWidth, cd->minimumWidth);
-            layoutStruct->maximumWidth = qMin(layoutStruct->maximumWidth, cd->maximumWidth);
-
-            previousIt = it;
-            ++it;
-        } else {
-            QTextFrameIterator lastIt;
-            if (!previousIt.atEnd() && previousIt != it)
-                lastIt = previousIt;
-            previousIt = it;
-            QTextBlock block = it.currentBlock();
-            ++it;
-
-            const QTextBlockFormat blockFormat = block.blockFormat();
-
-            if (blockFormat.pageBreakPolicy() & QTextFormat::PageBreak_AlwaysBefore)
-                layoutStruct->newPage();
-
-            const QFixed origY = layoutStruct->y;
-            const QFixed origPageBottom = layoutStruct->pageBottom;
-            const QFixed origMaximumWidth = layoutStruct->maximumWidth;
-            layoutStruct->maximumWidth = 0;
-
-            const QTextBlockFormat *previousBlockFormatPtr = 0;
-            if (lastIt.currentBlock().isValid())
-                previousBlockFormatPtr = &previousBlockFormat;
-
-            // layout and position child block
-            layoutBlock(block, docPos, blockFormat, layoutStruct, layoutFrom, layoutTo, previousBlockFormatPtr);
-
-            // detect whether we have any alignment in the document that disallows optimizations,
-            // such as not laying out the document again in a textedit with wrapping disabled.
-            if (inRootFrame && !(block.layout()->textOption().alignment() & Qt::AlignLeft))
-                contentHasAlignment = true;
-
-            if (blockFormat.pageBreakPolicy() & QTextFormat::PageBreak_AlwaysAfter)
-                layoutStruct->newPage();
-
-
-            maximumBlockWidth = qMax(maximumBlockWidth, layoutStruct->maximumWidth);
-            layoutStruct->maximumWidth = origMaximumWidth;
-            previousBlockFormat = blockFormat;
-        }
-    }
-    if (layoutStruct->maximumWidth == QFIXED_MAX && maximumBlockWidth > 0)
-        layoutStruct->maximumWidth = maximumBlockWidth;
-    else
-        layoutStruct->maximumWidth = qMax(layoutStruct->maximumWidth, maximumBlockWidth);
-
-    if (inRootFrame) {
-        // we assume that any float is aligned in a way that disallows the optimizations that rely
-        // on unaligned content.
-        if (!fd->floats.isEmpty())
-            contentHasAlignment = true;
-
-        if (it.atEnd()) {
-            currentLazyLayoutPosition = -1;
-            CheckPoint cp;
-            cp.y = layoutStruct->y;
-            cp.positionInFrame = docPrivate->length();
-            cp.minimumWidth = layoutStruct->minimumWidth;
-            cp.maximumWidth = layoutStruct->maximumWidth;
-            cp.contentsWidth = layoutStruct->contentsWidth;
-            checkPoints.append(cp);
-            checkPoints.reserve(checkPoints.size());
-        } else {
-            currentLazyLayoutPosition = checkPoints.constLast().positionInFrame;
-            // #######
-            //checkPoints.last().positionInFrame = q->document()->docHandle()->length();
-        }
-    }
-
-
-    fd->currentLayoutStruct = 0;
-}
-
-static inline void getLineHeightParams(const QTextBlockFormat &blockFormat, const QTextLine &line, qreal scaling,
-                                       QFixed *lineAdjustment, QFixed *lineBreakHeight, QFixed *lineHeight)
-{
-    *lineHeight = QFixed::fromReal(blockFormat.lineHeight(line.height(), scaling));
-
-    if (blockFormat.lineHeightType() == QTextBlockFormat::FixedHeight || blockFormat.lineHeightType() == QTextBlockFormat::MinimumHeight) {
-        *lineBreakHeight = *lineHeight;
-        if (blockFormat.lineHeightType() == QTextBlockFormat::FixedHeight)
-            *lineAdjustment = QFixed::fromReal(line.ascent() + qMax(line.leading(), qreal(0.0))) - ((*lineHeight * 4) / 5);
-        else
-            *lineAdjustment = QFixed::fromReal(line.height()) - *lineHeight;
-    }
-    else {
-        *lineBreakHeight = QFixed::fromReal(line.height());
-        *lineAdjustment = 0;
-    }
-}
-
-void TextDocumentLayoutPrivate::layoutBlock(const QTextBlock &bl, int blockPosition, const QTextBlockFormat &blockFormat,
-                                             TextLayoutStruct *layoutStruct, int layoutFrom, int layoutTo, const QTextBlockFormat *previousBlockFormat)
-{
-    Q_Q(TextDocumentLayout);
-    if (!bl.isVisible())
-        return;
-
-    QTextLayout *tl = bl.layout();
-    const int blockLength = bl.length();
-
-    LDEBUG << "layoutBlock from=" << layoutFrom << "to=" << layoutTo;
-
-
-    if (previousBlockFormat) {
-        qreal margin = qMax(blockFormat.topMargin(), previousBlockFormat->bottomMargin());
-        if (margin > 0 && q->paintDevice()) {
-            margin *= qreal(q->paintDevice()->logicalDpiY()) / qreal(qt_defaultDpi());
-        }
-        layoutStruct->y += QFixed::fromReal(margin);
-    }
-
-    //TextFrameData *fd = data(layoutStruct->frame);
-
-    Qt::LayoutDirection dir = bl.textDirection();
-
-    QFixed extraMargin;
-    if (docPrivate->defaultTextOption.flags() & QTextOption::AddSpaceForLineAndParagraphSeparators) {
-        QFontMetricsF fm(bl.charFormat().font());
-#if (QT_VERSION > QT_VERSION_CHECK(5,10,0))
-        extraMargin = QFixed::fromReal(fm.horizontalAdvance(QChar(QChar(0x21B5))));
-#else
-        extraMargin = QFixed::fromReal(fm.width(QChar(QChar(0x21B5))));
-#endif
-    }
-
-    const QFixed indent = this->blockIndent(blockFormat);
-    const QFixed totalLeftMargin = QFixed::fromReal(blockFormat.leftMargin()) + (dir == Qt::RightToLeft ? extraMargin : indent);
-    const QFixed totalRightMargin = QFixed::fromReal(blockFormat.rightMargin()) + (dir == Qt::RightToLeft ? indent : extraMargin);
-
-    const QPointF oldPosition = tl->position();
-    tl->setPosition(QPointF(layoutStruct->x_left.toReal(), layoutStruct->y.toReal()));
-
-    if (layoutStruct->fullLayout
-        || (blockPosition + blockLength > layoutFrom && blockPosition <= layoutTo)
-        // force relayout if we cross a page boundary
-        || (layoutStruct->pageHeight != QFIXED_MAX && layoutStruct->absoluteY() + QFixed::fromReal(tl->boundingRect().height()) > layoutStruct->pageBottom)) {
-
-        LDEBUG << " do layout";
-        QTextOption option = docPrivate->defaultTextOption;
-        option.setTextDirection(dir);
-        option.setTabs( blockFormat.tabPositions() );
-
-        Qt::Alignment align = docPrivate->defaultTextOption.alignment();
-        if (blockFormat.hasProperty(QTextFormat::BlockAlignment))
-            align = blockFormat.alignment();
-
-        Qt::Alignment alres = align;
-        if (!(alres & Qt::AlignHorizontal_Mask))
-            alres |= Qt::AlignLeft;
-        if (!(alres & Qt::AlignAbsolute) && (alres & (Qt::AlignLeft | Qt::AlignRight))) {
-            if (dir == Qt::RightToLeft)
-                alres ^= (Qt::AlignLeft | Qt::AlignRight);
-            alres |= Qt::AlignAbsolute;
-        }
-
-        option.setAlignment(alres); // for paragraph that are RTL, alignment is auto-reversed;
-
-        if (blockFormat.nonBreakableLines() || document->pageSize().width() < 0) {
-            option.setWrapMode(QTextOption::ManualWrap);
-        }
-
-        tl->setTextOption(option);
-
-        const bool haveWordOrAnyWrapMode = (option.wrapMode() == QTextOption::WrapAtWordBoundaryOrAnywhere);
-
-        const QFixed cy = layoutStruct->y;
-        const QFixed l = layoutStruct->x_left  + totalLeftMargin;
-        const QFixed r = layoutStruct->x_right - totalRightMargin;
-
-        tl->beginLayout();
-        bool firstLine = true;
-        while (1) {
-            QTextLine line = tl->createLine();
-            if (!line.isValid())
-                break;
-            line.setLeadingIncluded(true);
-
-            QFixed left, right;
-            floatMargins(layoutStruct->y, layoutStruct, &left, &right);
-            left = qMax(left, l);
-            right = qMin(right, r);
-            QFixed text_indent;
-            if (firstLine) {
-                text_indent = QFixed::fromReal(blockFormat.textIndent());
-                if (dir == Qt::LeftToRight)
-                    left += text_indent;
-                else
-                    right -= text_indent;
-                firstLine = false;
-            }
-
-            if (fixedColumnWidth != -1)
-                line.setNumColumns(fixedColumnWidth, (right - left).toReal());
-            else
-                line.setLineWidth((right - left).toReal());
-
-            floatMargins(layoutStruct->y, layoutStruct, &left, &right);
-            left = qMax(left, l);
-            right = qMin(right, r);
-            if (dir == Qt::LeftToRight)
-                left += text_indent;
-            else
-                right -= text_indent;
-
-            if (fixedColumnWidth == -1 && QFixed::fromReal(line.naturalTextWidth()) > right-left) {
-                // float has been added in the meantime, redo
-                layoutStruct->pendingFloats.clear();
-
-                line.setLineWidth((right-left).toReal());
-                if (QFixed::fromReal(line.naturalTextWidth()) > right-left) {
-                    if (haveWordOrAnyWrapMode) {
-                        option.setWrapMode(QTextOption::WrapAnywhere);
-                        tl->setTextOption(option);
-                    }
-
-                    layoutStruct->pendingFloats.clear();
-                    // lines min width more than what we have
-                    layoutStruct->y = findY(layoutStruct->y, layoutStruct, QFixed::fromReal(line.naturalTextWidth()));
-                    floatMargins(layoutStruct->y, layoutStruct, &left, &right);
-                    left = qMax(left, l);
-                    right = qMin(right, r);
-                    if (dir == Qt::LeftToRight)
-                        left += text_indent;
-                    else
-                        right -= text_indent;
-                    line.setLineWidth(qMax<qreal>(line.naturalTextWidth(), (right-left).toReal()));
-
-                    if (haveWordOrAnyWrapMode) {
-                        option.setWrapMode(QTextOption::WordWrap);
-                        tl->setTextOption(option);
-                    }
-                }
-
-            }
-
-            QFixed lineBreakHeight, lineHeight, lineAdjustment;
-            qreal scaling = (q->paintDevice() && q->paintDevice()->logicalDpiY() != qt_defaultDpi()) ?
-                            qreal(q->paintDevice()->logicalDpiY()) / qreal(qt_defaultDpi()) : 1;
-            getLineHeightParams(blockFormat, line, scaling, &lineAdjustment, &lineBreakHeight, &lineHeight);
-
-            if (layoutStruct->pageHeight > 0 && layoutStruct->absoluteY() + lineBreakHeight > layoutStruct->pageBottom) {
-                layoutStruct->newPage();
-
-                floatMargins(layoutStruct->y, layoutStruct, &left, &right);
-                left = qMax(left, l);
-                right = qMin(right, r);
-                if (dir == Qt::LeftToRight)
-                    left += text_indent;
-                else
-                    right -= text_indent;
-            }
-
-            line.setPosition(QPointF((left - layoutStruct->x_left).toReal(), (layoutStruct->y - cy - lineAdjustment).toReal()));
-            layoutStruct->y += lineHeight;
-            layoutStruct->contentsWidth
-                = qMax<QFixed>(layoutStruct->contentsWidth, QFixed::fromReal(line.x() + line.naturalTextWidth()) + totalRightMargin);
-
-            // position floats
-            for (int i = 0; i < layoutStruct->pendingFloats.size(); ++i) {
-                QTextFrame *f = layoutStruct->pendingFloats.at(i);
-                positionFloat(f);
-            }
-            layoutStruct->pendingFloats.clear();
-        }
-        tl->endLayout();
-    } else {
-        const int cnt = tl->lineCount();
-        for (int i = 0; i < cnt; ++i) {
-            LDEBUG << "going to move text line" << i;
-            QTextLine line = tl->lineAt(i);
-            layoutStruct->contentsWidth
-                = qMax(layoutStruct->contentsWidth, QFixed::fromReal(line.x() + tl->lineAt(i).naturalTextWidth()) + totalRightMargin);
-
-            QFixed lineBreakHeight, lineHeight, lineAdjustment;
-            qreal scaling = (q->paintDevice() && q->paintDevice()->logicalDpiY() != qt_defaultDpi()) ?
-                            qreal(q->paintDevice()->logicalDpiY()) / qreal(qt_defaultDpi()) : 1;
-            getLineHeightParams(blockFormat, line, scaling, &lineAdjustment, &lineBreakHeight, &lineHeight);
-
-            if (layoutStruct->pageHeight != QFIXED_MAX) {
-                if (layoutStruct->absoluteY() + lineBreakHeight > layoutStruct->pageBottom)
-                    layoutStruct->newPage();
-                line.setPosition(QPointF(line.position().x(), (layoutStruct->y - lineAdjustment).toReal() - tl->position().y()));
-            }
-            layoutStruct->y += lineHeight;
-        }
-        if (layoutStruct->updateRect.isValid()
-            && blockLength > 1) {
-            if (layoutFrom >= blockPosition + blockLength) {
-                // if our height didn't change and the change in the document is
-                // in one of the later paragraphs, then we don't need to repaint
-                // this one
-                layoutStruct->updateRect.setTop(qMax(layoutStruct->updateRect.top(), layoutStruct->y.toReal()));
-            } else if (layoutTo < blockPosition) {
-                if (oldPosition == tl->position())
-                    // if the change in the document happened earlier in the document
-                    // and our position did /not/ change because none of the earlier paragraphs
-                    // or frames changed their height, then we don't need to repaint
-                    // this one
-                    layoutStruct->updateRect.setBottom(qMin(layoutStruct->updateRect.bottom(), tl->position().y()));
-                else
-                    layoutStruct->updateRect.setBottom(qreal(INT_MAX)); // reset
-            }
-        }
-    }
-
-    // ### doesn't take floats into account. would need to do it per line. but how to retrieve then? (Simon)
-    const QFixed margins = totalLeftMargin + totalRightMargin;
-    layoutStruct->minimumWidth = qMax(layoutStruct->minimumWidth, QFixed::fromReal(tl->minimumWidth()) + margins);
-
-    const QFixed maxW = QFixed::fromReal(tl->maximumWidth()) + margins;
-
-    if (maxW > 0) {
-        if (layoutStruct->maximumWidth == QFIXED_MAX)
-            layoutStruct->maximumWidth = maxW;
-        else
-            layoutStruct->maximumWidth = qMax(layoutStruct->maximumWidth, maxW);
-    }
-}
-
-void TextDocumentLayoutPrivate::floatMargins(const QFixed &y, const TextLayoutStruct *layoutStruct,
-                                              QFixed *left, QFixed *right) const
-{
-    *left = layoutStruct->x_left;
-    *right = layoutStruct->x_right;
-    TextFrameData *lfd = data(layoutStruct->frame);
-    for (int i = 0; i < lfd->floats.size(); ++i) {
-        TextFrameData *fd = data(lfd->floats.at(i));
-        if (!fd->layoutDirty) {
-            if (fd->position.y <= y && fd->position.y + fd->size.height > y) {
-                if (lfd->floats.at(i)->frameFormat().position() == QTextFrameFormat::FloatLeft)
-                    *left = qMax(*left, fd->position.x + fd->size.width);
-                else
-                    *right = qMin(*right, fd->position.x);
-            }
-        }
-    }
-}
-
-QFixed TextDocumentLayoutPrivate::findY(QFixed yFrom, const TextLayoutStruct *layoutStruct, QFixed requiredWidth) const
-{
-    QFixed right, left;
-    requiredWidth = qMin(requiredWidth, layoutStruct->x_right - layoutStruct->x_left);
-
-    while (1) {
-        floatMargins(yFrom, layoutStruct, &left, &right);
-        if (right-left >= requiredWidth)
-            break;
-
-        // move float down until we find enough space
-        QFixed newY = QFIXED_MAX;
-        TextFrameData *lfd = data(layoutStruct->frame);
-        for (int i = 0; i < lfd->floats.size(); ++i) {
-            TextFrameData *fd = data(lfd->floats.at(i));
-            if (!fd->layoutDirty) {
-                if (fd->position.y <= yFrom && fd->position.y + fd->size.height > yFrom)
-                    newY = qMin(newY, fd->position.y + fd->size.height);
-            }
-        }
-        if (newY == QFIXED_MAX)
-            break;
-        yFrom = newY;
-    }
-    return yFrom;
-}
-
-TextDocumentLayout::TextDocumentLayout(QTextDocument *doc)
-    : QAbstractTextDocumentLayout(*new TextDocumentLayoutPrivate, doc)
-{
-    Q_D(TextDocumentLayout);
-    d->lineManager = new LineManager(this);
-}
-
-
-void TextDocumentLayout::draw(QPainter *painter, const PaintContext &context)
-{
-    Q_D(TextDocumentLayout);
-    QTextFrame *frame = d->document->rootFrame();
-    TextFrameData *fd = data(frame);
-
-    if(fd->sizeDirty)
-        return;
-
-    if (context.clip.isValid()) {
-        d->ensureLayouted(QFixed::fromReal(context.clip.bottom()));
-    } else {
-        d->ensureLayoutFinished();
-    }
-
-    QFixed width = fd->size.width;
-    if (d->document->pageSize().width() == 0 && d->viewportRect.isValid()) {
-        // we're in NoWrap mode, meaning the frame should expand to the viewport
-        // so that backgrounds are drawn correctly
-        fd->size.width = qMax(width, QFixed::fromReal(d->viewportRect.right()));
-    }
-
-    // Make sure we conform to the root frames bounds when drawing.
-    d->clipRect = QRectF(fd->position.toPointF(), fd->size.toSizeF()).adjusted(fd->leftMargin.toReal(), 0, -fd->rightMargin.toReal(), 0);
-    d->drawFrame(QPointF(), painter, context, frame);
-    fd->size.width = width;
-}
-
-void TextDocumentLayout::setViewport(const QRectF &viewport)
-{
-    Q_D(TextDocumentLayout);
-    d->viewportRect = viewport;
-}
-
-static void markFrames(QTextFrame *current, int from, int oldLength, int length)
-{
-    int end = qMax(oldLength, length) + from;
-
-    if (current->firstPosition() >= end || current->lastPosition() < from)
-        return;
-
-    TextFrameData *fd = data(current);
-    // float got removed in editing operation
-    QTextFrame *null = nullptr; // work-around for (at least) MSVC 2012 emitting
-                                // warning C4100 for its own header <algorithm>
-                                // when passing nullptr directly to std::remove
-    fd->floats.erase(std::remove(fd->floats.begin(), fd->floats.end(), null),
-                     fd->floats.end());
-
-    fd->layoutDirty = true;
-    fd->sizeDirty = true;
-
-    QList<QTextFrame *> children = current->childFrames();
-    for (int i = 0; i < children.size(); ++i)
-        markFrames(children.at(i), from, oldLength, length);
-}
-
-void TextDocumentLayout::documentChanged(int from, int oldLength, int length)
-{
-    Q_D(TextDocumentLayout);
-
-    QTextBlock startIt = document()->findBlock(from);
-    QTextBlock endIt = document()->findBlock(qMax(0, from + length - 1));
-    if (endIt.isValid())
-        endIt = endIt.next();
-    for (QTextBlock blockIt = startIt; blockIt.isValid() && blockIt != endIt; blockIt = blockIt.next())
-        blockIt.clearLayout();
-
-    if (d->docPrivate->pageSize.isNull())
-        return;
-
-    QRectF updateRect;
-
-    d->lazyLayoutStepSize = 1000;
-    d->sizeChangedTimer.stop();
-    d->insideDocumentChange = true;
-
-    const int documentLength = d->docPrivate->length();
-    const bool fullLayout = (oldLength == 0 && length == documentLength);
-    const bool smallChange = documentLength > 0
-                             && (qMax(length, oldLength) * 100 / documentLength) < 5;
-
-    // don't show incremental layout progress (avoid scroll bar flicker)
-    // if we see only a small change in the document and we're either starting
-    // a layout run or we're already in progress for that and we haven't seen
-    // any bigger change previously (showLayoutProgress already false)
-    if (smallChange
-        && (d->currentLazyLayoutPosition == -1 || d->showLayoutProgress == false))
-        d->showLayoutProgress = false;
-    else
-        d->showLayoutProgress = true;
-
-    if (fullLayout) {
-        d->contentHasAlignment = false;
-        d->currentLazyLayoutPosition = 0;
-        d->checkPoints.clear();
-        d->layoutStep();
-    } else {
-        d->ensureLayoutedByPosition(from);
-        updateRect = doLayout(from, oldLength, length);
-    }
-
-    if (!d->layoutTimer.isActive() && d->currentLazyLayoutPosition != -1)
-        d->layoutTimer.start(10, this);
-
-    d->insideDocumentChange = false;
-
-    for (QTextBlock blockIt = startIt; blockIt.isValid() && blockIt != endIt; blockIt = blockIt.next())
-        emit updateBlock(blockIt);
-
-    if (d->showLayoutProgress) {
-        const QSizeF newSize = dynamicDocumentSize();
-        if (newSize != d->lastReportedSize) {
-            d->lastReportedSize = newSize;
-            emit documentSizeChanged(newSize);
-        }
-    }
-
-    if (!updateRect.isValid()) {
-        // don't use the frame size, it might have shrunken
-        updateRect = QRectF(QPointF(0, 0), QSizeF(qreal(INT_MAX), qreal(INT_MAX)));
-    }
-
-    emit update(updateRect);
-}
-
-QRectF TextDocumentLayout::doLayout(int from, int oldLength, int length)
-{
-    Q_D(TextDocumentLayout);
-
-
-    // mark all frames between f_start and f_end as dirty
-    markFrames(d->document->rootFrame(), from, oldLength, length);
-
-    QRectF updateRect;
-
-    QTextFrame *root = d->document->rootFrame();
-    if(data(root)->sizeDirty)
-        updateRect = d->layoutFrame(root, from, from + length);
-    data(root)->layoutDirty = false;
-
-    if (d->currentLazyLayoutPosition == -1)
-        layoutFinished();
-    else if (d->showLayoutProgress)
-        d->sizeChangedTimer.start(0, this);
-
-    return updateRect;
-}
-
-int TextDocumentLayout::hitTest(const QPointF &point, Qt::HitTestAccuracy accuracy) const
-{
-    Q_D(const TextDocumentLayout);
-    d->ensureLayouted(QFixed::fromReal(point.y()));
-    QTextFrame *f = d->document->rootFrame();
-    int position = 0;
-    QTextLayout *l = 0;
-    QFixedPoint pointf;
-    pointf.x = QFixed::fromReal(point.x());
-    pointf.y = QFixed::fromReal(point.y());
-    TextDocumentLayoutPrivate::HitPoint p = d->hitTest(f, pointf, &position, &l, accuracy);
-    if (accuracy == Qt::ExactHit && p < TextDocumentLayoutPrivate::PointExact)
-        return -1;
-
-    // ensure we stay within document bounds
-    int lastPos = f->lastPosition();
-    if (l && !l->preeditAreaText().isEmpty())
-        lastPos += l->preeditAreaText().length();
-    if (position > lastPos)
-        position = lastPos;
-    else if (position < 0)
-        position = 0;
-
-    return position;
-}
-
-void TextDocumentLayout::resizeInlineObject(QTextInlineObject item, int posInDocument, const QTextFormat &format)
-{
-    Q_D(TextDocumentLayout);
-    QTextCharFormat f = format.toCharFormat();
-    Q_ASSERT(f.isValid());
-    QTextObjectHandler handler = d->handlers.value(f.objectType());
-    if (!handler.component)
-        return;
-
-    QSizeF intrinsic = handler.iface->intrinsicSize(d->document, posInDocument, format);
-
-    QTextFrameFormat::Position pos = QTextFrameFormat::InFlow;
-    QTextFrame *frame = qobject_cast<QTextFrame *>(d->document->objectForFormat(f));
-    if (frame) {
-        pos = frame->frameFormat().position();
-        TextFrameData *fd = data(frame);
-        fd->sizeDirty = false;
-        fd->size = QFixedSize::fromSizeF(intrinsic);
-        fd->minimumWidth = fd->maximumWidth = fd->size.width;
-    }
-
-    QSizeF inlineSize = (pos == QTextFrameFormat::InFlow ? intrinsic : QSizeF(0, 0));
-    item.setWidth(inlineSize.width());
-
-    QFontMetrics m(f.font());
-    switch (f.verticalAlignment())
-    {
-    case QTextCharFormat::AlignMiddle:
-        item.setDescent(inlineSize.height() / 2);
-        item.setAscent(inlineSize.height() / 2);
-        break;
-    case QTextCharFormat::AlignBaseline:
-        item.setDescent(m.descent());
-        item.setAscent(inlineSize.height() - m.descent());
-        break;
-    default:
-        item.setDescent(0);
-        item.setAscent(inlineSize.height());
-    }
-}
-
-void TextDocumentLayout::positionInlineObject(QTextInlineObject item, int posInDocument, const QTextFormat &format)
-{
-    Q_D(TextDocumentLayout);
-    Q_UNUSED(posInDocument);
-    if (item.width() != 0)
-        // inline
-        return;
-
-    QTextCharFormat f = format.toCharFormat();
-    Q_ASSERT(f.isValid());
-    QTextObjectHandler handler = d->handlers.value(f.objectType());
-    if (!handler.component)
-        return;
-
-    QTextFrame *frame = qobject_cast<QTextFrame *>(d->document->objectForFormat(f));
-    if (!frame)
-        return;
-
-    QTextBlock b = d->document->findBlock(frame->firstPosition());
-    QTextLine line;
-    if (b.position() <= frame->firstPosition() && b.position() + b.length() > frame->lastPosition())
-        line = b.layout()->lineAt(b.layout()->lineCount()-1);
-
-    d->positionFloat(frame, line.isValid() ? &line : 0);
-}
-
-void TextDocumentLayout::drawInlineObject(QPainter *p, const QRectF &rect, QTextInlineObject item,
-                                           int posInDocument, const QTextFormat &format)
-{
-    Q_D(TextDocumentLayout);
-    QTextCharFormat f = format.toCharFormat();
-    Q_ASSERT(f.isValid());
-    QTextFrame *frame = qobject_cast<QTextFrame *>(d->document->objectForFormat(f));
-    if (frame && frame->frameFormat().position() != QTextFrameFormat::InFlow)
-        return; // don't draw floating frames from inline objects here but in drawFlow instead
-
-    QAbstractTextDocumentLayout::drawInlineObject(p, rect, item, posInDocument, format);
-}
-
-int TextDocumentLayout::dynamicPageCount() const
-{
-    Q_D(const TextDocumentLayout);
-    const QSizeF pgSize = d->document->pageSize();
-    if (pgSize.height() < 0)
-        return 1;
-    return qCeil(dynamicDocumentSize().height() / pgSize.height());
-}
-
-QSizeF TextDocumentLayout::dynamicDocumentSize() const
-{
-    Q_D(const TextDocumentLayout);
-    return data(d->document->rootFrame())->size.toSizeF();
-}
-
-int TextDocumentLayout::pageCount() const
-{
-    Q_D(const TextDocumentLayout);
-    d->ensureLayoutFinished();
-    return dynamicPageCount();
-}
-
-QSizeF TextDocumentLayout::documentSize() const
-{
-    Q_D(const TextDocumentLayout);
-    d->ensureLayoutFinished();
-    return dynamicDocumentSize();
-}
-
-void TextDocumentLayoutPrivate::ensureLayouted(QFixed y) const
-{
-    Q_Q(const TextDocumentLayout);
-    if (currentLazyLayoutPosition == -1)
-        return;
-    const QSizeF oldSize = q->dynamicDocumentSize();
-    Q_UNUSED(oldSize);
-
-    if (checkPoints.isEmpty())
-        layoutStep();
-
-    while (currentLazyLayoutPosition != -1
-           && checkPoints.last().y < y)
-        layoutStep();
-}
-
-void TextDocumentLayoutPrivate::ensureLayoutedByPosition(int position) const
-{
-    if (currentLazyLayoutPosition == -1)
-        return;
-    if (position < currentLazyLayoutPosition)
-        return;
-    while (currentLazyLayoutPosition != -1
-           && currentLazyLayoutPosition < position) {
-        const_cast<TextDocumentLayout *>(q_func())->doLayout(currentLazyLayoutPosition, 0, INT_MAX - currentLazyLayoutPosition);
-    }
-}
-
-void TextDocumentLayoutPrivate::layoutStep() const
-{
-    ensureLayoutedByPosition(currentLazyLayoutPosition + lazyLayoutStepSize);
-    lazyLayoutStepSize = qMin(200000, lazyLayoutStepSize * 2);
-}
-
-void TextDocumentLayout::setCursorWidth(int width)
-{
-    Q_D(TextDocumentLayout);
-    d->cursorWidth = width;
-}
-
-int TextDocumentLayout::cursorWidth() const
-{
-    Q_D(const TextDocumentLayout);
-    return d->cursorWidth;
-}
-
-void TextDocumentLayout::setFixedColumnWidth(int width)
-{
-    Q_D(TextDocumentLayout);
-    d->fixedColumnWidth = width;
-}
-
-QRectF TextDocumentLayout::frameBoundingRect(QTextFrame *frame) const
-{
-    Q_D(const TextDocumentLayout);
-    if (d->docPrivate->pageSize.isNull())
-        return QRectF();
-    d->ensureLayoutFinished();
-    return d->frameBoundingRectInternal(frame);
-}
-
-QRectF TextDocumentLayoutPrivate::frameBoundingRectInternal(QTextFrame *frame) const
-{
-    QPointF pos;
-    const int framePos = frame->firstPosition();
-    QTextFrame *f = frame;
-    while (f) {
-        TextFrameData *fd = data(f);
-        pos += fd->position.toPointF();
-
-        f = f->parentFrame();
-    }
-    return QRectF(pos, data(frame)->size.toSizeF());
-}
-
-QRectF TextDocumentLayout::blockBoundingRect(const QTextBlock &block) const
-{
-    Q_D(const TextDocumentLayout);
-    if (d->docPrivate->pageSize.isNull() || !block.isValid() || !block.isVisible())
-        return QRectF();
-    d->ensureLayoutedByPosition(block.position() + block.length());
-    QTextFrame *frame = d->document->frameAt(block.position());
-    QPointF offset;
-
-    while (frame) {
-        TextFrameData *fd = data(frame);
-        offset += fd->position.toPointF();
-
-        frame = frame->parentFrame();
-    }
-
-    const QTextLayout *layout = block.layout();
-    QRectF rect = layout->boundingRect();
-    rect.moveTopLeft(layout->position() + offset);
-    return rect;
-}
-
-int TextDocumentLayout::layoutStatus() const
-{
-    Q_D(const TextDocumentLayout);
-    int pos = d->currentLazyLayoutPosition;
-    if (pos == -1)
-        return 100;
-    return pos * 100 / d->document->docHandle()->length();
-}
-
-void TextDocumentLayout::timerEvent(QTimerEvent *e)
-{
-    Q_D(TextDocumentLayout);
-    if (e->timerId() == d->layoutTimer.timerId()) {
-        if (d->currentLazyLayoutPosition != -1)
-            d->layoutStep();
-    } else if (e->timerId() == d->sizeChangedTimer.timerId()) {
-        d->lastReportedSize = dynamicDocumentSize();
-        emit documentSizeChanged(d->lastReportedSize);
-        d->sizeChangedTimer.stop();
-
-        if (d->currentLazyLayoutPosition == -1) {
-            const int newCount = dynamicPageCount();
-            if (newCount != d->lastPageCount) {
-                d->lastPageCount = newCount;
-                emit pageCountChanged(newCount);
-            }
-        }
-    } else {
-        QAbstractTextDocumentLayout::timerEvent(e);
-    }
-}
-
-void TextDocumentLayout::layoutFinished()
-{
-    Q_D(TextDocumentLayout);
-    d->layoutTimer.stop();
-    if (!d->insideDocumentChange)
-        d->sizeChangedTimer.start(0, this);
-    // reset
-    d->showLayoutProgress = true;
-}
-
-void TextDocumentLayout::ensureLayouted(qreal y)
-{
-    d_func()->ensureLayouted(QFixed::fromReal(y));
-}
-
-qreal TextDocumentLayout::idealWidth() const
-{
-    Q_D(const TextDocumentLayout);
-    d->ensureLayoutFinished();
-    return d->idealWidth;
-}
-
-bool TextDocumentLayout::contentHasAlignment() const
-{
-    Q_D(const TextDocumentLayout);
-    return d->contentHasAlignment;
-}
-
-LineManager *TextDocumentLayout::getLineManager()
-{
-    Q_D(TextDocumentLayout);
-    return d->lineManager;
-}
-
-void TextDocumentLayout::stateChangeUpdate(int pos)
-{
-    Q_D(TextDocumentLayout);
-    d->lineManager->setDirtyPos(pos);
-    d->lineManager->textDocumentFinishedUpdating(this->document()->blockCount());
-}
-
-QTextDocument *TextDocumentLayout::lineDocument()
-{
-    Q_D(TextDocumentLayout);
-    return d->lineManager->m_lineDocument;
-}
-
-void TextDocumentLayout::collapseLines(int pos, int len)
-{
-    Q_D(TextDocumentLayout);
-    d->lineManager->collapseLines(pos,len);
-    emit linesCollapsed(pos, len);
-}
-
-void TextDocumentLayout::expandLines(int pos, int len)
-{
-    Q_D(TextDocumentLayout);
-    d->lineManager->expandLines(pos, len);
-    emit linesExpanded(pos, len);
-}
-
-std::pair<int,int> TextDocumentLayout::isFirstLineOfCollapsedSection(int lineNumber)
-{
-    Q_D(TextDocumentLayout);
-    return d->lineManager->isFirstLineOfCollapsedSection(lineNumber);
-}
-
-std::pair<int,int> TextDocumentLayout::isLineAfterCollapsedSection(int lineNumber)
-{
-    Q_D(TextDocumentLayout);
-    return d->lineManager->isLineAfterCollapsedSection(lineNumber);
-}
-
-QTextDocument *TextDocumentLayout::lineManagerParentDocument()
-{
-    Q_D(TextDocumentLayout);
-    return d->lineManager->m_parentDocument;
-}
-
-void TextDocumentLayout::setLineManagerParentDocument(QTextDocument *doc)
-{
-    Q_D(TextDocumentLayout);
-    d->lineManager->m_parentDocument = doc;
-}
-
-void TextDocumentLayout::setLineDocumentFont(const QFont& font)
-{
-    Q_D(TextDocumentLayout);
-    d->lineManager->setLineDocumentFont(font);
-}
-
-void TextDocumentLayout::setDirtyPos(int pos)
-{
-    Q_D(TextDocumentLayout);
-    d->lineManager->setDirtyPos(pos);
-}
-
-void TextDocumentLayout::textDocumentFinishedUpdating(int newLineNumber)
-{
-    Q_D(TextDocumentLayout);
-    d->lineManager->textDocumentFinishedUpdating(newLineNumber);
-}
-
-void TextDocumentLayout::updateLineSurface(int oldLineNum, int newLineNum, int dirtyPos)
-{
-    emit updateLineSurfaceSignal(oldLineNum, newLineNum, dirtyPos);
-}
-
-qreal TextDocumentLayoutPrivate::scaleToDevice(qreal value) const
-{
-    if (!paintDevice)
-        return value;
-    return value * paintDevice->logicalDpiY() / qreal(qt_defaultDpi());
-}
-
-QFixed TextDocumentLayoutPrivate::scaleToDevice(QFixed value) const
-{
-    if (!paintDevice)
-        return value;
-    return value * QFixed(paintDevice->logicalDpiY()) / QFixed(qt_defaultDpi());
-}
-
-}
-
-#include "moc_textdocumentlayout.cpp"
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "textdocumentlayout.h"
+#include "qtextlist.h"
+#include "private/qtextengine_p.h"
+#include "private/qabstracttextdocumentlayout_p.h"
+
+#include <qpainter.h>
+#include <qmath.h>
+#include <qrect.h>
+#include <qpalette.h>
+#include <qdebug.h>
+#include <qvarlengtharray.h>
+#include <limits.h>
+#include <qbasictimer.h>
+#include <algorithm>
+
+#ifdef LAYOUT_DEBUG
+#define LDEBUG qDebug()
+#define INC_INDENT debug_indent += "  "
+#define DEC_INDENT debug_indent = debug_indent.left(debug_indent.length()-2)
+#else
+#define LDEBUG if(0) qDebug()
+#define INC_INDENT do {} while(0)
+#define DEC_INDENT do {} while(0)
+#endif
+
+
+
+class QTextFrameIterator {
+    QTextFrame *f;
+    int b;
+    int e;
+    QTextFrame *cf;
+    int cb;
+
+    friend class QTextFrame;
+    friend class lv::TextDocumentLayoutPrivate;
+    QTextFrameIterator(QTextFrame *frame, int block, int begin, int end)
+    {
+        f = frame;
+        b = begin;
+        e = end;
+        cf = nullptr;
+        cb = block;
+    }
+public:
+    static QTextFrameIterator findFrameBeginning(const QTextFrame *frame);
+    QTextFrameIterator(){
+        f = nullptr;
+        b = 0;
+        e = 0;
+        cf = nullptr;
+        cb = 0;
+    }
+#if QT_VERSION < QT_VERSION_CHECK(6,0,0)
+    QTextFrameIterator(const QTextFrameIterator &other) Q_DECL_NOTHROW
+    {
+        f = other.f;
+        b = other.b;
+        e = other.e;
+        cf = other.cf;
+        cb = other.cb;
+    } // = default
+    QTextFrameIterator &operator=(const QTextFrameIterator &other) Q_DECL_NOTHROW
+    {
+        f = other.f;
+        b = other.b;
+        e = other.e;
+        cf = other.cf;
+        cb = other.cb;
+        return *this;
+    } // = default
+    QTextFrameIterator(QTextFrameIterator &&other) Q_DECL_NOTHROW // = default
+    { memcpy(static_cast<void *>(this), static_cast<void *>(&other), sizeof(QTextFrameIterator)); }
+    QTextFrameIterator &operator=(QTextFrameIterator &&other) Q_DECL_NOTHROW // = default
+    { memcpy(static_cast<void *>(this), static_cast<void *>(&other), sizeof(QTextFrameIterator)); return *this; }
+#endif
+
+    QTextFrame *parentFrame() const { return f; }
+
+    QTextFrame *currentFrame() const
+    {
+        return cf;
+    }
+    QTextBlock currentBlock() const
+    {
+        if (!f)
+            return QTextBlock();
+        return QTextBlock(f->docHandle(), cb);
+    }
+
+    bool atEnd() const { return !cf && cb == e; }
+
+    inline bool operator==(const QTextFrameIterator &o) const { return f == o.f && cf == o.cf && cb == o.cb; }
+    inline bool operator!=(const QTextFrameIterator &o) const { return f != o.f || cf != o.cf || cb != o.cb; }
+    QTextFrameIterator &operator++()
+    {
+        const QTextDocumentPrivate *priv = f->docHandle();
+        QTextDocument* document = f->document();
+        const QTextDocumentPrivate::BlockMap &map = priv->blockMap();
+        if (cf) {
+            int end = cf->lastPosition() + 1;
+            cb = map.findNode(end);
+            cf = 0;
+        } else if (cb) {
+            cb = map.next(cb);
+            if (cb == e)
+                return *this;
+
+            if (!f->childFrames().isEmpty()) {
+                int pos = map.position(cb);
+                // check if we entered a frame
+                QTextDocumentPrivate::FragmentIterator frag = priv->find(pos-1);
+                if (priv->buffer().at(frag->stringPosition) != QChar::ParagraphSeparator) {
+
+                    auto formats = priv->formatCollection();
+                    int objectIndex = formats->format(frag->format).objectIndex();
+
+                    QTextFrame *nf = qobject_cast<QTextFrame *>(document->object(objectIndex));
+                    if (nf) {
+                        if (priv->buffer().at(frag->stringPosition) == QTextBeginningOfFrame && nf != f) {
+                            cf = nf;
+                            cb = 0;
+                        } else {
+                            Q_ASSERT(priv->buffer().at(frag->stringPosition) != QTextEndOfFrame);
+                        }
+                    }
+                }
+            }
+        }
+        return *this;
+    }
+    inline QTextFrameIterator operator++(int) { QTextFrameIterator tmp = *this; operator++(); return tmp; }
+    QTextFrameIterator &operator--()
+    {
+        const QTextDocumentPrivate *priv = f->docHandle();
+        QTextDocument* document = f->document();
+        const QTextDocumentPrivate::BlockMap &map = priv->blockMap();
+        if (cf) {
+            int start = cf->firstPosition() - 1;
+            cb = map.findNode(start);
+            cf = 0;
+        } else {
+            if (cb == b)
+                goto end;
+            if (cb != e) {
+                int pos = map.position(cb);
+                // check if we have to enter a frame
+                QTextDocumentPrivate::FragmentIterator frag = priv->find(pos-1);
+                if (priv->buffer().at(frag->stringPosition) != QChar::ParagraphSeparator) {
+
+                    auto formats = priv->formatCollection();
+                    int objectIndex = formats->format(frag->format).objectIndex();
+
+                    QTextFrame *pf = qobject_cast<QTextFrame *>(document->object(objectIndex));
+
+                    if (pf) {
+                        if (priv->buffer().at(frag->stringPosition) == QTextBeginningOfFrame) {
+                            Q_ASSERT(pf == f);
+                        } else if (priv->buffer().at(frag->stringPosition) == QTextEndOfFrame) {
+                            Q_ASSERT(pf != f);
+                            cf = pf;
+                            cb = 0;
+                            goto end;
+                        }
+                    }
+                }
+            }
+            cb = map.previous(cb);
+        }
+     end:
+        return *this;
+    }
+    inline QTextFrameIterator operator--(int) { QTextFrameIterator tmp = *this; operator--(); return tmp; }
+};
+
+inline QTextFrameIterator QTextFrameIterator::findFrameBeginning(const QTextFrame *frame)
+{
+    const QTextDocumentPrivate *priv = frame->docHandle();
+    int b = priv->blockMap().findNode(frame->firstPosition());
+    int e = priv->blockMap().findNode(frame->lastPosition()+1);
+    return QTextFrameIterator(const_cast<QTextFrame *>(frame), b, b, e);
+}
+
+Q_DECLARE_TYPEINFO(QTextFrameIterator, Q_MOVABLE_TYPE);
+
+// ################ should probably add frameFormatChange notification!
+
+struct TextLayoutStruct;
+
+class TextFrameData : public QTextFrameLayoutData
+{
+public:
+    TextFrameData();
+
+    // relative to parent frame
+    QFixedPoint position;
+    QFixedSize size;
+
+    // contents starts at (margin+border/margin+border)
+    QFixed topMargin;
+    QFixed bottomMargin;
+    QFixed leftMargin;
+    QFixed rightMargin;
+    QFixed border;
+    QFixed padding;
+    QFixed contentsWidth;
+    QFixed contentsHeight;
+    QFixed oldContentsWidth;
+
+    // accumulated margins
+    QFixed effectiveTopMargin;
+    QFixed effectiveBottomMargin;
+
+    QFixed minimumWidth;
+    QFixed maximumWidth;
+
+    TextLayoutStruct *currentLayoutStruct;
+
+    bool sizeDirty;
+    bool layoutDirty;
+
+    QVector<QPointer<QTextFrame> > floats;
+};
+
+TextFrameData::TextFrameData()
+    : maximumWidth(QFIXED_MAX),
+      currentLayoutStruct(0), sizeDirty(true), layoutDirty(true)
+{
+}
+
+struct TextLayoutStruct {
+    TextLayoutStruct() : maximumWidth(QFIXED_MAX), fullLayout(false)
+    {}
+    QTextFrame *frame;
+    QFixed x_left;
+    QFixed x_right;
+    QFixed frameY; // absolute y position of the current frame
+    QFixed y; // always relative to the current frame
+    QFixed contentsWidth;
+    QFixed minimumWidth;
+    QFixed maximumWidth;
+    bool fullLayout;
+    QList<QTextFrame *> pendingFloats;
+    QFixed pageHeight;
+    QFixed pageBottom;
+    QFixed pageTopMargin;
+    QFixed pageBottomMargin;
+    QRectF updateRect;
+    QRectF updateRectForFloats;
+
+    inline void addUpdateRectForFloat(const QRectF &rect) {
+        if (updateRectForFloats.isValid())
+            updateRectForFloats |= rect;
+        else
+            updateRectForFloats = rect;
+    }
+
+    inline QFixed absoluteY() const
+    { return frameY + y; }
+
+    inline int currentPage() const
+    { return pageHeight == 0 ? 0 : (absoluteY() / pageHeight).truncate(); }
+
+    inline void newPage()
+    { if (pageHeight == QFIXED_MAX) return; pageBottom += pageHeight; y = pageBottom - pageHeight + pageBottomMargin + pageTopMargin - frameY; }
+};
+
+static TextFrameData *createData(QTextFrame *f)
+{
+    TextFrameData *data = new TextFrameData;
+    f->setLayoutData(data);
+    return data;
+}
+
+static inline TextFrameData *data(QTextFrame *f)
+{
+    TextFrameData *data = static_cast<TextFrameData *>(f->layoutData());
+    if (!data)
+        data = createData(f);
+    return data;
+}
+
+static bool isFrameFromInlineObject(QTextFrame *f)
+{
+    return f->firstPosition() > f->lastPosition();
+}
+
+struct CheckPoint
+{
+    QFixed y;
+    QFixed frameY; // absolute y position of the current frame
+    int positionInFrame;
+    QFixed minimumWidth;
+    QFixed maximumWidth;
+    QFixed contentsWidth;
+};
+Q_DECLARE_TYPEINFO(CheckPoint, Q_PRIMITIVE_TYPE);
+
+static bool operator<(const CheckPoint &checkPoint, QFixed y)
+{
+    return checkPoint.y < y;
+}
+
+static bool operator<(const CheckPoint &checkPoint, int pos)
+{
+    return checkPoint.positionInFrame < pos;
+}
+
+#if defined(Q_CC_MSVC) && _MSC_VER < 1600
+//The STL implementation of MSVC 2008 requires the definitions
+
+static bool operator<(const CheckPoint &checkPoint1, const CheckPoint &checkPoint2)
+{
+    return checkPoint1.y < checkPoint2.y;
+}
+
+static bool operator<(QFixed y, const CheckPoint &checkPoint)
+{
+    return y < checkPoint.y;
+}
+
+static bool operator<(int pos, const CheckPoint &checkPoint)
+{
+    return pos < checkPoint.positionInFrame;
+}
+
+#endif
+
+static void fillBackground(QPainter *p, const QRectF &rect, QBrush brush, const QPointF &origin, const QRectF &gradientRect = QRectF())
+{
+    p->save();
+    if (brush.style() >= Qt::LinearGradientPattern && brush.style() <= Qt::ConicalGradientPattern) {
+        if (!gradientRect.isNull()) {
+            QTransform m;
+            m.translate(gradientRect.left(), gradientRect.top());
+            m.scale(gradientRect.width(), gradientRect.height());
+            brush.setTransform(m);
+            const_cast<QGradient *>(brush.gradient())->setCoordinateMode(QGradient::LogicalMode);
+        }
+    } else {
+        p->setBrushOrigin(origin);
+    }
+    p->fillRect(rect, brush);
+    p->restore();
+}
+
+namespace lv {
+
+class TextDocumentLayoutPrivate : public QAbstractTextDocumentLayoutPrivate
+{
+    Q_DECLARE_PUBLIC(TextDocumentLayout)
+public:
+    TextDocumentLayoutPrivate();
+
+    QTextOption::WrapMode wordWrapMode;
+#ifdef LAYOUT_DEBUG
+    mutable QString debug_indent;
+#endif
+
+    int fixedColumnWidth;
+    int cursorWidth;
+
+    QSizeF lastReportedSize;
+    QRectF viewportRect;
+    QRectF clipRect;
+
+    mutable int currentLazyLayoutPosition;
+    mutable int lazyLayoutStepSize;
+    QBasicTimer layoutTimer;
+    mutable QBasicTimer sizeChangedTimer;
+    uint showLayoutProgress : 1;
+    uint insideDocumentChange : 1;
+
+    int lastPageCount;
+    qreal idealWidth;
+    bool contentHasAlignment;
+
+    QFixed blockIndent(const QTextBlockFormat &blockFormat) const;
+
+    void drawFrame(const QPointF &offset, QPainter *painter, const QAbstractTextDocumentLayout::PaintContext &context,
+                   QTextFrame *f) const;
+    void drawFlow(const QPointF &offset, QPainter *painter, const QAbstractTextDocumentLayout::PaintContext &context,
+                  QTextFrameIterator it, const QList<QTextFrame *> &floats, QTextBlock *cursorBlockNeedingRepaint) const;
+    void drawBlock(const QPointF &offset, QPainter *painter, const QAbstractTextDocumentLayout::PaintContext &context,
+                   const QTextBlock &bl, bool inRootFrame) const;
+    void drawListItem(const QPointF &offset, QPainter *painter, const QAbstractTextDocumentLayout::PaintContext &context,
+                      const QTextBlock &bl, const QTextCharFormat *selectionFormat) const;
+    void drawBorder(QPainter *painter, const QRectF &rect, qreal topMargin, qreal bottomMargin, qreal border,
+                    const QBrush &brush, QTextFrameFormat::BorderStyle style) const;
+    void drawFrameDecoration(QPainter *painter, QTextFrame *frame, TextFrameData *fd, const QRectF &clip, const QRectF &rect) const;
+
+    enum HitPoint {
+        PointBefore,
+        PointAfter,
+        PointInside,
+        PointExact
+    };
+    HitPoint hitTest(QTextFrame *frame, const QFixedPoint &point, int *position, QTextLayout **l, Qt::HitTestAccuracy accuracy) const;
+    HitPoint hitTest(QTextFrameIterator it, HitPoint hit, const QFixedPoint &p,
+                     int *position, QTextLayout **l, Qt::HitTestAccuracy accuracy) const;
+    HitPoint hitTest(const QTextBlock &bl, const QFixedPoint &point, int *position, QTextLayout **l, Qt::HitTestAccuracy accuracy) const;
+
+    void positionFloat(QTextFrame *frame, QTextLine *currentLine = 0);
+
+    // calls the next one
+    QRectF layoutFrame(QTextFrame *f, int layoutFrom, int layoutTo, QFixed parentY = 0);
+    QRectF layoutFrame(QTextFrame *f, int layoutFrom, int layoutTo, QFixed frameWidth, QFixed frameHeight, QFixed parentY = 0);
+
+    void layoutBlock(const QTextBlock &bl, int blockPosition, const QTextBlockFormat &blockFormat,
+                     TextLayoutStruct *layoutStruct, int layoutFrom, int layoutTo, const QTextBlockFormat *previousBlockFormat);
+    void layoutFlow(QTextFrameIterator it, TextLayoutStruct *layoutStruct, int layoutFrom, int layoutTo, QFixed width = 0);
+
+    void floatMargins(const QFixed &y, const TextLayoutStruct *layoutStruct, QFixed *left, QFixed *right) const;
+    QFixed findY(QFixed yFrom, const TextLayoutStruct *layoutStruct, QFixed requiredWidth) const;
+
+    QVector<CheckPoint> checkPoints;
+
+    QTextFrameIterator frameIteratorForYPosition(QFixed y) const;
+    QTextFrameIterator frameIteratorForTextPosition(int position) const;
+
+    void ensureLayouted(QFixed y) const;
+    void ensureLayoutedByPosition(int position) const;
+    inline void ensureLayoutFinished() const
+    { ensureLayoutedByPosition(INT_MAX); }
+    void layoutStep() const;
+
+    QRectF frameBoundingRectInternal(QTextFrame *frame) const;
+
+    qreal scaleToDevice(qreal value) const;
+    QFixed scaleToDevice(QFixed value) const;
+};
+
+TextDocumentLayoutPrivate::TextDocumentLayoutPrivate()
+    : fixedColumnWidth(-1),
+      cursorWidth(1),
+      currentLazyLayoutPosition(-1),
+      lazyLayoutStepSize(1000),
+      lastPageCount(-1)
+{
+    showLayoutProgress = true;
+    insideDocumentChange = false;
+    idealWidth = 0;
+    contentHasAlignment = false;
+}
+
+
+QTextFrameIterator TextDocumentLayoutPrivate::frameIteratorForYPosition(QFixed y) const
+{
+    QTextFrame *rootFrame = document->rootFrame();
+
+    if (checkPoints.isEmpty()
+        || y < 0 || y > data(rootFrame)->size.height)
+    {
+        return QTextFrameIterator::findFrameBeginning(rootFrame);
+    }
+
+    QVector<CheckPoint>::ConstIterator checkPoint = std::lower_bound(checkPoints.begin(), checkPoints.end(), y);
+    if (checkPoint == checkPoints.end())
+    {
+        return QTextFrameIterator::findFrameBeginning(rootFrame);
+    }
+
+    if (checkPoint != checkPoints.begin())
+        --checkPoint;
+
+    const int position = rootFrame->firstPosition() + checkPoint->positionInFrame;
+    return frameIteratorForTextPosition(position);
+}
+
+QTextFrameIterator TextDocumentLayoutPrivate::frameIteratorForTextPosition(int position) const
+{
+    QTextFrame *rootFrame = document->rootFrame();
+
+    const QTextDocumentPrivate::BlockMap &map = docPrivate->blockMap();
+    const int begin = map.findNode(rootFrame->firstPosition());
+    const int end = map.findNode(rootFrame->lastPosition()+1);
+
+    const int block = map.findNode(position);
+    const int blockPos = map.position(block);
+
+    QTextFrameIterator it(rootFrame, block, begin, end);
+
+    QTextFrame *containingFrame = document->frameAt(blockPos);
+    if (containingFrame != rootFrame) {
+        while (containingFrame->parentFrame() != rootFrame) {
+            containingFrame = containingFrame->parentFrame();
+            Q_ASSERT(containingFrame);
+        }
+
+        it.cf = containingFrame;
+        it.cb = 0;
+    }
+
+    return it;
+}
+
+TextDocumentLayoutPrivate::HitPoint
+TextDocumentLayoutPrivate::hitTest(QTextFrame *frame, const QFixedPoint &point, int *position, QTextLayout **l, Qt::HitTestAccuracy accuracy) const
+{
+    TextFrameData *fd = data(frame);
+    // #########
+    if (fd->layoutDirty)
+        return PointAfter;
+    Q_ASSERT(!fd->layoutDirty);
+    Q_ASSERT(!fd->sizeDirty);
+    const QFixedPoint relativePoint(point.x - fd->position.x, point.y - fd->position.y);
+
+    QTextFrame *rootFrame = document->rootFrame();
+
+//     LDEBUG << "checking frame" << frame->firstPosition() << "point=" << point
+//            << "position" << fd->position << "size" << fd->size;
+    if (frame != rootFrame) {
+        if (relativePoint.y < 0 || relativePoint.x < 0) {
+            *position = frame->firstPosition() - 1;
+//             LDEBUG << "before pos=" << *position;
+            return PointBefore;
+        } else if (relativePoint.y > fd->size.height || relativePoint.x > fd->size.width) {
+            *position = frame->lastPosition() + 1;
+//             LDEBUG << "after pos=" << *position;
+            return PointAfter;
+        }
+    }
+
+    if (isFrameFromInlineObject(frame)) {
+        *position = frame->firstPosition() - 1;
+        return PointExact;
+    }
+
+    const QList<QTextFrame *> childFrames = frame->childFrames();
+    for (int i = 0; i < childFrames.size(); ++i) {
+        QTextFrame *child = childFrames.at(i);
+        if (isFrameFromInlineObject(child)
+            && child->frameFormat().position() != QTextFrameFormat::InFlow
+            && hitTest(child, relativePoint, position, l, accuracy) == PointExact)
+        {
+            return PointExact;
+        }
+    }
+
+    QTextFrameIterator it = QTextFrameIterator::findFrameBeginning(frame);
+
+    if (frame == rootFrame) {
+        it = frameIteratorForYPosition(relativePoint.y);
+
+        Q_ASSERT(it.parentFrame() == frame);
+    }
+
+    if (it.currentFrame())
+        *position = it.currentFrame()->firstPosition();
+    else
+        *position = it.currentBlock().position();
+
+    return hitTest(it, PointBefore, relativePoint, position, l, accuracy);
+}
+
+TextDocumentLayoutPrivate::HitPoint
+TextDocumentLayoutPrivate::hitTest(QTextFrameIterator it, HitPoint hit, const QFixedPoint &p,
+                                    int *position, QTextLayout **l, Qt::HitTestAccuracy accuracy) const
+{
+    INC_INDENT;
+
+    for (; !it.atEnd(); ++it) {
+        QTextFrame *c = it.currentFrame();
+        HitPoint hp;
+        int pos = -1;
+        if (c) {
+            hp = hitTest(c, p, &pos, l, accuracy);
+        } else {
+            hp = hitTest(it.currentBlock(), p, &pos, l, accuracy);
+        }
+        if (hp >= PointInside) {
+            hit = hp;
+            *position = pos;
+            break;
+        }
+        if (hp == PointBefore && pos < *position) {
+            *position = pos;
+            hit = hp;
+        } else if (hp == PointAfter && pos > *position) {
+            *position = pos;
+            hit = hp;
+        }
+    }
+
+    DEC_INDENT;
+//     LDEBUG << "inside=" << hit << " pos=" << *position;
+    return hit;
+}
+
+TextDocumentLayoutPrivate::HitPoint
+TextDocumentLayoutPrivate::hitTest(const QTextBlock &bl, const QFixedPoint &point, int *position, QTextLayout **l,
+                                    Qt::HitTestAccuracy accuracy) const
+{
+    QTextLayout *tl = bl.layout();
+    QRectF textrect = tl->boundingRect();
+    textrect.translate(tl->position());
+//     LDEBUG << "    checking block" << bl.position() << "point=" << point
+//            << "    tlrect" << textrect;
+    *position = bl.position();
+    if (point.y.toReal() < textrect.top()) {
+//             LDEBUG << "    before pos=" << *position;
+        return PointBefore;
+    } else if (point.y.toReal() > textrect.bottom()) {
+        *position += bl.length();
+//             LDEBUG << "    after pos=" << *position;
+        return PointAfter;
+    }
+
+    QPointF pos = point.toPointF() - tl->position();
+
+    // ### rtl?
+
+    HitPoint hit = PointInside;
+    *l = tl;
+    int off = 0;
+    for (int i = 0; i < tl->lineCount(); ++i) {
+        QTextLine line = tl->lineAt(i);
+        const QRectF lr = line.naturalTextRect();
+        if (lr.top() > pos.y()) {
+            off = qMin(off, line.textStart());
+        } else if (lr.bottom() <= pos.y()) {
+            off = qMax(off, line.textStart() + line.textLength());
+        } else {
+            if (lr.left() <= pos.x() && lr.right() >= pos.x())
+                hit = PointExact;
+            // when trying to hit an anchor we want it to hit not only in the left
+            // half
+            if (accuracy == Qt::ExactHit)
+                off = line.xToCursor(pos.x(), QTextLine::CursorOnCharacter);
+            else
+                off = line.xToCursor(pos.x(), QTextLine::CursorBetweenCharacters);
+            break;
+        }
+    }
+    *position += off;
+
+//     LDEBUG << "    inside=" << hit << " pos=" << *position;
+    return hit;
+}
+
+// ### could be moved to QTextBlock
+QFixed TextDocumentLayoutPrivate::blockIndent(const QTextBlockFormat &blockFormat) const
+{
+    qreal indent = blockFormat.indent();
+
+    QTextObject *object = document->objectForFormat(blockFormat);
+    if (object)
+        indent += object->format().toListFormat().indent();
+
+    if (qIsNull(indent))
+        return 0;
+
+    qreal scale = 1;
+    if (paintDevice) {
+        scale = qreal(paintDevice->logicalDpiY()) / qreal(qt_defaultDpi());
+    }
+
+    return QFixed::fromReal(indent * scale * document->indentWidth());
+}
+
+void TextDocumentLayoutPrivate::drawBorder(QPainter *painter, const QRectF &rect, qreal topMargin, qreal bottomMargin,
+                                            qreal border, const QBrush &brush, QTextFrameFormat::BorderStyle style) const
+{
+    const qreal pageHeight = document->pageSize().height();
+    const int topPage = pageHeight > 0 ? static_cast<int>(rect.top() / pageHeight) : 0;
+    const int bottomPage = pageHeight > 0 ? static_cast<int>((rect.bottom() + border) / pageHeight) : 0;
+
+    Q_UNUSED(style);
+
+    bool turn_off_antialiasing = !(painter->renderHints() & QPainter::Antialiasing);
+    painter->setRenderHint(QPainter::Antialiasing);
+
+    for (int i = topPage; i <= bottomPage; ++i) {
+        QRectF clipped = rect.toRect();
+
+        if (topPage != bottomPage) {
+            clipped.setTop(qMax(clipped.top(), i * pageHeight + topMargin - border));
+            clipped.setBottom(qMin(clipped.bottom(), (i + 1) * pageHeight - bottomMargin));
+
+            if (clipped.bottom() <= clipped.top())
+                continue;
+        }
+
+        painter->save();
+        painter->setPen(Qt::NoPen);
+        painter->setBrush(brush);
+        painter->drawRect(QRectF(clipped.left(), clipped.top(), clipped.left() + border, clipped.bottom() + border));
+        painter->drawRect(QRectF(clipped.left() + border, clipped.top(), clipped.right() + border, clipped.top() + border));
+        painter->drawRect(QRectF(clipped.right(), clipped.top() + border, clipped.right() + border, clipped.bottom()));
+        painter->drawRect(QRectF(clipped.left() + border, clipped.bottom(), clipped.right() + border, clipped.bottom() + border));
+        painter->restore();
+    }
+    if (turn_off_antialiasing)
+        painter->setRenderHint(QPainter::Antialiasing, false);
+}
+
+void TextDocumentLayoutPrivate::drawFrameDecoration(QPainter *painter, QTextFrame *frame, TextFrameData *fd, const QRectF &clip, const QRectF &rect) const
+{
+
+    const QBrush bg = frame->frameFormat().background();
+    if (bg != Qt::NoBrush) {
+        QRectF bgRect = rect;
+        bgRect.adjust((fd->leftMargin + fd->border).toReal(),
+                      (fd->topMargin + fd->border).toReal(),
+                      - (fd->rightMargin + fd->border).toReal(),
+                      - (fd->bottomMargin + fd->border).toReal());
+
+        QRectF gradientRect; // invalid makes it default to bgRect
+        QPointF origin = bgRect.topLeft();
+        if (!frame->parentFrame()) {
+            bgRect = clip;
+            gradientRect.setWidth(painter->device()->width());
+            gradientRect.setHeight(painter->device()->height());
+        }
+        fillBackground(painter, bgRect, bg, origin, gradientRect);
+    }
+    if (fd->border != 0) {
+        painter->save();
+        painter->setBrush(Qt::lightGray);
+        painter->setPen(Qt::NoPen);
+
+        const qreal leftEdge = rect.left() + fd->leftMargin.toReal();
+        const qreal border = fd->border.toReal();
+        const qreal topMargin = fd->topMargin.toReal();
+        const qreal leftMargin = fd->leftMargin.toReal();
+        const qreal bottomMargin = fd->bottomMargin.toReal();
+        const qreal rightMargin = fd->rightMargin.toReal();
+        const qreal w = rect.width() - 2 * border - leftMargin - rightMargin;
+        const qreal h = rect.height() - 2 * border - topMargin - bottomMargin;
+
+        drawBorder(painter, QRectF(leftEdge, rect.top() + topMargin, w + border, h + border),
+                   fd->effectiveTopMargin.toReal(), fd->effectiveBottomMargin.toReal(),
+                   border, frame->frameFormat().borderBrush(), frame->frameFormat().borderStyle());
+
+        painter->restore();
+    }
+}
+
+void TextDocumentLayoutPrivate::drawFrame(const QPointF &offset, QPainter *painter,
+                                           const QAbstractTextDocumentLayout::PaintContext &context,
+                                           QTextFrame *frame) const
+{
+    TextFrameData *fd = data(frame);
+    // #######
+    if (fd->layoutDirty)
+        return;
+    Q_ASSERT(!fd->sizeDirty);
+    Q_ASSERT(!fd->layoutDirty);
+
+    const QPointF off = offset + fd->position.toPointF();
+    if (context.clip.isValid()
+        && (off.y() > context.clip.bottom() || off.y() + fd->size.height.toReal() < context.clip.top()
+            || off.x() > context.clip.right() || off.x() + fd->size.width.toReal() < context.clip.left()))
+        return;
+
+//     LDEBUG << debug_indent << "drawFrame" << frame->firstPosition() << "--" << frame->lastPosition() << "at" << offset;
+//     INC_INDENT;
+    QTextBlock cursorBlockNeedingRepaint;
+    QPointF offsetOfRepaintedCursorBlock = off;
+
+    const QRectF frameRect(off, fd->size.toSizeF());
+
+    drawFrameDecoration(painter, frame, fd, context.clip, frameRect);
+
+    QTextFrameIterator it = QTextFrameIterator::findFrameBeginning(frame);
+
+    if (frame == document->rootFrame())
+        it = frameIteratorForYPosition(QFixed::fromReal(context.clip.top()));
+
+    QList<QTextFrame *> floats;
+    const int numFloats = fd->floats.count();
+    floats.reserve(numFloats);
+    for (int i = 0; i < numFloats; ++i)
+        floats.append(fd->floats.at(i));
+
+    drawFlow(off, painter, context, it, floats, &cursorBlockNeedingRepaint);
+
+
+    if (cursorBlockNeedingRepaint.isValid()) {
+        const QPen oldPen = painter->pen();
+        painter->setPen(context.palette.color(QPalette::Text));
+        const int cursorPos = context.cursorPosition - cursorBlockNeedingRepaint.position();
+        cursorBlockNeedingRepaint.layout()->drawCursor(painter, offsetOfRepaintedCursorBlock,
+                                                       cursorPos, cursorWidth);
+        painter->setPen(oldPen);
+    }
+
+//     DEC_INDENT;
+
+    return;
+}
+
+void TextDocumentLayoutPrivate::drawFlow(const QPointF &offset, QPainter *painter, const QAbstractTextDocumentLayout::PaintContext &context,
+                                          QTextFrameIterator it, const QList<QTextFrame *> &floats, QTextBlock *cursorBlockNeedingRepaint) const
+{
+    Q_Q(const TextDocumentLayout);
+    const bool inRootFrame = (!it.atEnd() && it.parentFrame() && it.parentFrame()->parentFrame() == 0);
+
+    QVector<CheckPoint>::ConstIterator lastVisibleCheckPoint = checkPoints.end();
+    if (inRootFrame && context.clip.isValid()) {
+        lastVisibleCheckPoint = std::lower_bound(checkPoints.begin(), checkPoints.end(), QFixed::fromReal(context.clip.bottom()));
+    }
+
+    QTextBlock previousBlock;
+    QTextFrame *previousFrame = 0;
+
+    for (; !it.atEnd(); ++it) {
+        QTextFrame *c = it.currentFrame();
+
+        if (inRootFrame && !checkPoints.isEmpty()) {
+            int currentPosInDoc;
+            if (c)
+                currentPosInDoc = c->firstPosition();
+            else
+                currentPosInDoc = it.currentBlock().position();
+
+            // if we're past what is already laid out then we're better off
+            // not trying to draw things that may not be positioned correctly yet
+            if (currentPosInDoc >= checkPoints.constLast().positionInFrame)
+                break;
+
+            if (lastVisibleCheckPoint != checkPoints.end()
+                && context.clip.isValid()
+                && currentPosInDoc >= lastVisibleCheckPoint->positionInFrame
+               )
+                break;
+        }
+
+        if (c)
+            drawFrame(offset, painter, context, c);
+        else {
+            QAbstractTextDocumentLayout::PaintContext pc = context;
+            drawBlock(offset, painter, pc, it.currentBlock(), inRootFrame);
+        }
+
+        previousBlock = it.currentBlock();
+        previousFrame = c;
+    }
+
+    for (int i = 0; i < floats.count(); ++i) {
+        QTextFrame *frame = floats.at(i);
+        if (!isFrameFromInlineObject(frame)
+            || frame->frameFormat().position() == QTextFrameFormat::InFlow)
+            continue;
+
+        const int pos = frame->firstPosition() - 1;
+        QTextCharFormat format = const_cast<TextDocumentLayout *>(q)->format(pos);
+        QTextObjectInterface *handler = q->handlerForObject(format.objectType());
+        if (handler) {
+            QRectF rect = frameBoundingRectInternal(frame);
+            handler->drawObject(painter, rect, document, pos, format);
+        }
+    }
+}
+
+void TextDocumentLayoutPrivate::drawBlock(const QPointF &offset, QPainter *painter,
+                                           const QAbstractTextDocumentLayout::PaintContext &context,
+                                           const QTextBlock &bl, bool inRootFrame) const
+{
+    const QTextLayout *tl = bl.layout();
+    QRectF r = tl->boundingRect();
+    r.translate(offset + tl->position());
+    if (!bl.isVisible() || (context.clip.isValid() && (r.bottom() < context.clip.y() || r.top() > context.clip.bottom())))
+        return;
+//      LDEBUG << debug_indent << "drawBlock" << bl.position() << "at" << offset << "br" << tl->boundingRect();
+
+    QTextBlockFormat blockFormat = bl.blockFormat();
+
+    QBrush bg = blockFormat.background();
+    if (bg != Qt::NoBrush) {
+        QRectF rect = r;
+
+        // extend the background rectangle if we're in the root frame with NoWrap,
+        // as the rect of the text block will then be only the width of the text
+        // instead of the full page width
+        if (inRootFrame && document->pageSize().width() <= 0) {
+            const TextFrameData *fd = data(document->rootFrame());
+            rect.setRight((fd->size.width - fd->rightMargin).toReal());
+        }
+
+        fillBackground(painter, rect, bg, r.topLeft());
+    }
+
+    QVector<QTextLayout::FormatRange> selections;
+    int blpos = bl.position();
+    int bllen = bl.length();
+    const QTextCharFormat *selFormat = 0;
+    for (int i = 0; i < context.selections.size(); ++i) {
+        const QAbstractTextDocumentLayout::Selection &range = context.selections.at(i);
+        const int selStart = range.cursor.selectionStart() - blpos;
+        const int selEnd = range.cursor.selectionEnd() - blpos;
+        if (selStart < bllen && selEnd > 0
+             && selEnd > selStart) {
+            QTextLayout::FormatRange o;
+            o.start = selStart;
+            o.length = selEnd - selStart;
+            o.format = range.format;
+            selections.append(o);
+        } else if (! range.cursor.hasSelection() && range.format.hasProperty(QTextFormat::FullWidthSelection)
+                   && bl.contains(range.cursor.position())) {
+            // for full width selections we don't require an actual selection, just
+            // a position to specify the line. that's more convenience in usage.
+            QTextLayout::FormatRange o;
+            QTextLine l = tl->lineForTextPosition(range.cursor.position() - blpos);
+            o.start = l.textStart();
+            o.length = l.textLength();
+            if (o.start + o.length == bllen - 1)
+                ++o.length; // include newline
+            o.format = range.format;
+            selections.append(o);
+       }
+        if (selStart < 0 && selEnd >= 1)
+            selFormat = &range.format;
+    }
+
+    QTextObject *object = document->objectForFormat(bl.blockFormat());
+    if (object && object->format().toListFormat().style() != QTextListFormat::ListStyleUndefined)
+        drawListItem(offset, painter, context, bl, selFormat);
+
+    QPen oldPen = painter->pen();
+    painter->setPen(context.palette.color(QPalette::Text));
+
+    tl->draw(painter, offset, selections, context.clip.isValid() ? (context.clip & clipRect) : clipRect);
+
+    if ((context.cursorPosition >= blpos && context.cursorPosition < blpos + bllen)
+        || (context.cursorPosition < -1 && !tl->preeditAreaText().isEmpty())) {
+        int cpos = context.cursorPosition;
+        if (cpos < -1)
+            cpos = tl->preeditAreaPosition() - (cpos + 2);
+        else
+            cpos -= blpos;
+        tl->drawCursor(painter, offset, cpos, cursorWidth);
+    }
+
+    if (blockFormat.hasProperty(QTextFormat::BlockTrailingHorizontalRulerWidth)) {
+        const qreal width = blockFormat.lengthProperty(QTextFormat::BlockTrailingHorizontalRulerWidth).value(r.width());
+        painter->setPen(context.palette.color(QPalette::Dark));
+        qreal y = r.bottom();
+        if (bl.length() == 1)
+            y = r.top() + r.height() / 2;
+
+        const qreal middleX = r.left() + r.width() / 2;
+        painter->drawLine(QLineF(middleX - width / 2, y, middleX + width / 2, y));
+    }
+
+    painter->setPen(oldPen);
+}
+
+
+void TextDocumentLayoutPrivate::drawListItem(const QPointF &offset, QPainter *painter,
+                                              const QAbstractTextDocumentLayout::PaintContext &context,
+                                              const QTextBlock &bl, const QTextCharFormat *selectionFormat) const
+{
+    Q_Q(const TextDocumentLayout);
+    const QTextBlockFormat blockFormat = bl.blockFormat();
+    const QTextCharFormat charFormat = QTextCursor(bl).charFormat();
+    QFont font(charFormat.font());
+    if (q->paintDevice())
+        font = QFont(font, q->paintDevice());
+
+    const QFontMetrics fontMetrics(font);
+    QTextObject * const object = document->objectForFormat(blockFormat);
+    const QTextListFormat lf = object->format().toListFormat();
+    int style = lf.style();
+    QString itemText;
+    QSizeF size;
+
+    if (blockFormat.hasProperty(QTextFormat::ListStyle))
+        style = QTextListFormat::Style(blockFormat.intProperty(QTextFormat::ListStyle));
+
+    QTextLayout *layout = bl.layout();
+    if (layout->lineCount() == 0)
+        return;
+    QTextLine firstLine = layout->lineAt(0);
+    Q_ASSERT(firstLine.isValid());
+    QPointF pos = (offset + layout->position()).toPoint();
+    Qt::LayoutDirection dir = bl.textDirection();
+    {
+        QRectF textRect = firstLine.naturalTextRect();
+        pos += textRect.topLeft().toPoint();
+        if (dir == Qt::RightToLeft)
+            pos.rx() += textRect.width();
+    }
+
+    switch (style) {
+    case QTextListFormat::ListDecimal:
+    case QTextListFormat::ListLowerAlpha:
+    case QTextListFormat::ListUpperAlpha:
+    case QTextListFormat::ListLowerRoman:
+    case QTextListFormat::ListUpperRoman:
+        itemText = static_cast<QTextList *>(object)->itemText(bl);
+#if (QT_VERSION >= QT_VERSION_CHECK(5,10,0))
+        size.setWidth(fontMetrics.horizontalAdvance(itemText));
+#else
+        size.setWidth(fontMetrics.width(itemText));
+#endif
+        size.setHeight(fontMetrics.height());
+        break;
+
+    case QTextListFormat::ListSquare:
+    case QTextListFormat::ListCircle:
+    case QTextListFormat::ListDisc:
+        size.setWidth(fontMetrics.lineSpacing() / 3);
+        size.setHeight(size.width());
+        break;
+
+    case QTextListFormat::ListStyleUndefined:
+        return;
+    default: return;
+    }
+
+    QRectF r(pos, size);
+#if (QT_VERSION > QT_VERSION_CHECK(5,10,0))
+    qreal xoff = fontMetrics.horizontalAdvance(QLatin1Char(' '));
+#else
+    qreal xoff = fontMetrics.width(QLatin1Char(' '));
+#endif
+    if (dir == Qt::LeftToRight)
+        xoff = -xoff - size.width();
+    r.translate( xoff, (fontMetrics.height() / 2) - (size.height() / 2));
+
+    painter->save();
+
+    painter->setRenderHint(QPainter::Antialiasing);
+
+    if (selectionFormat) {
+        painter->setPen(QPen(selectionFormat->foreground(), 0));
+        painter->fillRect(r, selectionFormat->background());
+    } else {
+        QBrush fg = charFormat.foreground();
+        if (fg == Qt::NoBrush)
+            fg = context.palette.text();
+        painter->setPen(QPen(fg, 0));
+    }
+
+    QBrush brush = context.palette.brush(QPalette::Text);
+
+    switch (style) {
+    case QTextListFormat::ListDecimal:
+    case QTextListFormat::ListLowerAlpha:
+    case QTextListFormat::ListUpperAlpha:
+    case QTextListFormat::ListLowerRoman:
+    case QTextListFormat::ListUpperRoman: {
+        QTextLayout layout(itemText, font, q->paintDevice());
+        layout.setCacheEnabled(true);
+        QTextOption option(Qt::AlignLeft | Qt::AlignAbsolute);
+        option.setTextDirection(dir);
+        layout.setTextOption(option);
+        layout.beginLayout();
+        QTextLine line = layout.createLine();
+        if (line.isValid())
+            line.setLeadingIncluded(true);
+        layout.endLayout();
+        layout.draw(painter, QPointF(r.left(), pos.y()));
+        break;
+    }
+    case QTextListFormat::ListSquare:
+        painter->fillRect(r, brush);
+        break;
+    case QTextListFormat::ListCircle:
+        painter->setPen(QPen(brush, 0));
+        painter->drawEllipse(r.translated(0.5, 0.5)); // pixel align for sharper rendering
+        break;
+    case QTextListFormat::ListDisc:
+        painter->setBrush(brush);
+        painter->setPen(Qt::NoPen);
+        painter->drawEllipse(r);
+        break;
+    case QTextListFormat::ListStyleUndefined:
+        break;
+    default:
+        break;
+    }
+
+    painter->restore();
+}
+
+static QFixed flowPosition(const QTextFrameIterator &it)
+{
+    if (it.atEnd())
+        return 0;
+
+    if (it.currentFrame()) {
+        return data(it.currentFrame())->position.y;
+    } else {
+        QTextBlock block = it.currentBlock();
+        QTextLayout *layout = block.layout();
+        if (layout->lineCount() == 0)
+            return QFixed::fromReal(layout->position().y());
+        else
+            return QFixed::fromReal(layout->position().y() + layout->lineAt(0).y());
+    }
+}
+
+static QFixed firstChildPos(const QTextFrame *f)
+{
+    return flowPosition(QTextFrameIterator::findFrameBeginning(f));
+}
+
+void TextDocumentLayoutPrivate::positionFloat(QTextFrame *frame, QTextLine *currentLine)
+{
+    TextFrameData *fd = data(frame);
+
+    QTextFrame *parent = frame->parentFrame();
+    Q_ASSERT(parent);
+    TextFrameData *pd = data(parent);
+    Q_ASSERT(pd && pd->currentLayoutStruct);
+
+    TextLayoutStruct *layoutStruct = pd->currentLayoutStruct;
+
+    if (!pd->floats.contains(frame))
+        pd->floats.append(frame);
+    fd->layoutDirty = true;
+    Q_ASSERT(!fd->sizeDirty);
+
+    QFixed y = layoutStruct->y;
+    if (currentLine) {
+        QFixed left, right;
+        floatMargins(y, layoutStruct, &left, &right);
+        if (right - left < QFixed::fromReal(currentLine->naturalTextWidth()) + fd->size.width) {
+            layoutStruct->pendingFloats.append(frame);
+            return;
+        }
+    }
+
+    bool frameSpansIntoNextPage = (y + layoutStruct->frameY + fd->size.height > layoutStruct->pageBottom);
+    if (frameSpansIntoNextPage && fd->size.height <= layoutStruct->pageHeight) {
+        layoutStruct->newPage();
+        y = layoutStruct->y;
+
+        frameSpansIntoNextPage = false;
+    }
+
+    y = findY(y, layoutStruct, fd->size.width);
+
+    QFixed left, right;
+    floatMargins(y, layoutStruct, &left, &right);
+
+    if (frame->frameFormat().position() == QTextFrameFormat::FloatLeft) {
+        fd->position.x = left;
+        fd->position.y = y;
+    } else {
+        fd->position.x = right - fd->size.width;
+        fd->position.y = y;
+    }
+
+    layoutStruct->minimumWidth = qMax(layoutStruct->minimumWidth, fd->minimumWidth);
+    layoutStruct->maximumWidth = qMin(layoutStruct->maximumWidth, fd->maximumWidth);
+
+    fd->layoutDirty = false;
+
+}
+
+QRectF TextDocumentLayoutPrivate::layoutFrame(QTextFrame *f, int layoutFrom, int layoutTo, QFixed parentY)
+{
+    LDEBUG << "layoutFrame (pre)";
+    Q_ASSERT(data(f)->sizeDirty);
+
+    QTextFrameFormat fformat = f->frameFormat();
+
+    QTextFrame *parent = f->parentFrame();
+    const TextFrameData *pd = parent ? data(parent) : 0;
+
+    const qreal maximumWidth = qMax(qreal(0), pd ? pd->contentsWidth.toReal() : document->pageSize().width());
+    QFixed width = QFixed::fromReal(fformat.width().value(maximumWidth));
+    if (fformat.width().type() == QTextLength::FixedLength)
+        width = scaleToDevice(width);
+
+    const QFixed maximumHeight = pd ? pd->contentsHeight : -1;
+    const QFixed height = (maximumHeight != -1 || fformat.height().type() != QTextLength::PercentageLength)
+                            ? QFixed::fromReal(fformat.height().value(maximumHeight.toReal()))
+                            : -1;
+
+    return layoutFrame(f, layoutFrom, layoutTo, width, height, parentY);
+}
+
+QRectF TextDocumentLayoutPrivate::layoutFrame(QTextFrame *f, int layoutFrom, int layoutTo, QFixed frameWidth, QFixed frameHeight, QFixed parentY)
+{
+    LDEBUG << "layoutFrame from=" << layoutFrom << "to=" << layoutTo;
+    Q_ASSERT(data(f)->sizeDirty);
+
+    TextFrameData *fd = data(f);
+    QFixed newContentsWidth;
+
+    bool fullLayout = false;
+    {
+        QTextFrameFormat fformat = f->frameFormat();
+        // set sizes of this frame from the format
+        QFixed tm = QFixed::fromReal(fformat.topMargin());
+        if (tm != fd->topMargin) {
+            fd->topMargin = tm;
+            fullLayout = true;
+        }
+        QFixed bm = QFixed::fromReal(fformat.bottomMargin());
+        if (bm != fd->bottomMargin) {
+            fd->bottomMargin = bm;
+            fullLayout = true;
+        }
+        fd->leftMargin = QFixed::fromReal(fformat.leftMargin());
+        fd->rightMargin = QFixed::fromReal(fformat.rightMargin());
+        QFixed b = QFixed::fromReal(fformat.border());
+        if (b != fd->border) {
+            fd->border = b;
+            fullLayout = true;
+        }
+        QFixed p = QFixed::fromReal(fformat.padding());
+        if (p != fd->padding) {
+            fd->padding = p;
+            fullLayout = true;
+        }
+
+        QTextFrame *parent = f->parentFrame();
+        const TextFrameData *pd = parent ? data(parent) : 0;
+
+        // accumulate top and bottom margins
+        if (parent) {
+            fd->effectiveTopMargin = pd->effectiveTopMargin + fd->topMargin + fd->border + fd->padding;
+            fd->effectiveBottomMargin = pd->effectiveBottomMargin + fd->topMargin + fd->border + fd->padding;
+        } else {
+            fd->effectiveTopMargin = fd->topMargin + fd->border + fd->padding;
+            fd->effectiveBottomMargin = fd->bottomMargin + fd->border + fd->padding;
+        }
+
+        newContentsWidth = frameWidth - 2*(fd->border + fd->padding)
+                           - fd->leftMargin - fd->rightMargin;
+
+        if (frameHeight != -1) {
+            fd->contentsHeight = frameHeight - 2*(fd->border + fd->padding)
+                                 - fd->topMargin - fd->bottomMargin;
+        } else {
+            fd->contentsHeight = frameHeight;
+        }
+    }
+
+    if (isFrameFromInlineObject(f)) {
+        // never reached, handled in resizeInlineObject/positionFloat instead
+        return QRectF();
+    }
+
+    // set fd->contentsWidth temporarily, so that layoutFrame for the children
+    // picks the right width. We'll initialize it properly at the end of this
+    // function.
+    fd->contentsWidth = newContentsWidth;
+
+    TextLayoutStruct layoutStruct;
+    layoutStruct.frame = f;
+    layoutStruct.x_left = fd->leftMargin + fd->border + fd->padding;
+    layoutStruct.x_right = layoutStruct.x_left + newContentsWidth;
+    layoutStruct.y = fd->topMargin + fd->border + fd->padding;
+    layoutStruct.frameY = parentY + fd->position.y;
+    layoutStruct.contentsWidth = 0;
+    layoutStruct.minimumWidth = 0;
+    layoutStruct.maximumWidth = QFIXED_MAX;
+    layoutStruct.fullLayout = fullLayout || (fd->oldContentsWidth != newContentsWidth);
+    layoutStruct.updateRect = QRectF(QPointF(0, 0), QSizeF(qreal(INT_MAX), qreal(INT_MAX)));
+    LDEBUG << "layoutStruct: x_left" << layoutStruct.x_left << "x_right" << layoutStruct.x_right
+           << "fullLayout" << layoutStruct.fullLayout;
+    fd->oldContentsWidth = newContentsWidth;
+
+    layoutStruct.pageHeight = QFixed::fromReal(document->pageSize().height());
+    if (layoutStruct.pageHeight < 0)
+        layoutStruct.pageHeight = QFIXED_MAX;
+
+    const int currentPage = layoutStruct.pageHeight == 0 ? 0 : (layoutStruct.frameY / layoutStruct.pageHeight).truncate();
+    layoutStruct.pageTopMargin = fd->effectiveTopMargin;
+    layoutStruct.pageBottomMargin = fd->effectiveBottomMargin;
+    layoutStruct.pageBottom = (currentPage + 1) * layoutStruct.pageHeight - layoutStruct.pageBottomMargin;
+
+    if (!f->parentFrame())
+        idealWidth = 0; // reset
+
+    QTextFrameIterator it = QTextFrameIterator::findFrameBeginning(f);
+    layoutFlow(it, &layoutStruct, layoutFrom, layoutTo);
+
+    QFixed maxChildFrameWidth = 0;
+    QList<QTextFrame *> children = f->childFrames();
+    for (int i = 0; i < children.size(); ++i) {
+        QTextFrame *c = children.at(i);
+        TextFrameData *cd = data(c);
+        maxChildFrameWidth = qMax(maxChildFrameWidth, cd->size.width);
+    }
+
+    const QFixed marginWidth = 2*(fd->border + fd->padding) + fd->leftMargin + fd->rightMargin;
+    if (!f->parentFrame()) {
+        idealWidth = qMax(maxChildFrameWidth, layoutStruct.contentsWidth).toReal();
+        idealWidth += marginWidth.toReal();
+    }
+
+    QFixed actualWidth = qMax(newContentsWidth, qMax(maxChildFrameWidth, layoutStruct.contentsWidth));
+    fd->contentsWidth = actualWidth;
+    if (newContentsWidth <= 0) { // nowrap layout?
+        fd->contentsWidth = newContentsWidth;
+    }
+
+    fd->minimumWidth = layoutStruct.minimumWidth;
+    fd->maximumWidth = layoutStruct.maximumWidth;
+
+    fd->size.height = fd->contentsHeight == -1
+                 ? layoutStruct.y + fd->border + fd->padding + fd->bottomMargin
+                 : fd->contentsHeight + 2*(fd->border + fd->padding) + fd->topMargin + fd->bottomMargin;
+    fd->size.width = actualWidth + marginWidth;
+    fd->sizeDirty = false;
+    if (layoutStruct.updateRectForFloats.isValid())
+        layoutStruct.updateRect |= layoutStruct.updateRectForFloats;
+    return layoutStruct.updateRect;
+}
+
+void TextDocumentLayoutPrivate::layoutFlow(QTextFrameIterator it, TextLayoutStruct *layoutStruct,
+                                            int layoutFrom, int layoutTo, QFixed width)
+{
+    LDEBUG << "layoutFlow from=" << layoutFrom << "to=" << layoutTo;
+    TextFrameData *fd = data(layoutStruct->frame);
+
+    fd->currentLayoutStruct = layoutStruct;
+
+    QTextFrameIterator previousIt;
+
+    const bool inRootFrame = (it.parentFrame() == document->rootFrame());
+    if (inRootFrame) {
+        bool redoCheckPoints = layoutStruct->fullLayout || checkPoints.isEmpty();
+
+        if (!redoCheckPoints) {
+            QVector<CheckPoint>::Iterator checkPoint = std::lower_bound(checkPoints.begin(), checkPoints.end(), layoutFrom);
+            if (checkPoint != checkPoints.end()) {
+                if (checkPoint != checkPoints.begin())
+                    --checkPoint;
+
+                layoutStruct->y = checkPoint->y;
+                layoutStruct->frameY = checkPoint->frameY;
+                layoutStruct->minimumWidth = checkPoint->minimumWidth;
+                layoutStruct->maximumWidth = checkPoint->maximumWidth;
+                layoutStruct->contentsWidth = checkPoint->contentsWidth;
+
+                if (layoutStruct->pageHeight > 0) {
+                    int page = layoutStruct->currentPage();
+                    layoutStruct->pageBottom = (page + 1) * layoutStruct->pageHeight - layoutStruct->pageBottomMargin;
+                }
+
+                it = frameIteratorForTextPosition(checkPoint->positionInFrame);
+                checkPoints.resize(checkPoint - checkPoints.begin() + 1);
+
+                if (checkPoint != checkPoints.begin()) {
+                    previousIt = it;
+                    --previousIt;
+                }
+            } else {
+                redoCheckPoints = true;
+            }
+        }
+
+        if (redoCheckPoints) {
+            checkPoints.clear();
+            CheckPoint cp;
+            cp.y = layoutStruct->y;
+            cp.frameY = layoutStruct->frameY;
+            cp.positionInFrame = 0;
+            cp.minimumWidth = layoutStruct->minimumWidth;
+            cp.maximumWidth = layoutStruct->maximumWidth;
+            cp.contentsWidth = layoutStruct->contentsWidth;
+            checkPoints.append(cp);
+        }
+    }
+
+    QTextBlockFormat previousBlockFormat = previousIt.currentBlock().blockFormat();
+
+    QFixed maximumBlockWidth = 0;
+    while (!it.atEnd()) {
+        QTextFrame *c = it.currentFrame();
+
+        int docPos;
+        if (it.currentFrame())
+            docPos = it.currentFrame()->firstPosition();
+        else
+            docPos = it.currentBlock().position();
+
+        if (inRootFrame) {
+            if (qAbs(layoutStruct->y - checkPoints.constLast().y) > 2000) {
+                QFixed left, right;
+                floatMargins(layoutStruct->y, layoutStruct, &left, &right);
+                if (left == layoutStruct->x_left && right == layoutStruct->x_right) {
+                    CheckPoint p;
+                    p.y = layoutStruct->y;
+                    p.frameY = layoutStruct->frameY;
+                    p.positionInFrame = docPos;
+                    p.minimumWidth = layoutStruct->minimumWidth;
+                    p.maximumWidth = layoutStruct->maximumWidth;
+                    p.contentsWidth = layoutStruct->contentsWidth;
+                    checkPoints.append(p);
+
+                    if (currentLazyLayoutPosition != -1
+                        && docPos > currentLazyLayoutPosition + lazyLayoutStepSize)
+                        break;
+
+                }
+            }
+        }
+
+        if (c) {
+            // position child frame
+            TextFrameData *cd = data(c);
+
+            QTextFrameFormat fformat = c->frameFormat();
+
+            if (fformat.position() == QTextFrameFormat::InFlow) {
+                if (fformat.pageBreakPolicy() & QTextFormat::PageBreak_AlwaysBefore)
+                    layoutStruct->newPage();
+
+                QFixed left, right;
+                floatMargins(layoutStruct->y, layoutStruct, &left, &right);
+                left = qMax(left, layoutStruct->x_left);
+                right = qMin(right, layoutStruct->x_right);
+
+                if (right - left < cd->size.width) {
+                    layoutStruct->y = findY(layoutStruct->y, layoutStruct, cd->size.width);
+                    floatMargins(layoutStruct->y, layoutStruct, &left, &right);
+                }
+
+                QFixedPoint pos(left, layoutStruct->y);
+
+                Qt::Alignment align = Qt::AlignLeft;
+
+                // detect whether we have any alignment in the document that disallows optimizations,
+                // such as not laying out the document again in a textedit with wrapping disabled.
+                if (inRootFrame && !(align & Qt::AlignLeft))
+                    contentHasAlignment = true;
+
+                cd->position = pos;
+
+                if (document->pageSize().height() > 0.0f)
+                    cd->sizeDirty = true;
+
+                if (cd->sizeDirty) {
+                    if (width != 0)
+                        layoutFrame(c, layoutFrom, layoutTo, width, -1, layoutStruct->frameY);
+                    else
+                        layoutFrame(c, layoutFrom, layoutTo, layoutStruct->frameY);
+
+                    QFixed absoluteChildPos = pos.y + firstChildPos(c);
+                    absoluteChildPos += layoutStruct->frameY;
+
+                    // drop entire frame to next page if first child of frame is on next page
+                    if (absoluteChildPos > layoutStruct->pageBottom) {
+                        layoutStruct->newPage();
+                        pos.y = layoutStruct->y;
+
+                        cd->position = pos;
+                        cd->sizeDirty = true;
+
+                        if (width != 0)
+                            layoutFrame(c, layoutFrom, layoutTo, width, -1, layoutStruct->frameY);
+                        else
+                            layoutFrame(c, layoutFrom, layoutTo, layoutStruct->frameY);
+                    }
+                }
+
+                // align only if there is space for alignment
+                if (right - left > cd->size.width) {
+                    if (align & Qt::AlignRight)
+                        pos.x += layoutStruct->x_right - cd->size.width;
+                    else if (align & Qt::AlignHCenter)
+                        pos.x += (layoutStruct->x_right - cd->size.width) / 2;
+                }
+
+                cd->position = pos;
+
+                layoutStruct->y += cd->size.height;
+                const int page = layoutStruct->currentPage();
+                layoutStruct->pageBottom = (page + 1) * layoutStruct->pageHeight - layoutStruct->pageBottomMargin;
+
+                cd->layoutDirty = false;
+
+                if (c->frameFormat().pageBreakPolicy() & QTextFormat::PageBreak_AlwaysAfter)
+                    layoutStruct->newPage();
+            } else {
+                QRectF oldFrameRect(cd->position.toPointF(), cd->size.toSizeF());
+                QRectF updateRect;
+
+                if (cd->sizeDirty)
+                    updateRect = layoutFrame(c, layoutFrom, layoutTo);
+
+                positionFloat(c);
+
+                // If the size was made dirty when the position was set, layout again
+                if (cd->sizeDirty)
+                    updateRect = layoutFrame(c, layoutFrom, layoutTo);
+
+                QRectF frameRect(cd->position.toPointF(), cd->size.toSizeF());
+
+                if (frameRect == oldFrameRect && updateRect.isValid())
+                    updateRect.translate(cd->position.toPointF());
+                else
+                    updateRect = frameRect;
+
+                layoutStruct->addUpdateRectForFloat(updateRect);
+                if (oldFrameRect.isValid())
+                    layoutStruct->addUpdateRectForFloat(oldFrameRect);
+            }
+
+            layoutStruct->minimumWidth = qMax(layoutStruct->minimumWidth, cd->minimumWidth);
+            layoutStruct->maximumWidth = qMin(layoutStruct->maximumWidth, cd->maximumWidth);
+
+            previousIt = it;
+            ++it;
+        } else {
+            QTextFrameIterator lastIt;
+            if (!previousIt.atEnd() && previousIt != it)
+                lastIt = previousIt;
+            previousIt = it;
+            QTextBlock block = it.currentBlock();
+            ++it;
+
+            const QTextBlockFormat blockFormat = block.blockFormat();
+
+            if (blockFormat.pageBreakPolicy() & QTextFormat::PageBreak_AlwaysBefore)
+                layoutStruct->newPage();
+
+            const QFixed origY = layoutStruct->y;
+            const QFixed origPageBottom = layoutStruct->pageBottom;
+            const QFixed origMaximumWidth = layoutStruct->maximumWidth;
+            layoutStruct->maximumWidth = 0;
+
+            const QTextBlockFormat *previousBlockFormatPtr = 0;
+            if (lastIt.currentBlock().isValid())
+                previousBlockFormatPtr = &previousBlockFormat;
+
+            // layout and position child block
+            layoutBlock(block, docPos, blockFormat, layoutStruct, layoutFrom, layoutTo, previousBlockFormatPtr);
+
+            // detect whether we have any alignment in the document that disallows optimizations,
+            // such as not laying out the document again in a textedit with wrapping disabled.
+            if (inRootFrame && !(block.layout()->textOption().alignment() & Qt::AlignLeft))
+                contentHasAlignment = true;
+
+            if (blockFormat.pageBreakPolicy() & QTextFormat::PageBreak_AlwaysAfter)
+                layoutStruct->newPage();
+
+
+            maximumBlockWidth = qMax(maximumBlockWidth, layoutStruct->maximumWidth);
+            layoutStruct->maximumWidth = origMaximumWidth;
+            previousBlockFormat = blockFormat;
+        }
+    }
+    if (layoutStruct->maximumWidth == QFIXED_MAX && maximumBlockWidth > 0)
+        layoutStruct->maximumWidth = maximumBlockWidth;
+    else
+        layoutStruct->maximumWidth = qMax(layoutStruct->maximumWidth, maximumBlockWidth);
+
+    if (inRootFrame) {
+        // we assume that any float is aligned in a way that disallows the optimizations that rely
+        // on unaligned content.
+        if (!fd->floats.isEmpty())
+            contentHasAlignment = true;
+
+        if (it.atEnd()) {
+            currentLazyLayoutPosition = -1;
+            CheckPoint cp;
+            cp.y = layoutStruct->y;
+            cp.positionInFrame = docPrivate->length();
+            cp.minimumWidth = layoutStruct->minimumWidth;
+            cp.maximumWidth = layoutStruct->maximumWidth;
+            cp.contentsWidth = layoutStruct->contentsWidth;
+            checkPoints.append(cp);
+            checkPoints.reserve(checkPoints.size());
+        } else {
+            currentLazyLayoutPosition = checkPoints.constLast().positionInFrame;
+            // #######
+            //checkPoints.last().positionInFrame = q->document()->docHandle()->length();
+        }
+    }
+
+
+    fd->currentLayoutStruct = 0;
+}
+
+static inline void getLineHeightParams(const QTextBlockFormat &blockFormat, const QTextLine &line, qreal scaling,
+                                       QFixed *lineAdjustment, QFixed *lineBreakHeight, QFixed *lineHeight)
+{
+    *lineHeight = QFixed::fromReal(blockFormat.lineHeight(line.height(), scaling));
+
+    if (blockFormat.lineHeightType() == QTextBlockFormat::FixedHeight || blockFormat.lineHeightType() == QTextBlockFormat::MinimumHeight) {
+        *lineBreakHeight = *lineHeight;
+        if (blockFormat.lineHeightType() == QTextBlockFormat::FixedHeight)
+            *lineAdjustment = QFixed::fromReal(line.ascent() + qMax(line.leading(), qreal(0.0))) - ((*lineHeight * 4) / 5);
+        else
+            *lineAdjustment = QFixed::fromReal(line.height()) - *lineHeight;
+    }
+    else {
+        *lineBreakHeight = QFixed::fromReal(line.height());
+        *lineAdjustment = 0;
+    }
+}
+
+void TextDocumentLayoutPrivate::layoutBlock(const QTextBlock &bl, int blockPosition, const QTextBlockFormat &blockFormat,
+                                             TextLayoutStruct *layoutStruct, int layoutFrom, int layoutTo, const QTextBlockFormat *previousBlockFormat)
+{
+    Q_Q(TextDocumentLayout);
+    if (!bl.isVisible())
+        return;
+
+    QTextLayout *tl = bl.layout();
+    const int blockLength = bl.length();
+
+    LDEBUG << "layoutBlock from=" << layoutFrom << "to=" << layoutTo;
+
+
+    if (previousBlockFormat) {
+        qreal margin = qMax(blockFormat.topMargin(), previousBlockFormat->bottomMargin());
+        if (margin > 0 && q->paintDevice()) {
+            margin *= qreal(q->paintDevice()->logicalDpiY()) / qreal(qt_defaultDpi());
+        }
+        layoutStruct->y += QFixed::fromReal(margin);
+    }
+
+    //TextFrameData *fd = data(layoutStruct->frame);
+
+    Qt::LayoutDirection dir = bl.textDirection();
+
+    QFixed extraMargin;
+    if (docPrivate->defaultTextOption.flags() & QTextOption::AddSpaceForLineAndParagraphSeparators) {
+        QFontMetricsF fm(bl.charFormat().font());
+#if (QT_VERSION > QT_VERSION_CHECK(5,10,0))
+        extraMargin = QFixed::fromReal(fm.horizontalAdvance(QChar(QChar(0x21B5))));
+#else
+        extraMargin = QFixed::fromReal(fm.width(QChar(QChar(0x21B5))));
+#endif
+    }
+
+    const QFixed indent = this->blockIndent(blockFormat);
+    const QFixed totalLeftMargin = QFixed::fromReal(blockFormat.leftMargin()) + (dir == Qt::RightToLeft ? extraMargin : indent);
+    const QFixed totalRightMargin = QFixed::fromReal(blockFormat.rightMargin()) + (dir == Qt::RightToLeft ? indent : extraMargin);
+
+    const QPointF oldPosition = tl->position();
+    tl->setPosition(QPointF(layoutStruct->x_left.toReal(), layoutStruct->y.toReal()));
+
+    if (layoutStruct->fullLayout
+        || (blockPosition + blockLength > layoutFrom && blockPosition <= layoutTo)
+        // force relayout if we cross a page boundary
+        || (layoutStruct->pageHeight != QFIXED_MAX && layoutStruct->absoluteY() + QFixed::fromReal(tl->boundingRect().height()) > layoutStruct->pageBottom)) {
+
+        LDEBUG << " do layout";
+        QTextOption option = docPrivate->defaultTextOption;
+        option.setTextDirection(dir);
+        option.setTabs( blockFormat.tabPositions() );
+
+        Qt::Alignment align = docPrivate->defaultTextOption.alignment();
+        if (blockFormat.hasProperty(QTextFormat::BlockAlignment))
+            align = blockFormat.alignment();
+
+        Qt::Alignment alres = align;
+        if (!(alres & Qt::AlignHorizontal_Mask))
+            alres |= Qt::AlignLeft;
+        if (!(alres & Qt::AlignAbsolute) && (alres & (Qt::AlignLeft | Qt::AlignRight))) {
+            if (dir == Qt::RightToLeft)
+                alres ^= (Qt::AlignLeft | Qt::AlignRight);
+            alres |= Qt::AlignAbsolute;
+        }
+
+        option.setAlignment(alres); // for paragraph that are RTL, alignment is auto-reversed;
+
+        if (blockFormat.nonBreakableLines() || document->pageSize().width() < 0) {
+            option.setWrapMode(QTextOption::ManualWrap);
+        }
+
+        tl->setTextOption(option);
+
+        const bool haveWordOrAnyWrapMode = (option.wrapMode() == QTextOption::WrapAtWordBoundaryOrAnywhere);
+
+        const QFixed cy = layoutStruct->y;
+        const QFixed l = layoutStruct->x_left  + totalLeftMargin;
+        const QFixed r = layoutStruct->x_right - totalRightMargin;
+
+        tl->beginLayout();
+        bool firstLine = true;
+        while (1) {
+            QTextLine line = tl->createLine();
+            if (!line.isValid())
+                break;
+            line.setLeadingIncluded(true);
+
+            QFixed left, right;
+            floatMargins(layoutStruct->y, layoutStruct, &left, &right);
+            left = qMax(left, l);
+            right = qMin(right, r);
+            QFixed text_indent;
+            if (firstLine) {
+                text_indent = QFixed::fromReal(blockFormat.textIndent());
+                if (dir == Qt::LeftToRight)
+                    left += text_indent;
+                else
+                    right -= text_indent;
+                firstLine = false;
+            }
+
+            if (fixedColumnWidth != -1)
+                line.setNumColumns(fixedColumnWidth, (right - left).toReal());
+            else
+                line.setLineWidth((right - left).toReal());
+
+            floatMargins(layoutStruct->y, layoutStruct, &left, &right);
+            left = qMax(left, l);
+            right = qMin(right, r);
+            if (dir == Qt::LeftToRight)
+                left += text_indent;
+            else
+                right -= text_indent;
+
+            if (fixedColumnWidth == -1 && QFixed::fromReal(line.naturalTextWidth()) > right-left) {
+                // float has been added in the meantime, redo
+                layoutStruct->pendingFloats.clear();
+
+                line.setLineWidth((right-left).toReal());
+                if (QFixed::fromReal(line.naturalTextWidth()) > right-left) {
+                    if (haveWordOrAnyWrapMode) {
+                        option.setWrapMode(QTextOption::WrapAnywhere);
+                        tl->setTextOption(option);
+                    }
+
+                    layoutStruct->pendingFloats.clear();
+                    // lines min width more than what we have
+                    layoutStruct->y = findY(layoutStruct->y, layoutStruct, QFixed::fromReal(line.naturalTextWidth()));
+                    floatMargins(layoutStruct->y, layoutStruct, &left, &right);
+                    left = qMax(left, l);
+                    right = qMin(right, r);
+                    if (dir == Qt::LeftToRight)
+                        left += text_indent;
+                    else
+                        right -= text_indent;
+                    line.setLineWidth(qMax<qreal>(line.naturalTextWidth(), (right-left).toReal()));
+
+                    if (haveWordOrAnyWrapMode) {
+                        option.setWrapMode(QTextOption::WordWrap);
+                        tl->setTextOption(option);
+                    }
+                }
+
+            }
+
+            QFixed lineBreakHeight, lineHeight, lineAdjustment;
+            qreal scaling = (q->paintDevice() && q->paintDevice()->logicalDpiY() != qt_defaultDpi()) ?
+                            qreal(q->paintDevice()->logicalDpiY()) / qreal(qt_defaultDpi()) : 1;
+            getLineHeightParams(blockFormat, line, scaling, &lineAdjustment, &lineBreakHeight, &lineHeight);
+
+            if (layoutStruct->pageHeight > 0 && layoutStruct->absoluteY() + lineBreakHeight > layoutStruct->pageBottom) {
+                layoutStruct->newPage();
+
+                floatMargins(layoutStruct->y, layoutStruct, &left, &right);
+                left = qMax(left, l);
+                right = qMin(right, r);
+                if (dir == Qt::LeftToRight)
+                    left += text_indent;
+                else
+                    right -= text_indent;
+            }
+
+            line.setPosition(QPointF((left - layoutStruct->x_left).toReal(), (layoutStruct->y - cy - lineAdjustment).toReal()));
+            layoutStruct->y += lineHeight;
+            layoutStruct->contentsWidth
+                = qMax<QFixed>(layoutStruct->contentsWidth, QFixed::fromReal(line.x() + line.naturalTextWidth()) + totalRightMargin);
+
+            // position floats
+            for (int i = 0; i < layoutStruct->pendingFloats.size(); ++i) {
+                QTextFrame *f = layoutStruct->pendingFloats.at(i);
+                positionFloat(f);
+            }
+            layoutStruct->pendingFloats.clear();
+        }
+        tl->endLayout();
+    } else {
+        const int cnt = tl->lineCount();
+        for (int i = 0; i < cnt; ++i) {
+            LDEBUG << "going to move text line" << i;
+            QTextLine line = tl->lineAt(i);
+            layoutStruct->contentsWidth
+                = qMax(layoutStruct->contentsWidth, QFixed::fromReal(line.x() + tl->lineAt(i).naturalTextWidth()) + totalRightMargin);
+
+            QFixed lineBreakHeight, lineHeight, lineAdjustment;
+            qreal scaling = (q->paintDevice() && q->paintDevice()->logicalDpiY() != qt_defaultDpi()) ?
+                            qreal(q->paintDevice()->logicalDpiY()) / qreal(qt_defaultDpi()) : 1;
+            getLineHeightParams(blockFormat, line, scaling, &lineAdjustment, &lineBreakHeight, &lineHeight);
+
+            if (layoutStruct->pageHeight != QFIXED_MAX) {
+                if (layoutStruct->absoluteY() + lineBreakHeight > layoutStruct->pageBottom)
+                    layoutStruct->newPage();
+                line.setPosition(QPointF(line.position().x(), (layoutStruct->y - lineAdjustment).toReal() - tl->position().y()));
+            }
+            layoutStruct->y += lineHeight;
+        }
+        if (layoutStruct->updateRect.isValid()
+            && blockLength > 1) {
+            if (layoutFrom >= blockPosition + blockLength) {
+                // if our height didn't change and the change in the document is
+                // in one of the later paragraphs, then we don't need to repaint
+                // this one
+                layoutStruct->updateRect.setTop(qMax(layoutStruct->updateRect.top(), layoutStruct->y.toReal()));
+            } else if (layoutTo < blockPosition) {
+                if (oldPosition == tl->position())
+                    // if the change in the document happened earlier in the document
+                    // and our position did /not/ change because none of the earlier paragraphs
+                    // or frames changed their height, then we don't need to repaint
+                    // this one
+                    layoutStruct->updateRect.setBottom(qMin(layoutStruct->updateRect.bottom(), tl->position().y()));
+                else
+                    layoutStruct->updateRect.setBottom(qreal(INT_MAX)); // reset
+            }
+        }
+    }
+
+    // ### doesn't take floats into account. would need to do it per line. but how to retrieve then? (Simon)
+    const QFixed margins = totalLeftMargin + totalRightMargin;
+    layoutStruct->minimumWidth = qMax(layoutStruct->minimumWidth, QFixed::fromReal(tl->minimumWidth()) + margins);
+
+    const QFixed maxW = QFixed::fromReal(tl->maximumWidth()) + margins;
+
+    if (maxW > 0) {
+        if (layoutStruct->maximumWidth == QFIXED_MAX)
+            layoutStruct->maximumWidth = maxW;
+        else
+            layoutStruct->maximumWidth = qMax(layoutStruct->maximumWidth, maxW);
+    }
+}
+
+void TextDocumentLayoutPrivate::floatMargins(const QFixed &y, const TextLayoutStruct *layoutStruct,
+                                              QFixed *left, QFixed *right) const
+{
+    *left = layoutStruct->x_left;
+    *right = layoutStruct->x_right;
+    TextFrameData *lfd = data(layoutStruct->frame);
+    for (int i = 0; i < lfd->floats.size(); ++i) {
+        TextFrameData *fd = data(lfd->floats.at(i));
+        if (!fd->layoutDirty) {
+            if (fd->position.y <= y && fd->position.y + fd->size.height > y) {
+                if (lfd->floats.at(i)->frameFormat().position() == QTextFrameFormat::FloatLeft)
+                    *left = qMax(*left, fd->position.x + fd->size.width);
+                else
+                    *right = qMin(*right, fd->position.x);
+            }
+        }
+    }
+}
+
+QFixed TextDocumentLayoutPrivate::findY(QFixed yFrom, const TextLayoutStruct *layoutStruct, QFixed requiredWidth) const
+{
+    QFixed right, left;
+    requiredWidth = qMin(requiredWidth, layoutStruct->x_right - layoutStruct->x_left);
+
+    while (1) {
+        floatMargins(yFrom, layoutStruct, &left, &right);
+        if (right-left >= requiredWidth)
+            break;
+
+        // move float down until we find enough space
+        QFixed newY = QFIXED_MAX;
+        TextFrameData *lfd = data(layoutStruct->frame);
+        for (int i = 0; i < lfd->floats.size(); ++i) {
+            TextFrameData *fd = data(lfd->floats.at(i));
+            if (!fd->layoutDirty) {
+                if (fd->position.y <= yFrom && fd->position.y + fd->size.height > yFrom)
+                    newY = qMin(newY, fd->position.y + fd->size.height);
+            }
+        }
+        if (newY == QFIXED_MAX)
+            break;
+        yFrom = newY;
+    }
+    return yFrom;
+}
+
+TextDocumentLayout::TextDocumentLayout(QTextDocument *doc)
+    : QAbstractTextDocumentLayout(*new TextDocumentLayoutPrivate, doc){}
+
+
+void TextDocumentLayout::draw(QPainter *painter, const PaintContext &context)
+{
+    Q_D(TextDocumentLayout);
+    QTextFrame *frame = d->document->rootFrame();
+    TextFrameData *fd = data(frame);
+
+    if(fd->sizeDirty)
+        return;
+
+    if (context.clip.isValid()) {
+        d->ensureLayouted(QFixed::fromReal(context.clip.bottom()));
+    } else {
+        d->ensureLayoutFinished();
+    }
+
+    QFixed width = fd->size.width;
+    if (d->document->pageSize().width() == 0 && d->viewportRect.isValid()) {
+        // we're in NoWrap mode, meaning the frame should expand to the viewport
+        // so that backgrounds are drawn correctly
+        fd->size.width = qMax(width, QFixed::fromReal(d->viewportRect.right()));
+    }
+
+    // Make sure we conform to the root frames bounds when drawing.
+    d->clipRect = QRectF(fd->position.toPointF(), fd->size.toSizeF()).adjusted(fd->leftMargin.toReal(), 0, -fd->rightMargin.toReal(), 0);
+    d->drawFrame(QPointF(), painter, context, frame);
+    fd->size.width = width;
+}
+
+void TextDocumentLayout::setViewport(const QRectF &viewport)
+{
+    Q_D(TextDocumentLayout);
+    d->viewportRect = viewport;
+}
+
+static void markFrames(QTextFrame *current, int from, int oldLength, int length)
+{
+    int end = qMax(oldLength, length) + from;
+
+    if (current->firstPosition() >= end || current->lastPosition() < from)
+        return;
+
+    TextFrameData *fd = data(current);
+    // float got removed in editing operation
+    QTextFrame *null = nullptr; // work-around for (at least) MSVC 2012 emitting
+                                // warning C4100 for its own header <algorithm>
+                                // when passing nullptr directly to std::remove
+    fd->floats.erase(std::remove(fd->floats.begin(), fd->floats.end(), null),
+                     fd->floats.end());
+
+    fd->layoutDirty = true;
+    fd->sizeDirty = true;
+
+    QList<QTextFrame *> children = current->childFrames();
+    for (int i = 0; i < children.size(); ++i)
+        markFrames(children.at(i), from, oldLength, length);
+}
+
+void TextDocumentLayout::documentChanged(int from, int oldLength, int length)
+{
+    Q_D(TextDocumentLayout);
+
+    QTextBlock startIt = document()->findBlock(from);
+    QTextBlock endIt = document()->findBlock(qMax(0, from + length - 1));
+    if (endIt.isValid())
+        endIt = endIt.next();
+    for (QTextBlock blockIt = startIt; blockIt.isValid() && blockIt != endIt; blockIt = blockIt.next())
+        blockIt.clearLayout();
+
+    if (d->docPrivate->pageSize.isNull())
+        return;
+
+    QRectF updateRect;
+
+    d->lazyLayoutStepSize = 1000;
+    d->sizeChangedTimer.stop();
+    d->insideDocumentChange = true;
+
+    const int documentLength = d->docPrivate->length();
+    const bool fullLayout = (oldLength == 0 && length == documentLength);
+    const bool smallChange = documentLength > 0
+                             && (qMax(length, oldLength) * 100 / documentLength) < 5;
+
+    // don't show incremental layout progress (avoid scroll bar flicker)
+    // if we see only a small change in the document and we're either starting
+    // a layout run or we're already in progress for that and we haven't seen
+    // any bigger change previously (showLayoutProgress already false)
+    if (smallChange
+        && (d->currentLazyLayoutPosition == -1 || d->showLayoutProgress == false))
+        d->showLayoutProgress = false;
+    else
+        d->showLayoutProgress = true;
+
+    if (fullLayout) {
+        d->contentHasAlignment = false;
+        d->currentLazyLayoutPosition = 0;
+        d->checkPoints.clear();
+        d->layoutStep();
+    } else {
+        d->ensureLayoutedByPosition(from);
+        updateRect = doLayout(from, oldLength, length);
+    }
+
+    if (!d->layoutTimer.isActive() && d->currentLazyLayoutPosition != -1)
+        d->layoutTimer.start(10, this);
+
+    d->insideDocumentChange = false;
+
+    for (QTextBlock blockIt = startIt; blockIt.isValid() && blockIt != endIt; blockIt = blockIt.next())
+        emit updateBlock(blockIt);
+
+    if (d->showLayoutProgress) {
+        const QSizeF newSize = dynamicDocumentSize();
+        if (newSize != d->lastReportedSize) {
+            d->lastReportedSize = newSize;
+            emit documentSizeChanged(newSize);
+        }
+    }
+
+    if (!updateRect.isValid()) {
+        // don't use the frame size, it might have shrunken
+        updateRect = QRectF(QPointF(0, 0), QSizeF(qreal(INT_MAX), qreal(INT_MAX)));
+    }
+
+    emit update(updateRect);
+}
+
+QRectF TextDocumentLayout::doLayout(int from, int oldLength, int length)
+{
+    Q_D(TextDocumentLayout);
+
+
+    // mark all frames between f_start and f_end as dirty
+    markFrames(d->document->rootFrame(), from, oldLength, length);
+
+    QRectF updateRect;
+
+    QTextFrame *root = d->document->rootFrame();
+    if(data(root)->sizeDirty)
+        updateRect = d->layoutFrame(root, from, from + length);
+    data(root)->layoutDirty = false;
+
+    if (d->currentLazyLayoutPosition == -1)
+        layoutFinished();
+    else if (d->showLayoutProgress)
+        d->sizeChangedTimer.start(0, this);
+
+    return updateRect;
+}
+
+int TextDocumentLayout::hitTest(const QPointF &point, Qt::HitTestAccuracy accuracy) const
+{
+    Q_D(const TextDocumentLayout);
+    d->ensureLayouted(QFixed::fromReal(point.y()));
+    QTextFrame *f = d->document->rootFrame();
+    int position = 0;
+    QTextLayout *l = 0;
+    QFixedPoint pointf;
+    pointf.x = QFixed::fromReal(point.x());
+    pointf.y = QFixed::fromReal(point.y());
+    TextDocumentLayoutPrivate::HitPoint p = d->hitTest(f, pointf, &position, &l, accuracy);
+    if (accuracy == Qt::ExactHit && p < TextDocumentLayoutPrivate::PointExact)
+        return -1;
+
+    // ensure we stay within document bounds
+    int lastPos = f->lastPosition();
+    if (l && !l->preeditAreaText().isEmpty())
+        lastPos += l->preeditAreaText().length();
+    if (position > lastPos)
+        position = lastPos;
+    else if (position < 0)
+        position = 0;
+
+    return position;
+}
+
+void TextDocumentLayout::resizeInlineObject(QTextInlineObject item, int posInDocument, const QTextFormat &format)
+{
+    Q_D(TextDocumentLayout);
+    QTextCharFormat f = format.toCharFormat();
+    Q_ASSERT(f.isValid());
+    QTextObjectHandler handler = d->handlers.value(f.objectType());
+    if (!handler.component)
+        return;
+
+    QSizeF intrinsic = handler.iface->intrinsicSize(d->document, posInDocument, format);
+
+    QTextFrameFormat::Position pos = QTextFrameFormat::InFlow;
+    QTextFrame *frame = qobject_cast<QTextFrame *>(d->document->objectForFormat(f));
+    if (frame) {
+        pos = frame->frameFormat().position();
+        TextFrameData *fd = data(frame);
+        fd->sizeDirty = false;
+        fd->size = QFixedSize::fromSizeF(intrinsic);
+        fd->minimumWidth = fd->maximumWidth = fd->size.width;
+    }
+
+    QSizeF inlineSize = (pos == QTextFrameFormat::InFlow ? intrinsic : QSizeF(0, 0));
+    item.setWidth(inlineSize.width());
+
+    QFontMetrics m(f.font());
+    switch (f.verticalAlignment())
+    {
+    case QTextCharFormat::AlignMiddle:
+        item.setDescent(inlineSize.height() / 2);
+        item.setAscent(inlineSize.height() / 2);
+        break;
+    case QTextCharFormat::AlignBaseline:
+        item.setDescent(m.descent());
+        item.setAscent(inlineSize.height() - m.descent());
+        break;
+    default:
+        item.setDescent(0);
+        item.setAscent(inlineSize.height());
+    }
+}
+
+void TextDocumentLayout::positionInlineObject(QTextInlineObject item, int posInDocument, const QTextFormat &format)
+{
+    Q_D(TextDocumentLayout);
+    Q_UNUSED(posInDocument);
+    if (item.width() != 0)
+        // inline
+        return;
+
+    QTextCharFormat f = format.toCharFormat();
+    Q_ASSERT(f.isValid());
+    QTextObjectHandler handler = d->handlers.value(f.objectType());
+    if (!handler.component)
+        return;
+
+    QTextFrame *frame = qobject_cast<QTextFrame *>(d->document->objectForFormat(f));
+    if (!frame)
+        return;
+
+    QTextBlock b = d->document->findBlock(frame->firstPosition());
+    QTextLine line;
+    if (b.position() <= frame->firstPosition() && b.position() + b.length() > frame->lastPosition())
+        line = b.layout()->lineAt(b.layout()->lineCount()-1);
+
+    d->positionFloat(frame, line.isValid() ? &line : 0);
+}
+
+void TextDocumentLayout::drawInlineObject(QPainter *p, const QRectF &rect, QTextInlineObject item,
+                                           int posInDocument, const QTextFormat &format)
+{
+    Q_D(TextDocumentLayout);
+    QTextCharFormat f = format.toCharFormat();
+    Q_ASSERT(f.isValid());
+    QTextFrame *frame = qobject_cast<QTextFrame *>(d->document->objectForFormat(f));
+    if (frame && frame->frameFormat().position() != QTextFrameFormat::InFlow)
+        return; // don't draw floating frames from inline objects here but in drawFlow instead
+
+    QAbstractTextDocumentLayout::drawInlineObject(p, rect, item, posInDocument, format);
+}
+
+int TextDocumentLayout::dynamicPageCount() const
+{
+    Q_D(const TextDocumentLayout);
+    const QSizeF pgSize = d->document->pageSize();
+    if (pgSize.height() < 0)
+        return 1;
+    return qCeil(dynamicDocumentSize().height() / pgSize.height());
+}
+
+QSizeF TextDocumentLayout::dynamicDocumentSize() const
+{
+    Q_D(const TextDocumentLayout);
+    return data(d->document->rootFrame())->size.toSizeF();
+}
+
+int TextDocumentLayout::pageCount() const
+{
+    Q_D(const TextDocumentLayout);
+    d->ensureLayoutFinished();
+    return dynamicPageCount();
+}
+
+QSizeF TextDocumentLayout::documentSize() const
+{
+    Q_D(const TextDocumentLayout);
+    d->ensureLayoutFinished();
+    return dynamicDocumentSize();
+}
+
+void TextDocumentLayoutPrivate::ensureLayouted(QFixed y) const
+{
+    Q_Q(const TextDocumentLayout);
+    if (currentLazyLayoutPosition == -1)
+        return;
+    const QSizeF oldSize = q->dynamicDocumentSize();
+    Q_UNUSED(oldSize);
+
+    if (checkPoints.isEmpty())
+        layoutStep();
+
+    while (currentLazyLayoutPosition != -1
+           && checkPoints.last().y < y)
+        layoutStep();
+}
+
+void TextDocumentLayoutPrivate::ensureLayoutedByPosition(int position) const
+{
+    if (currentLazyLayoutPosition == -1)
+        return;
+    if (position < currentLazyLayoutPosition)
+        return;
+    while (currentLazyLayoutPosition != -1
+           && currentLazyLayoutPosition < position) {
+        const_cast<TextDocumentLayout *>(q_func())->doLayout(currentLazyLayoutPosition, 0, INT_MAX - currentLazyLayoutPosition);
+    }
+}
+
+void TextDocumentLayoutPrivate::layoutStep() const
+{
+    ensureLayoutedByPosition(currentLazyLayoutPosition + lazyLayoutStepSize);
+    lazyLayoutStepSize = qMin(200000, lazyLayoutStepSize * 2);
+}
+
+void TextDocumentLayout::setCursorWidth(int width)
+{
+    Q_D(TextDocumentLayout);
+    d->cursorWidth = width;
+}
+
+int TextDocumentLayout::cursorWidth() const
+{
+    Q_D(const TextDocumentLayout);
+    return d->cursorWidth;
+}
+
+void TextDocumentLayout::setFixedColumnWidth(int width)
+{
+    Q_D(TextDocumentLayout);
+    d->fixedColumnWidth = width;
+}
+
+QRectF TextDocumentLayout::frameBoundingRect(QTextFrame *frame) const
+{
+    Q_D(const TextDocumentLayout);
+    if (d->docPrivate->pageSize.isNull())
+        return QRectF();
+    d->ensureLayoutFinished();
+    return d->frameBoundingRectInternal(frame);
+}
+
+QRectF TextDocumentLayoutPrivate::frameBoundingRectInternal(QTextFrame *frame) const
+{
+    QPointF pos;
+    const int framePos = frame->firstPosition();
+    QTextFrame *f = frame;
+    while (f) {
+        TextFrameData *fd = data(f);
+        pos += fd->position.toPointF();
+
+        f = f->parentFrame();
+    }
+    return QRectF(pos, data(frame)->size.toSizeF());
+}
+
+QRectF TextDocumentLayout::blockBoundingRect(const QTextBlock &block) const
+{
+    Q_D(const TextDocumentLayout);
+    if (d->docPrivate->pageSize.isNull() || !block.isValid() || !block.isVisible())
+        return QRectF();
+    d->ensureLayoutedByPosition(block.position() + block.length());
+    QTextFrame *frame = d->document->frameAt(block.position());
+    QPointF offset;
+
+    while (frame) {
+        TextFrameData *fd = data(frame);
+        offset += fd->position.toPointF();
+
+        frame = frame->parentFrame();
+    }
+
+    const QTextLayout *layout = block.layout();
+    QRectF rect = layout->boundingRect();
+    rect.moveTopLeft(layout->position() + offset);
+    return rect;
+}
+
+int TextDocumentLayout::layoutStatus() const
+{
+    Q_D(const TextDocumentLayout);
+    int pos = d->currentLazyLayoutPosition;
+    if (pos == -1)
+        return 100;
+    return pos * 100 / d->document->docHandle()->length();
+}
+
+void TextDocumentLayout::timerEvent(QTimerEvent *e)
+{
+    Q_D(TextDocumentLayout);
+    if (e->timerId() == d->layoutTimer.timerId()) {
+        if (d->currentLazyLayoutPosition != -1)
+            d->layoutStep();
+    } else if (e->timerId() == d->sizeChangedTimer.timerId()) {
+        d->lastReportedSize = dynamicDocumentSize();
+        emit documentSizeChanged(d->lastReportedSize);
+        d->sizeChangedTimer.stop();
+
+        if (d->currentLazyLayoutPosition == -1) {
+            const int newCount = dynamicPageCount();
+            if (newCount != d->lastPageCount) {
+                d->lastPageCount = newCount;
+                emit pageCountChanged(newCount);
+            }
+        }
+    } else {
+        QAbstractTextDocumentLayout::timerEvent(e);
+    }
+}
+
+void TextDocumentLayout::layoutFinished()
+{
+    Q_D(TextDocumentLayout);
+    d->layoutTimer.stop();
+    if (!d->insideDocumentChange)
+        d->sizeChangedTimer.start(0, this);
+    // reset
+    d->showLayoutProgress = true;
+}
+
+void TextDocumentLayout::ensureLayouted(qreal y)
+{
+    d_func()->ensureLayouted(QFixed::fromReal(y));
+}
+
+qreal TextDocumentLayout::idealWidth() const
+{
+    Q_D(const TextDocumentLayout);
+    d->ensureLayoutFinished();
+    return d->idealWidth;
+}
+
+bool TextDocumentLayout::contentHasAlignment() const
+{
+    Q_D(const TextDocumentLayout);
+    return d->contentHasAlignment;
+}
+
+qreal TextDocumentLayoutPrivate::scaleToDevice(qreal value) const
+{
+    if (!paintDevice)
+        return value;
+    return value * paintDevice->logicalDpiY() / qreal(qt_defaultDpi());
+}
+
+QFixed TextDocumentLayoutPrivate::scaleToDevice(QFixed value) const
+{
+    if (!paintDevice)
+        return value;
+    return value * QFixed(paintDevice->logicalDpiY()) / QFixed(qt_defaultDpi());
+}
+
+}
+
+#include "moc_textdocumentlayout.cpp"
diff --git a/lib/lveditor/3rdparty/textdocumentlayout.h b/lib/lveditor/3rdparty/textdocumentlayout.h
index 64713ba..65e87ae 100644
--- a/lib/lveditor/3rdparty/textdocumentlayout.h
+++ b/lib/lveditor/3rdparty/textdocumentlayout.h
@@ -1,140 +1,118 @@
-/****************************************************************************
-**
-** Copyright (C) 2016 The Qt Company Ltd.
-** Contact: https://www.qt.io/licensing/
-**
-** This file is part of the QtGui module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and The Qt Company. For licensing terms
-** and conditions see https://www.qt.io/terms-conditions. For further
-** information use the contact form at https://www.qt.io/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 2.0 or (at your option) the GNU General
-** Public license version 3 or any later version approved by the KDE Free
-** Qt Foundation. The licenses are as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
-** included in the packaging of this file. Please review the following
-** information to ensure the GNU General Public License requirements will
-** be met: https://www.gnu.org/licenses/gpl-2.0.html and
-** https://www.gnu.org/licenses/gpl-3.0.html.
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef TEXTDOCUMENTLAYOUT_P_H
-#define TEXTDOCUMENTLAYOUT_P_H
-
-//
-//  W A R N I N G
-//  -------------
-//
-// This file is not part of the Qt API.  It exists purely as an
-// implementation detail.  This header file may change from version to
-// version without notice, or even be removed.
-//
-// We mean it.
-//
-
-#include "QtGui/qabstracttextdocumentlayout.h"
-#include "QtGui/qtextoption.h"
-#include "QtGui/qtextobject.h"
-#include "lveditorglobal.h"
-
-class QTextListFormat;
-
-namespace lv {
-
-class TextDocumentLayoutPrivate;
-class LineManager;
-
-class TextDocumentLayout : public QAbstractTextDocumentLayout
-{
-    Q_DECLARE_PRIVATE(TextDocumentLayout)
-    Q_OBJECT
-    Q_PROPERTY(int cursorWidth READ cursorWidth WRITE setCursorWidth)
-    Q_PROPERTY(qreal idealWidth READ idealWidth)
-    Q_PROPERTY(bool contentHasAlignment READ contentHasAlignment)
-public:
-    explicit TextDocumentLayout(QTextDocument *doc);
-
-    // from the abstract layout
-    void draw(QPainter *painter, const PaintContext &context) override;
-    int hitTest(const QPointF &point, Qt::HitTestAccuracy accuracy) const override;
-
-    int pageCount() const override;
-    QSizeF documentSize() const override;
-
-    void setCursorWidth(int width);
-    int cursorWidth() const;
-
-    // internal, to support the ugly FixedColumnWidth wordwrap mode in QTextEdit
-    void setFixedColumnWidth(int width);
-
-    // internal for QTextEdit's NoWrap mode
-    void setViewport(const QRectF &viewport);
-
-    virtual QRectF frameBoundingRect(QTextFrame *frame) const override;
-    virtual QRectF blockBoundingRect(const QTextBlock &block) const override;
-
-    // ####
-    int layoutStatus() const;
-    int dynamicPageCount() const;
-    QSizeF dynamicDocumentSize() const;
-    void ensureLayouted(qreal);
-
-    qreal idealWidth() const;
-
-    bool contentHasAlignment() const;
-
-    LineManager* getLineManager();
-    void stateChangeUpdate(int pos);
-
-
-    // line manager wrappers
-    QTextDocument* lineDocument();
-    void collapseLines(int pos, int len);
-    void expandLines(int pos, int len);
-    std::pair<int,int> isFirstLineOfCollapsedSection(int lineNumber);
-    std::pair<int,int> isLineAfterCollapsedSection(int lineNumber);
-    QTextDocument* lineManagerParentDocument();
-    void setLineManagerParentDocument(QTextDocument* doc);
-    void setLineDocumentFont(const QFont& font);
-
-    void setDirtyPos(int pos);
-    void textDocumentFinishedUpdating(int newLineNumber);
-    void updateLineSurface(int oldLineNum, int newLineNum, int dirtyPos);
-Q_SIGNALS:
-    void linesCollapsed(int pos, int len);
-    void linesExpanded(int pos, int len);
-    void updateLineSurfaceSignal(int oldLineNum, int newLineNum, int dirtyPos);
-protected:
-    void documentChanged(int from, int oldLength, int length) override;
-    void resizeInlineObject(QTextInlineObject item, int posInDocument, const QTextFormat &format) override;
-    void positionInlineObject(QTextInlineObject item, int posInDocument, const QTextFormat &format) override;
-    void drawInlineObject(QPainter *p, const QRectF &rect, QTextInlineObject item,
-                          int posInDocument, const QTextFormat &format) override;
-    virtual void timerEvent(QTimerEvent *e) override;
-private:
-    QRectF doLayout(int from, int oldLength, int length);
-    void layoutFinished();
-};
-
-}
-
-#endif // TEXTDOCUMENTLAYOUT_P_H
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtGui module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef TEXTDOCUMENTLAYOUT_P_H
+#define TEXTDOCUMENTLAYOUT_P_H
+
+//
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the Qt API.  It exists purely as an
+// implementation detail.  This header file may change from version to
+// version without notice, or even be removed.
+//
+// We mean it.
+//
+
+#include "QtGui/qabstracttextdocumentlayout.h"
+#include "QtGui/qtextoption.h"
+#include "QtGui/qtextobject.h"
+#include "lveditorglobal.h"
+
+class QTextListFormat;
+
+namespace lv {
+
+class TextDocumentLayoutPrivate;
+
+class TextDocumentLayout : public QAbstractTextDocumentLayout
+{
+    Q_DECLARE_PRIVATE(TextDocumentLayout)
+    Q_OBJECT
+    Q_PROPERTY(int cursorWidth READ cursorWidth WRITE setCursorWidth)
+    Q_PROPERTY(qreal idealWidth READ idealWidth)
+    Q_PROPERTY(bool contentHasAlignment READ contentHasAlignment)
+public:
+    explicit TextDocumentLayout(QTextDocument *doc);
+
+    // from the abstract layout
+    void draw(QPainter *painter, const PaintContext &context) override;
+    int hitTest(const QPointF &point, Qt::HitTestAccuracy accuracy) const override;
+
+    int pageCount() const override;
+    QSizeF documentSize() const override;
+
+    void setCursorWidth(int width);
+    int cursorWidth() const;
+
+    // internal, to support the ugly FixedColumnWidth wordwrap mode in QTextEdit
+    void setFixedColumnWidth(int width);
+
+    // internal for QTextEdit's NoWrap mode
+    void setViewport(const QRectF &viewport);
+
+    virtual QRectF frameBoundingRect(QTextFrame *frame) const override;
+    virtual QRectF blockBoundingRect(const QTextBlock &block) const override;
+
+    // ####
+    int layoutStatus() const;
+    int dynamicPageCount() const;
+    QSizeF dynamicDocumentSize() const;
+    void ensureLayouted(qreal);
+
+    qreal idealWidth() const;
+
+    bool contentHasAlignment() const;
+    void updateLineSurface(int oldLineNum, int newLineNum, int dirtyPos);
+protected:
+    void documentChanged(int from, int oldLength, int length) override;
+    void resizeInlineObject(QTextInlineObject item, int posInDocument, const QTextFormat &format) override;
+    void positionInlineObject(QTextInlineObject item, int posInDocument, const QTextFormat &format) override;
+    void drawInlineObject(QPainter *p, const QRectF &rect, QTextInlineObject item,
+                          int posInDocument, const QTextFormat &format) override;
+    virtual void timerEvent(QTimerEvent *e) override;
+private:
+    QRectF doLayout(int from, int oldLength, int length);
+    void layoutFinished();
+};
+
+}
+
+#endif // TEXTDOCUMENTLAYOUT_P_H
diff --git a/lib/lveditor/3rdparty/textedit.cpp b/lib/lveditor/3rdparty/textedit.cpp
index 424ec8a..bea5f3e 100644
--- a/lib/lveditor/3rdparty/textedit.cpp
+++ b/lib/lveditor/3rdparty/textedit.cpp
@@ -1,3657 +1,3733 @@
-/****************************************************************************
-**
-** Copyright (C) 2016 The Qt Company Ltd.
-** Contact: https://www.qt.io/licensing/
-**
-** This file is part of the QtQuick module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and The Qt Company. For licensing terms
-** and conditions see https://www.qt.io/terms-conditions. For further
-** information use the contact form at https://www.qt.io/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 2.0 or (at your option) the GNU General
-** Public license version 3 or any later version approved by the KDE Free
-** Qt Foundation. The licenses are as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
-** included in the packaging of this file. Please review the following
-** information to ensure the GNU General Public License requirements will
-** be met: https://www.gnu.org/licenses/gpl-2.0.html and
-** https://www.gnu.org/licenses/gpl-3.0.html.
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#include "textedit_p.h"
-#include "textedit_p_p.h"
-#include "textcontrol_p.h"
-#include "qquickwindow.h"
-#include "textnodeengine_p.h"
-#include "textutil_p.h"
-
-#include <QtCore/qmath.h>
-#include <QtGui/qguiapplication.h>
-#include <QtGui/qevent.h>
-#include <QtGui/qpainter.h>
-#include <QtGui/qtextobject.h>
-#include <QtGui/qtexttable.h>
-#include <QtQml/qqmlinfo.h>
-#include <QtQuick/qsgsimplerectnode.h>
-#include <QTimer>
-#include "textdocumentlayout.h"
-#include "linesurface.h"
-
-#include <QtGlobal>
-
-#if (QT_VERSION > QT_VERSION_CHECK(5,7,1))
-#include <QSGRectangleNode> // change for 5.11
-#endif
-
-#include "private/qquicktextnode_p.h"
-#include "private/qquickevents_p_p.h"
-#include "private/qqmlproperty_p.h"
-#include "private/qtextengine_p.h"
-#include "private/qsgadaptationlayer_p.h"
-
-#include <algorithm>
-
-#define LV_ACCURACY 1e-7
-#define lv_qmlobject_connect(Sender, SenderType, Signal, Receiver, ReceiverType, Method) \
-{ \
-    SenderType *sender = (Sender); \
-    ReceiverType *receiver = (Receiver); \
-    const char *signal = (Signal); \
-    const char *method = (Method); \
-    static int signalIdx = -1; \
-    static int methodIdx = -1; \
-    if (signalIdx < 0) { \
-        Q_ASSERT((static_cast<int>(*signal) - '0') == QSIGNAL_CODE); \
-        signalIdx = SenderType::staticMetaObject.indexOfSignal(signal+1); \
-    } \
-    if (methodIdx < 0) { \
-        int code = (static_cast<int>(*method) - '0'); \
-        Q_ASSERT(code == QSLOT_CODE || code == QSIGNAL_CODE); \
-        if (code == QSLOT_CODE) \
-            methodIdx = ReceiverType::staticMetaObject.indexOfSlot(method+1); \
-        else \
-            methodIdx = ReceiverType::staticMetaObject.indexOfSignal(method+1); \
-    } \
-    Q_ASSERT(signalIdx != -1 && methodIdx != -1); \
-    QMetaObject::connect(sender, signalIdx, receiver, methodIdx, Qt::DirectConnection); \
-}
-#define LV_IS_SIGNAL_CONNECTED(Sender, SenderType, Name, Arguments) \
-do { \
-    QObject *sender = (Sender); \
-    void (SenderType::*signal)Arguments = &SenderType::Name; \
-    static QMetaMethod method = QMetaMethod::fromSignal(signal); \
-    static uint signalIdx = static_cast<uint>(QMetaObjectPrivate::signalIndex(method)); \
-    return QObjectPrivate::get(sender)->isSignalConnected(signalIdx); \
-} while (0)
-
-namespace lv {
-
-/*!
-    \qmltype TextEdit
-    \instantiates QQuickTextEdit
-    \inqmlmodule QtQuick
-    \ingroup qtquick-visual
-    \ingroup qtquick-input
-    \inherits Item
-    \brief Displays multiple lines of editable formatted text
-
-    The TextEdit item displays a block of editable, formatted text.
-
-    It can display both plain and rich text. For example:
-
-    \qml
-TextEdit {
-    width: 240
-    text: "<b>Hello</b> <i>World!</i>"
-    font.family: "Helvetica"
-    font.pointSize: 20
-    color: "blue"
-    focus: true
-}
-    \endqml
-
-    \image declarative-textedit.gif
-
-    Setting \l {Item::focus}{focus} to \c true enables the TextEdit item to receive keyboard focus.
-
-    Note that the TextEdit does not implement scrolling, following the cursor, or other behaviors specific
-    to a look-and-feel. For example, to add flickable scrolling that follows the cursor:
-
-    \snippet qml/texteditor.qml 0
-
-    A particular look-and-feel might use smooth scrolling (eg. using SmoothedAnimation), might have a visible
-    scrollbar, or a scrollbar that fades in to show location, etc.
-
-    Clipboard support is provided by the cut(), copy(), and paste() functions, and the selection can
-    be handled in a traditional "mouse" mechanism by setting selectByMouse, or handled completely
-    from QML by manipulating selectionStart and selectionEnd, or using selectAll() or selectWord().
-
-    You can translate between cursor positions (characters from the start of the document) and pixel
-    points using positionAt() and positionToRectangle().
-
-    \sa Text, TextInput
-*/
-
-/*!
-    \qmlsignal QtQuick::TextEdit::linkActivated(string link)
-
-    This signal is emitted when the user clicks on a link embedded in the text.
-    The link must be in rich text or HTML format and the
-    \a link string provides access to the particular link.
-
-    The corresponding handler is \c onLinkActivated.
-*/
-
-// This is a pretty arbitrary figure. The idea is that we don't want to break down the document
-// into text nodes corresponding to a text block each so that the glyph node grouping doesn't become pointless.
-static const int nodeBreakingSize = 300;
-
-namespace {
-    class ProtectedLayoutAccessor: public QAbstractTextDocumentLayout
-    {
-    public:
-        inline QTextCharFormat formatAccessor(int pos)
-        {
-            return format(pos);
-        }
-    };
-
-    class RootNode : public QSGTransformNode
-    {
-    public:
-        RootNode() : cursorNode(nullptr), frameDecorationsNode(nullptr)
-        { }
-
-        void resetFrameDecorations(TextNode* newNode)
-        {
-            if (frameDecorationsNode) {
-                removeChildNode(frameDecorationsNode);
-                delete frameDecorationsNode;
-            }
-            frameDecorationsNode = newNode;
-            newNode->setFlag(QSGNode::OwnedByParent);
-        }
-
-        void resetCursorNode(QSGRectangleNode* newNode)
-        {
-            if (cursorNode)
-                removeChildNode(cursorNode);
-            delete cursorNode;
-            cursorNode = newNode;
-            if (cursorNode) {
-                appendChildNode(cursorNode);
-                cursorNode->setFlag(QSGNode::OwnedByParent);
-            }
-        }
-
-        QSGRectangleNode *cursorNode;
-        TextNode* frameDecorationsNode;
-
-    };
-}
-
-TextEdit::TextEdit(QQuickImplicitSizeItem *parent)
-: QQuickImplicitSizeItem(*(new TextEditPrivate), parent)
-{
-    Q_D(TextEdit);
-    d->init();
-}
-
-TextEdit::TextEdit(TextEditPrivate &dd, QQuickImplicitSizeItem *parent)
-: QQuickImplicitSizeItem(dd, parent)
-{
-    Q_D(TextEdit);
-    d->init();
-}
-
-PaletteManager *TextEdit::getPaletteManager()
-{
-    Q_D(TextEdit);
-    return d->paletteManager;
-}
-
-void TextEdit::setLineSurface(LineSurface *ls)
-{
-    Q_D(TextEdit);
-    d->lineSurface = ls;
-    if (d->document && getDocumentLayout())
-        d->lineSurface->setDocument(getDocumentLayout()->lineDocument());
-
-}
-
-QString TextEdit::text() const
-{
-    Q_D(const TextEdit);
-    if (!d->document || !d->control) return QString();
-    if (!d->textCached && isComponentComplete()) {
-        TextEditPrivate *d = const_cast<TextEditPrivate *>(d_func());
-#ifndef QT_NO_TEXTHTMLPARSER
-        if (d->richText)
-            d->text = d->control->toHtml();
-        else
-#endif
-            d->text = d->control->toPlainText();
-        d->textCached = true;
-    }
-    return d->text;
-}
-
-/*!
-    \qmlproperty string QtQuick::TextEdit::font.family
-
-    Sets the family name of the font.
-
-    The family name is case insensitive and may optionally include a foundry name, e.g. "Helvetica [Cronyx]".
-    If the family is available from more than one foundry and the foundry isn't specified, an arbitrary foundry is chosen.
-    If the family isn't available a family will be set using the font matching algorithm.
-*/
-
-/*!
-    \qmlproperty string QtQuick::TextEdit::font.styleName
-    \since 5.6
-
-    Sets the style name of the font.
-
-    The style name is case insensitive. If set, the font will be matched against style name instead
-    of the font properties \l font.weight, \l font.bold and \l font.italic.
-*/
-
-
-/*!
-    \qmlproperty bool QtQuick::TextEdit::font.bold
-
-    Sets whether the font weight is bold.
-*/
-
-/*!
-    \qmlproperty enumeration QtQuick::TextEdit::font.weight
-
-    Sets the font's weight.
-
-    The weight can be one of:
-    \list
-    \li Font.Thin
-    \li Font.Light
-    \li Font.ExtraLight
-    \li Font.Normal - the default
-    \li Font.Medium
-    \li Font.DemiBold
-    \li Font.Bold
-    \li Font.ExtraBold
-    \li Font.Black
-    \endlist
-
-    \qml
-    TextEdit { text: "Hello"; font.weight: Font.DemiBold }
-    \endqml
-*/
-
-/*!
-    \qmlproperty bool QtQuick::TextEdit::font.italic
-
-    Sets whether the font has an italic style.
-*/
-
-/*!
-    \qmlproperty bool QtQuick::TextEdit::font.underline
-
-    Sets whether the text is underlined.
-*/
-
-/*!
-    \qmlproperty bool QtQuick::TextEdit::font.strikeout
-
-    Sets whether the font has a strikeout style.
-*/
-
-/*!
-    \qmlproperty real QtQuick::TextEdit::font.pointSize
-
-    Sets the font size in points. The point size must be greater than zero.
-*/
-
-/*!
-    \qmlproperty int QtQuick::TextEdit::font.pixelSize
-
-    Sets the font size in pixels.
-
-    Using this function makes the font device dependent.  Use
-    \l{TextEdit::font.pointSize} to set the size of the font in a
-    device independent manner.
-*/
-
-/*!
-    \qmlproperty real QtQuick::TextEdit::font.letterSpacing
-
-    Sets the letter spacing for the font.
-
-    Letter spacing changes the default spacing between individual letters in the font.
-    A positive value increases the letter spacing by the corresponding pixels; a negative value decreases the spacing.
-*/
-
-/*!
-    \qmlproperty real QtQuick::TextEdit::font.wordSpacing
-
-    Sets the word spacing for the font.
-
-    Word spacing changes the default spacing between individual words.
-    A positive value increases the word spacing by a corresponding amount of pixels,
-    while a negative value decreases the inter-word spacing accordingly.
-*/
-
-/*!
-    \qmlproperty enumeration QtQuick::TextEdit::font.capitalization
-
-    Sets the capitalization for the text.
-
-    \list
-    \li Font.MixedCase - This is the normal text rendering option where no capitalization change is applied.
-    \li Font.AllUppercase - This alters the text to be rendered in all uppercase type.
-    \li Font.AllLowercase - This alters the text to be rendered in all lowercase type.
-    \li Font.SmallCaps - This alters the text to be rendered in small-caps type.
-    \li Font.Capitalize - This alters the text to be rendered with the first character of each word as an uppercase character.
-    \endlist
-
-    \qml
-    TextEdit { text: "Hello"; font.capitalization: Font.AllLowercase }
-    \endqml
-*/
-
-/*!
-    \qmlproperty string QtQuick::TextEdit::text
-
-    The text to display.  If the text format is AutoText the text edit will
-    automatically determine whether the text should be treated as
-    rich text.  This determination is made using Qt::mightBeRichText().
-
-    The text-property is mostly suitable for setting the initial content and
-    handling modifications to relatively small text content. The append(),
-    insert() and remove() methods provide more fine-grained control and
-    remarkably better performance for modifying especially large rich text
-    content.
-
-    \sa clear()
-*/
-void TextEdit::setText(const QString &text)
-{
-
-    Q_D(TextEdit);
-    if (TextEdit::text() == text)
-        return;
-
-    d->richText = d->format == RichText || (d->format == AutoText && Qt::mightBeRichText(text));
-    if (!isComponentComplete()) {
-        d->text = text;
-    } else if (d->control) {
-        if (d->richText) {
-        #ifndef QT_NO_TEXTHTMLPARSER
-                d->control->setHtml(text);
-        #else
-                d->control->setPlainText(text);
-        #endif
-        } else {
-            d->control->setPlainText(text);
-        }
-    }
-}
-
-/*!
-    \qmlproperty string QtQuick::TextEdit::preeditText
-    \readonly
-    \since 5.7
-
-    This property contains partial text input from an input method.
-*/
-QString TextEdit::preeditText() const
-{
-    Q_D(const TextEdit);
-    if (!d->document || !d->control) return QString();
-    return d->control->preeditText();
-}
-
-/*!
-    \qmlproperty enumeration QtQuick::TextEdit::textFormat
-
-    The way the text property should be displayed.
-
-    \list
-    \li TextEdit.AutoText
-    \li TextEdit.PlainText
-    \li TextEdit.RichText
-    \endlist
-
-    The default is TextEdit.PlainText.  If the text format is TextEdit.AutoText the text edit
-    will automatically determine whether the text should be treated as
-    rich text.  This determination is made using Qt::mightBeRichText().
-
-    \table
-    \row
-    \li
-    \qml
-Column {
-    TextEdit {
-        font.pointSize: 24
-        text: "<b>Hello</b> <i>World!</i>"
-    }
-    TextEdit {
-        font.pointSize: 24
-        textFormat: TextEdit.RichText
-        text: "<b>Hello</b> <i>World!</i>"
-    }
-    TextEdit {
-        font.pointSize: 24
-        textFormat: TextEdit.PlainText
-        text: "<b>Hello</b> <i>World!</i>"
-    }
-}
-    \endqml
-    \li \image declarative-textformat.png
-    \endtable
-*/
-TextEdit::TextFormat TextEdit::textFormat() const
-{
-    Q_D(const TextEdit);
-    return d->format;
-}
-
-void TextEdit::setTextFormat(TextFormat format)
-{
-    Q_D(TextEdit);
-
-    if (format == d->format)
-        return;
-
-    bool wasRich = d->richText;
-    d->richText = format == RichText || (format == AutoText && (wasRich || Qt::mightBeRichText(text())));
-
-#ifndef QT_NO_TEXTHTMLPARSER
-    if (isComponentComplete()) {
-        if (wasRich && !d->richText) {
-            if (d->control) d->control->setPlainText(!d->textCached ? d->control->toHtml() : d->text);
-            updateSize();
-        } else if (!wasRich && d->richText) {
-            if (d->control) d->control->setHtml(!d->textCached ? d->control->toPlainText() : d->text);
-            updateSize();
-        }
-    }
-#endif
-
-    d->format = format;
-    d->control->setAcceptRichText(d->format != PlainText);
-    emit textFormatChanged(d->format);
-}
-
-/*!
-    \qmlproperty enumeration QtQuick::TextEdit::renderType
-
-    Override the default rendering type for this component.
-
-    Supported render types are:
-    \list
-    \li Text.QtRendering - the default
-    \li Text.NativeRendering
-    \endlist
-
-    Select Text.NativeRendering if you prefer text to look native on the target platform and do
-    not require advanced features such as transformation of the text. Using such features in
-    combination with the NativeRendering render type will lend poor and sometimes pixelated
-    results.
-*/
-TextEdit::RenderType TextEdit::renderType() const
-{
-    Q_D(const TextEdit);
-    return d->renderType;
-}
-
-void TextEdit::setRenderType(TextEdit::RenderType renderType)
-{
-    Q_D(TextEdit);
-    if (d->renderType == renderType)
-        return;
-
-    d->renderType = renderType;
-    emit renderTypeChanged();
-    d->updateDefaultTextOption();
-
-    if (isComponentComplete())
-        updateSize();
-}
-
-QFont TextEdit::font() const
-{
-    Q_D(const TextEdit);
-    return d->sourceFont;
-}
-
-void TextEdit::setFont(const QFont &font)
-{
-    Q_D(TextEdit);
-    if (d->sourceFont == font)
-        return;
-
-    d->sourceFont = font;
-    QFont oldFont = d->font;
-    d->font = font;
-    if (static_cast<int>(d->font.pointSizeF()) != -1) {
-        // 0.5pt resolution
-        qreal size = qRound(d->font.pointSizeF()*2.0);
-        d->font.setPointSizeF(size/2.0);
-    }
-
-    if (oldFont != d->font && d->font.pixelSize() > 0) {
-        if (d->document) d->document->setDefaultFont(d->font);
-        if (d->cursorItem) {
-            d->cursorItem->setHeight(QFontMetrics(d->font).height());
-            moveCursorDelegate();
-        }
-        updateSize();
-        updateWholeDocument();
-#ifndef QT_NO_IM
-        updateInputMethod(Qt::ImCursorRectangle | Qt::ImAnchorRectangle | Qt::ImFont);
-#endif
-    }
-    if (d->document && d->document->documentLayout() && font.pixelSize() > 0)
-    {
-        getDocumentLayout()->setLineDocumentFont(font);
-    }
-    emit fontChanged(d->sourceFont);
-}
-
-/*!
-    \qmlproperty color QtQuick::TextEdit::color
-
-    The text color.
-
-    \qml
-    // green text using hexadecimal notation
-    TextEdit { color: "#00FF00" }
-    \endqml
-
-    \qml
-    // steelblue text using SVG color name
-    TextEdit { color: "steelblue" }
-    \endqml
-*/
-QColor TextEdit::color() const
-{
-    Q_D(const TextEdit);
-    return d->color;
-}
-
-void TextEdit::setColor(const QColor &color)
-{
-    Q_D(TextEdit);
-    if (d->color == color)
-        return;
-
-    d->color = color;
-
-    updateWholeDocument();
-    emit colorChanged(d->color);
-}
-
-/*!
-    \qmlproperty color QtQuick::TextEdit::selectionColor
-
-    The text highlight color, used behind selections.
-*/
-QColor TextEdit::selectionColor() const
-{
-    Q_D(const TextEdit);
-    return d->selectionColor;
-}
-
-void TextEdit::setSelectionColor(const QColor &color)
-{
-    Q_D(TextEdit);
-    if (d->selectionColor == color)
-        return;
-
-    d->selectionColor = color;
-    updateWholeDocument();
-    emit selectionColorChanged(d->selectionColor);
-}
-
-/*!
-    \qmlproperty color QtQuick::TextEdit::selectedTextColor
-
-    The selected text color, used in selections.
-*/
-QColor TextEdit::selectedTextColor() const
-{
-    Q_D(const TextEdit);
-    return d->selectedTextColor;
-}
-
-void TextEdit::setSelectedTextColor(const QColor &color)
-{
-    Q_D(TextEdit);
-    if (d->selectedTextColor == color)
-        return;
-
-    d->selectedTextColor = color;
-    updateWholeDocument();
-    emit selectedTextColorChanged(d->selectedTextColor);
-}
-
-int TextEdit::fragmentStart() const {
-    Q_D(const TextEdit);
-    return d->fragmentStart;
-}
-
-int TextEdit::fragmentEnd() const {
-    Q_D(const TextEdit);
-    return d->fragmentEnd;
-}
-
-void TextEdit::setFragmentStart(int frStart) {
-    Q_D(TextEdit);
-    d->fragmentStart = frStart - 1;
-    updateFragmentVisibility();
-}
-
-void TextEdit::setFragmentEnd(int frEnd) {
-    Q_D(TextEdit);
-    d->fragmentEnd = (frEnd == -1) ? INT_MAX : frEnd -1;
-    updateFragmentVisibility();
-}
-
-void TextEdit::resetFragmentStart() {
-    setFragmentStart(0);
-}
-
-void TextEdit::resetFragmentEnd() {
-    setFragmentEnd(INT_MAX);
-}
-
-int TextEdit::lineNumber() const
-{
-    Q_D(const TextEdit);
-    if (!d->document || !d->control) return 0;
-
-    return d->control->textCursor().block().blockNumber() + 1;
-}
-
-int TextEdit::columnNumber() const
-{
-    Q_D(const TextEdit);
-    if (!d->document || !d->control) return 0;
-
-    return d->control->textCursor().position() - d->control->textCursor().block().position();
-}
-
-/*!
-    \qmlproperty enumeration QtQuick::TextEdit::horizontalAlignment
-    \qmlproperty enumeration QtQuick::TextEdit::verticalAlignment
-    \qmlproperty enumeration QtQuick::TextEdit::effectiveHorizontalAlignment
-
-    Sets the horizontal and vertical alignment of the text within the TextEdit item's
-    width and height. By default, the text alignment follows the natural alignment
-    of the text, for example text that is read from left to right will be aligned to
-    the left.
-
-    Valid values for \c horizontalAlignment are:
-    \list
-    \li TextEdit.AlignLeft (default)
-    \li TextEdit.AlignRight
-    \li TextEdit.AlignHCenter
-    \li TextEdit.AlignJustify
-    \endlist
-
-    Valid values for \c verticalAlignment are:
-    \list
-    \li TextEdit.AlignTop (default)
-    \li TextEdit.AlignBottom
-    \li TextEdit.AlignVCenter
-    \endlist
-
-    When using the attached property LayoutMirroring::enabled to mirror application
-    layouts, the horizontal alignment of text will also be mirrored. However, the property
-    \c horizontalAlignment will remain unchanged. To query the effective horizontal alignment
-    of TextEdit, use the read-only property \c effectiveHorizontalAlignment.
-*/
-TextEdit::HAlignment TextEdit::hAlign() const
-{
-    Q_D(const TextEdit);
-    return d->hAlign;
-}
-
-void TextEdit::setHAlign(HAlignment align)
-{
-    Q_D(TextEdit);
-    bool forceAlign = d->hAlignImplicit && d->effectiveLayoutMirror;
-    d->hAlignImplicit = false;
-    if (d->setHAlign(align, forceAlign) && isComponentComplete()) {
-        d->updateDefaultTextOption();
-        updateSize();
-    }
-}
-
-void TextEdit::resetHAlign()
-{
-    Q_D(TextEdit);
-    d->hAlignImplicit = true;
-    if (d->determineHorizontalAlignment() && isComponentComplete()) {
-        d->updateDefaultTextOption();
-        updateSize();
-    }
-}
-
-TextEdit::HAlignment TextEdit::effectiveHAlign() const
-{
-    Q_D(const TextEdit);
-    TextEdit::HAlignment effectiveAlignment = d->hAlign;
-    if (!d->hAlignImplicit && d->effectiveLayoutMirror) {
-        switch (d->hAlign) {
-        case TextEdit::AlignLeft:
-            effectiveAlignment = TextEdit::AlignRight;
-            break;
-        case TextEdit::AlignRight:
-            effectiveAlignment = TextEdit::AlignLeft;
-            break;
-        default:
-            break;
-        }
-    }
-    return effectiveAlignment;
-}
-
-bool TextEditPrivate::setHAlign(TextEdit::HAlignment alignment, bool forceAlign)
-{
-    Q_Q(TextEdit);
-    if (hAlign != alignment || forceAlign) {
-        TextEdit::HAlignment oldEffectiveHAlign = q->effectiveHAlign();
-        hAlign = alignment;
-        emit q->horizontalAlignmentChanged(alignment);
-        if (oldEffectiveHAlign != q->effectiveHAlign())
-            emit q->effectiveHorizontalAlignmentChanged();
-        return true;
-    }
-    return false;
-}
-
-
-Qt::LayoutDirection TextEditPrivate::textDirection(const QString &text) const
-{
-    const QChar *character = text.constData();
-    while (!character->isNull()) {
-        switch (character->direction()) {
-        case QChar::DirL:
-            return Qt::LeftToRight;
-        case QChar::DirR:
-        case QChar::DirAL:
-        case QChar::DirAN:
-            return Qt::RightToLeft;
-        default:
-            break;
-        }
-        character++;
-    }
-    return Qt::LayoutDirectionAuto;
-}
-
-bool TextEditPrivate::determineHorizontalAlignment()
-{
-    Q_Q(TextEdit);
-    if (!document || !control) return false;
-
-    if (hAlignImplicit && q->isComponentComplete()) {
-        Qt::LayoutDirection direction = contentDirection;
-#ifndef QT_NO_IM
-        if (direction == Qt::LayoutDirectionAuto) {
-            const QString preeditText = control->textCursor().block().layout()->preeditAreaText();
-            direction = textDirection(preeditText);
-        }
-        if (direction == Qt::LayoutDirectionAuto)
-            direction = qGuiApp->inputMethod()->inputDirection();
-#endif
-
-        return setHAlign(direction == Qt::RightToLeft ? TextEdit::AlignRight : TextEdit::AlignLeft);
-    }
-    return false;
-}
-
-void TextEditPrivate::mirrorChange()
-{
-    Q_Q(TextEdit);
-    if (q->isComponentComplete()) {
-        if (!hAlignImplicit && (hAlign == TextEdit::AlignRight || hAlign == TextEdit::AlignLeft)) {
-            updateDefaultTextOption();
-            q->updateSize();
-            emit q->effectiveHorizontalAlignmentChanged();
-        }
-    }
-}
-
-#ifndef QT_NO_IM
-Qt::InputMethodHints TextEditPrivate::effectiveInputMethodHints() const
-{
-    return inputMethodHints | Qt::ImhMultiLine;
-}
-#endif
-
-void TextEditPrivate::setTopPadding(qreal value, bool reset)
-{
-    Q_Q(TextEdit);
-    qreal oldPadding = q->topPadding();
-    if (!reset || extra.isAllocated()) {
-        extra.value().topPadding = value;
-        extra.value().explicitTopPadding = !reset;
-    }
-    if ((!reset && !qFuzzyCompare(oldPadding, value)) || (reset && !qFuzzyCompare(oldPadding, padding()))) {
-        q->updateSize();
-        emit q->topPaddingChanged();
-    }
-}
-
-void TextEditPrivate::setLeftPadding(qreal value, bool reset)
-{
-    Q_Q(TextEdit);
-    qreal oldPadding = q->leftPadding();
-    if (!reset || extra.isAllocated()) {
-        extra.value().leftPadding = value;
-        extra.value().explicitLeftPadding = !reset;
-    }
-    if ((!reset && !qFuzzyCompare(oldPadding, value)) || (reset && !qFuzzyCompare(oldPadding, padding()))) {
-        q->updateSize();
-        emit q->leftPaddingChanged();
-    }
-}
-
-void TextEditPrivate::setRightPadding(qreal value, bool reset)
-{
-    Q_Q(TextEdit);
-    qreal oldPadding = q->rightPadding();
-    if (!reset || extra.isAllocated()) {
-        extra.value().rightPadding = value;
-        extra.value().explicitRightPadding = !reset;
-    }
-    if ((!reset && !qFuzzyCompare(oldPadding, value)) || (reset && !qFuzzyCompare(oldPadding, padding()))) {
-        q->updateSize();
-        emit q->rightPaddingChanged();
-    }
-}
-
-void TextEditPrivate::setBottomPadding(qreal value, bool reset)
-{
-    Q_Q(TextEdit);
-    qreal oldPadding = q->bottomPadding();
-    if (!reset || extra.isAllocated()) {
-        extra.value().bottomPadding = value;
-        extra.value().explicitBottomPadding = !reset;
-    }
-    if ((!reset && !qFuzzyCompare(oldPadding, value)) || (reset && !qFuzzyCompare(oldPadding, padding()))) {
-        q->updateSize();
-        emit q->bottomPaddingChanged();
-    }
-}
-
-bool TextEditPrivate::isImplicitResizeEnabled() const
-{
-    return !extra.isAllocated() || extra->implicitResize;
-}
-
-void TextEditPrivate::setImplicitResizeEnabled(bool enabled)
-{
-    if (!enabled)
-        extra.value().implicitResize = false;
-    else if (extra.isAllocated())
-        extra->implicitResize = true;
-}
-
-TextEdit::VAlignment TextEdit::vAlign() const
-{
-    Q_D(const TextEdit);
-    return d->vAlign;
-}
-
-void TextEdit::setVAlign(TextEdit::VAlignment alignment)
-{
-    Q_D(TextEdit);
-    if (alignment == d->vAlign)
-        return;
-    d->vAlign = alignment;
-    d->updateDefaultTextOption();
-    updateSize();
-    moveCursorDelegate();
-    emit verticalAlignmentChanged(d->vAlign);
-}
-/*!
-    \qmlproperty enumeration QtQuick::TextEdit::wrapMode
-
-    Set this property to wrap the text to the TextEdit item's width.
-    The text will only wrap if an explicit width has been set.
-
-    \list
-    \li TextEdit.NoWrap - no wrapping will be performed. If the text contains insufficient newlines, then implicitWidth will exceed a set width.
-    \li TextEdit.WordWrap - wrapping is done on word boundaries only. If a word is too long, implicitWidth will exceed a set width.
-    \li TextEdit.WrapAnywhere - wrapping is done at any point on a line, even if it occurs in the middle of a word.
-    \li TextEdit.Wrap - if possible, wrapping occurs at a word boundary; otherwise it will occur at the appropriate point on the line, even in the middle of a word.
-    \endlist
-
-    The default is TextEdit.NoWrap. If you set a width, consider using TextEdit.Wrap.
-*/
-TextEdit::WrapMode TextEdit::wrapMode() const
-{
-    Q_D(const TextEdit);
-    return d->wrapMode;
-}
-
-void TextEdit::setWrapMode(WrapMode mode)
-{
-    Q_D(TextEdit);
-    if (mode == d->wrapMode)
-        return;
-    d->wrapMode = mode;
-    d->updateDefaultTextOption();
-    updateSize();
-    emit wrapModeChanged();
-}
-
-/*!
-    \qmlproperty int QtQuick::TextEdit::lineCount
-
-    Returns the total number of lines in the textEdit item.
-*/
-int TextEdit::lineCount() const
-{
-    Q_D(const TextEdit);
-    return d->lineCount;
-}
-
-/*!
-    \qmlproperty int QtQuick::TextEdit::length
-
-    Returns the total number of plain text characters in the TextEdit item.
-
-    As this number doesn't include any formatting markup it may not be the same as the
-    length of the string returned by the \l text property.
-
-    This property can be faster than querying the length the \l text property as it doesn't
-    require any copying or conversion of the TextEdit's internal string data.
-*/
-
-int TextEdit::length() const
-{
-    Q_D(const TextEdit);
-    if (!d->document) return 0;
-    // QTextDocument::characterCount() includes the terminating null character.
-    return qMax(0, d->document->characterCount() - 1);
-}
-
-/*!
-    \qmlproperty real QtQuick::TextEdit::contentWidth
-
-    Returns the width of the text, including the width past the width
-    which is covered due to insufficient wrapping if \l wrapMode is set.
-*/
-qreal TextEdit::contentWidth() const
-{
-    Q_D(const TextEdit);
-    return d->paintedWidth;
-}
-
-/*!
-    \qmlproperty real QtQuick::TextEdit::contentHeight
-
-    Returns the height of the text, including the height past the height
-    that is covered if the text does not fit within the set height.
-*/
-qreal TextEdit::contentHeight() const
-{
-    Q_D(const TextEdit);
-    return d->paintedHeight;
-}
-
-/*!
-    \qmlproperty url QtQuick::TextEdit::baseUrl
-
-    This property specifies a base URL which is used to resolve relative URLs
-    within the text.
-
-    The default value is the url of the QML file instantiating the TextEdit item.
-*/
-
-QUrl TextEdit::baseUrl() const
-{
-    Q_D(const TextEdit);
-    if (d->baseUrl.isEmpty()) {
-        if (QQmlContext *context = qmlContext(this))
-            const_cast<TextEditPrivate *>(d)->baseUrl = context->baseUrl();
-    }
-    return d->baseUrl;
-}
-
-void TextEdit::setBaseUrl(const QUrl &url)
-{
-    Q_D(TextEdit);
-    if (baseUrl() != url) {
-        d->baseUrl = url;
-
-        if (d->document) d->document->setBaseUrl(url);
-        emit baseUrlChanged();
-    }
-}
-
-void TextEdit::resetBaseUrl()
-{
-    if (QQmlContext *context = qmlContext(this))
-        setBaseUrl(context->baseUrl());
-    else
-        setBaseUrl(QUrl());
-}
-
-/*!
-    \qmlmethod rectangle QtQuick::TextEdit::positionToRectangle(position)
-
-    Returns the rectangle at the given \a position in the text. The x, y,
-    and height properties correspond to the cursor that would describe
-    that position.
-*/
-QRectF TextEdit::positionToRectangle(int pos) const
-{
-    Q_D(const TextEdit);
-    if (!d->document || !d->control) return QRectF();
-    QTextCursor c(d->document);
-    c.setPosition(pos);
-    return d->control->cursorRect(c).translated(d->xoff, d->yoff);
-
-}
-
-/*!
-    \qmlmethod int QtQuick::TextEdit::positionAt(int x, int y)
-
-    Returns the text position closest to pixel position (\a x, \a y).
-
-    Position 0 is before the first character, position 1 is after the first character
-    but before the second, and so on until position \l {text}.length, which is after all characters.
-*/
-int TextEdit::positionAt(qreal x, qreal y) const
-{
-    Q_D(const TextEdit);
-    if (!d->document) return -1;
-    x -= d->xoff;
-    y -= d->yoff;
-
-    int r = dynamic_cast<TextDocumentLayout*>(d->document->documentLayout())->hitTest(QPointF(x, y), Qt::FuzzyHit);
-#ifndef QT_NO_IM
-    QTextCursor cursor = d->control->textCursor();
-    if (r > cursor.position()) {
-        // The cursor position includes positions within the preedit text, but only positions in the
-        // same text block are offset so it is possible to get a position that is either part of the
-        // preedit or the next text block.
-        QTextLayout *layout = cursor.block().layout();
-        const int preeditLength = layout
-                ? layout->preeditAreaText().length()
-                : 0;
-        if (preeditLength > 0
-                && dynamic_cast<TextDocumentLayout*>(d->document->documentLayout())->blockBoundingRect(cursor.block()).contains(x, y)) {
-            r = r > cursor.position() + preeditLength
-                    ? r - preeditLength
-                    : cursor.position();
-        }
-    }
-#endif
-    return r;
-}
-
-/*!
-    \qmlmethod QtQuick::TextEdit::moveCursorSelection(int position, SelectionMode mode = TextEdit.SelectCharacters)
-
-    Moves the cursor to \a position and updates the selection according to the optional \a mode
-    parameter. (To only move the cursor, set the \l cursorPosition property.)
-
-    When this method is called it additionally sets either the
-    selectionStart or the selectionEnd (whichever was at the previous cursor position)
-    to the specified position. This allows you to easily extend and contract the selected
-    text range.
-
-    The selection mode specifies whether the selection is updated on a per character or a per word
-    basis.  If not specified the selection mode will default to TextEdit.SelectCharacters.
-
-    \list
-    \li TextEdit.SelectCharacters - Sets either the selectionStart or selectionEnd (whichever was at
-    the previous cursor position) to the specified position.
-    \li TextEdit.SelectWords - Sets the selectionStart and selectionEnd to include all
-    words between the specified position and the previous cursor position.  Words partially in the
-    range are included.
-    \endlist
-
-    For example, take this sequence of calls:
-
-    \code
-        cursorPosition = 5
-        moveCursorSelection(9, TextEdit.SelectCharacters)
-        moveCursorSelection(7, TextEdit.SelectCharacters)
-    \endcode
-
-    This moves the cursor to position 5, extend the selection end from 5 to 9
-    and then retract the selection end from 9 to 7, leaving the text from position 5 to 7
-    selected (the 6th and 7th characters).
-
-    The same sequence with TextEdit.SelectWords will extend the selection start to a word boundary
-    before or on position 5 and extend the selection end to a word boundary on or past position 9.
-*/
-void TextEdit::moveCursorSelection(int pos)
-{
-    //Note that this is the same as setCursorPosition but with the KeepAnchor flag set
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    QTextCursor cursor = d->control->textCursor();
-    if (cursor.position() == pos)
-        return;
-    cursor.setPosition(pos, QTextCursor::KeepAnchor);
-    d->control->setTextCursor(cursor);
-}
-
-void TextEdit::moveCursorSelection(int pos, SelectionMode mode)
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    QTextCursor cursor = d->control->textCursor();
-    if (cursor.position() == pos)
-        return;
-    if (mode == SelectCharacters) {
-        cursor.setPosition(pos, QTextCursor::KeepAnchor);
-    } else if (cursor.anchor() < pos || (cursor.anchor() == pos && cursor.position() < pos)) {
-        if (cursor.anchor() > cursor.position()) {
-            cursor.setPosition(cursor.anchor(), QTextCursor::MoveAnchor);
-            cursor.movePosition(QTextCursor::StartOfWord, QTextCursor::KeepAnchor);
-            if (cursor.position() == cursor.anchor())
-                cursor.movePosition(QTextCursor::PreviousWord, QTextCursor::MoveAnchor);
-            else
-                cursor.setPosition(cursor.position(), QTextCursor::MoveAnchor);
-        } else {
-            cursor.setPosition(cursor.anchor(), QTextCursor::MoveAnchor);
-            cursor.movePosition(QTextCursor::StartOfWord, QTextCursor::MoveAnchor);
-        }
-
-        cursor.setPosition(pos, QTextCursor::KeepAnchor);
-        cursor.movePosition(QTextCursor::StartOfWord, QTextCursor::KeepAnchor);
-        if (cursor.position() != pos)
-            cursor.movePosition(QTextCursor::EndOfWord, QTextCursor::KeepAnchor);
-    } else if (cursor.anchor() > pos || (cursor.anchor() == pos && cursor.position() > pos)) {
-        if (cursor.anchor() < cursor.position()) {
-            cursor.setPosition(cursor.anchor(), QTextCursor::MoveAnchor);
-            cursor.movePosition(QTextCursor::EndOfWord, QTextCursor::MoveAnchor);
-        } else {
-            cursor.setPosition(cursor.anchor(), QTextCursor::MoveAnchor);
-            cursor.movePosition(QTextCursor::PreviousCharacter, QTextCursor::KeepAnchor);
-            cursor.movePosition(QTextCursor::EndOfWord, QTextCursor::KeepAnchor);
-            if (cursor.position() != cursor.anchor()) {
-                cursor.setPosition(cursor.anchor(), QTextCursor::MoveAnchor);
-                cursor.movePosition(QTextCursor::EndOfWord, QTextCursor::MoveAnchor);
-            }
-        }
-
-        cursor.setPosition(pos, QTextCursor::KeepAnchor);
-        cursor.movePosition(QTextCursor::EndOfWord, QTextCursor::KeepAnchor);
-        if (cursor.position() != pos) {
-            cursor.movePosition(QTextCursor::PreviousCharacter, QTextCursor::KeepAnchor);
-            cursor.movePosition(QTextCursor::StartOfWord, QTextCursor::KeepAnchor);
-        }
-    }
-    d->control->setTextCursor(cursor);
-}
-
-/*!
-    \qmlproperty bool QtQuick::TextEdit::cursorVisible
-    If true the text edit shows a cursor.
-
-    This property is set and unset when the text edit gets active focus, but it can also
-    be set directly (useful, for example, if a KeyProxy might forward keys to it).
-*/
-bool TextEdit::isCursorVisible() const
-{
-    Q_D(const TextEdit);
-    return d->cursorVisible;
-}
-
-void TextEdit::setCursorVisible(bool on)
-{
-    Q_D(TextEdit);
-    d->cursorVisible = on;
-    if (on && isComponentComplete())
-        TextUtil::createCursor(d);
-    if (!on && !d->persistentSelection)
-        if (d->control) d->control->setCursorIsFocusIndicator(true);
-    if (d->control) d->control->setCursorVisible(on);
-    emit cursorVisibleChanged(d->cursorVisible);
-}
-
-/*!
-    \qmlproperty int QtQuick::TextEdit::cursorPosition
-    The position of the cursor in the TextEdit.
-*/
-int TextEdit::cursorPosition() const
-{
-    Q_D(const TextEdit);
-    if (!d->document || !d->control) return -1;
-
-    return d->control->textCursor().position();
-}
-
-void TextEdit::setCursorPosition(int pos)
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-    if (pos < 0 || pos >= d->document->characterCount()) // characterCount includes the terminating null.
-        return;
-    QTextCursor cursor = d->control->textCursor();
-    if (cursor.position() == pos && cursor.anchor() == pos)
-        return;
-    cursor.setPosition(pos);
-    d->control->setTextCursor(cursor);
-    d->control->updateCursorRectangle(true);
-}
-
-/*!
-    \qmlproperty Component QtQuick::TextEdit::cursorDelegate
-    The delegate for the cursor in the TextEdit.
-
-    If you set a cursorDelegate for a TextEdit, this delegate will be used for
-    drawing the cursor instead of the standard cursor. An instance of the
-    delegate will be created and managed by the text edit when a cursor is
-    needed, and the x and y properties of delegate instance will be set so as
-    to be one pixel before the top left of the current character.
-
-    Note that the root item of the delegate component must be a QQuickItem or
-    QQuickItem derived item.
-*/
-QQmlComponent* TextEdit::cursorDelegate() const
-{
-    Q_D(const TextEdit);
-    return d->cursorComponent;
-}
-
-void TextEdit::setCursorDelegate(QQmlComponent* c)
-{
-    Q_D(TextEdit);
-    TextUtil::setCursorDelegate(d, c);
-}
-
-void TextEdit::createCursor()
-{
-    Q_D(TextEdit);
-    d->cursorPending = true;
-    TextUtil::createCursor(d);
-}
-
-/*!
-    \qmlproperty int QtQuick::TextEdit::selectionStart
-
-    The cursor position before the first character in the current selection.
-
-    This property is read-only. To change the selection, use select(start,end),
-    selectAll(), or selectWord().
-
-    \sa selectionEnd, cursorPosition, selectedText
-*/
-int TextEdit::selectionStart() const
-{
-    Q_D(const TextEdit);
-    if (!d->document || !d->control) return -1;
-
-    return d->control->textCursor().selectionStart();
-}
-
-/*!
-    \qmlproperty int QtQuick::TextEdit::selectionEnd
-
-    The cursor position after the last character in the current selection.
-
-    This property is read-only. To change the selection, use select(start,end),
-    selectAll(), or selectWord().
-
-    \sa selectionStart, cursorPosition, selectedText
-*/
-int TextEdit::selectionEnd() const
-{
-    Q_D(const TextEdit);
-    if (!d->document || !d->control) return -1;
-
-    return d->control->textCursor().selectionEnd();
-}
-
-/*!
-    \qmlproperty string QtQuick::TextEdit::selectedText
-
-    This read-only property provides the text currently selected in the
-    text edit.
-
-    It is equivalent to the following snippet, but is faster and easier
-    to use.
-    \code
-    //myTextEdit is the id of the TextEdit
-    myTextEdit.text.toString().substring(myTextEdit.selectionStart,
-            myTextEdit.selectionEnd);
-    \endcode
-*/
-QString TextEdit::selectedText() const
-{
-    Q_D(const TextEdit);
-    if (!d->document || !d->control) return QString();
-
-#ifndef QT_NO_TEXTHTMLPARSER
-    return d->richText
-            ? d->control->textCursor().selectedText()
-            : d->control->textCursor().selection().toPlainText();
-#else
-    return d->control->textCursor().selection().toPlainText();
-#endif
-}
-
-/*!
-    \qmlproperty bool QtQuick::TextEdit::activeFocusOnPress
-
-    Whether the TextEdit should gain active focus on a mouse press. By default this is
-    set to true.
-*/
-bool TextEdit::focusOnPress() const
-{
-    Q_D(const TextEdit);
-    return d->focusOnPress;
-}
-
-void TextEdit::setFocusOnPress(bool on)
-{
-    Q_D(TextEdit);
-    if (d->focusOnPress == on)
-        return;
-    d->focusOnPress = on;
-    emit activeFocusOnPressChanged(d->focusOnPress);
-}
-
-/*!
-    \qmlproperty bool QtQuick::TextEdit::persistentSelection
-
-    Whether the TextEdit should keep the selection visible when it loses active focus to another
-    item in the scene. By default this is set to false.
-*/
-bool TextEdit::persistentSelection() const
-{
-    Q_D(const TextEdit);
-    return d->persistentSelection;
-}
-
-void TextEdit::setPersistentSelection(bool on)
-{
-    Q_D(TextEdit);
-    if (d->persistentSelection == on)
-        return;
-    d->persistentSelection = on;
-    emit persistentSelectionChanged(d->persistentSelection);
-}
-
-/*!
-   \qmlproperty real QtQuick::TextEdit::textMargin
-
-   The margin, in pixels, around the text in the TextEdit.
-*/
-qreal TextEdit::textMargin() const
-{
-    Q_D(const TextEdit);
-    return d->textMargin;
-}
-
-void TextEdit::setTextMargin(qreal margin)
-{
-    Q_D(TextEdit);
-
-    if (abs(d->textMargin - margin) < LV_ACCURACY)
-        return;
-    d->textMargin = margin;
-    if (!d->document) d->document->setDocumentMargin(d->textMargin);
-    emit textMarginChanged(d->textMargin);
-}
-
-/*!
-    \qmlproperty enumeration QtQuick::TextEdit::inputMethodHints
-
-    Provides hints to the input method about the expected content of the text edit and how it
-    should operate.
-
-    The value is a bit-wise combination of flags or Qt.ImhNone if no hints are set.
-
-    Flags that alter behaviour are:
-
-    \list
-    \li Qt.ImhHiddenText - Characters should be hidden, as is typically used when entering passwords.
-    \li Qt.ImhSensitiveData - Typed text should not be stored by the active input method
-            in any persistent storage like predictive user dictionary.
-    \li Qt.ImhNoAutoUppercase - The input method should not try to automatically switch to upper case
-            when a sentence ends.
-    \li Qt.ImhPreferNumbers - Numbers are preferred (but not required).
-    \li Qt.ImhPreferUppercase - Upper case letters are preferred (but not required).
-    \li Qt.ImhPreferLowercase - Lower case letters are preferred (but not required).
-    \li Qt.ImhNoPredictiveText - Do not use predictive text (i.e. dictionary lookup) while typing.
-
-    \li Qt.ImhDate - The text editor functions as a date field.
-    \li Qt.ImhTime - The text editor functions as a time field.
-    \endlist
-
-    Flags that restrict input (exclusive flags) are:
-
-    \list
-    \li Qt.ImhDigitsOnly - Only digits are allowed.
-    \li Qt.ImhFormattedNumbersOnly - Only number input is allowed. This includes decimal point and minus sign.
-    \li Qt.ImhUppercaseOnly - Only upper case letter input is allowed.
-    \li Qt.ImhLowercaseOnly - Only lower case letter input is allowed.
-    \li Qt.ImhDialableCharactersOnly - Only characters suitable for phone dialing are allowed.
-    \li Qt.ImhEmailCharactersOnly - Only characters suitable for email addresses are allowed.
-    \li Qt.ImhUrlCharactersOnly - Only characters suitable for URLs are allowed.
-    \endlist
-
-    Masks:
-
-    \list
-    \li Qt.ImhExclusiveInputMask - This mask yields nonzero if any of the exclusive flags are used.
-    \endlist
-*/
-
-Qt::InputMethodHints TextEdit::inputMethodHints() const
-{
-#ifdef QT_NO_IM
-    return Qt::ImhNone;
-#else
-    Q_D(const TextEdit);
-    return d->inputMethodHints;
-#endif // QT_NO_IM
-}
-
-void TextEdit::setInputMethodHints(Qt::InputMethodHints hints)
-{
-#ifdef QT_NO_IM
-    Q_UNUSED(hints);
-#else
-    Q_D(TextEdit);
-
-    if (hints == d->inputMethodHints)
-        return;
-
-    d->inputMethodHints = hints;
-    updateInputMethod(Qt::ImHints);
-    emit inputMethodHintsChanged();
-#endif // QT_NO_IM
-}
-
-void TextEdit::geometryChanged(const QRectF &newGeometry,
-                                  const QRectF &oldGeometry)
-{
-    Q_D(TextEdit);
-    if (!d->inLayout && ((abs(newGeometry.width() - oldGeometry.width()) > LV_ACCURACY && widthValid())
-        || (abs(newGeometry.height() - oldGeometry.height()) > LV_ACCURACY && heightValid()))) {
-        updateSize();
-        updateWholeDocument();
-        moveCursorDelegate();
-    }
-    QQuickItem::geometryChanged(newGeometry, oldGeometry);
-
-}
-
-/*!
-    Ensures any delayed caching or data loading the class
-    needs to performed is complete.
-*/
-void TextEdit::componentComplete()
-{
-    Q_D(TextEdit);
-
-    QQuickItem::componentComplete();
-    if (!d->document || !d->control) return;
-
-    d->document->setBaseUrl(baseUrl());
-#ifndef QT_NO_TEXTHTML_PARSER
-    if (d->richText)
-        d->control->setHtml(d->text);
-    else
-#endif
-    if (!d->text.isEmpty())
-        d->control->setPlainText(d->text);
-
-    if (d->dirty) {
-        d->determineHorizontalAlignment();
-        d->updateDefaultTextOption();
-        updateSize();
-        d->dirty = false;
-    }
-    if (d->cursorComponent && isCursorVisible())
-        TextUtil::createCursor(d);
-}
-
-/*!
-    \qmlproperty bool QtQuick::TextEdit::selectByKeyboard
-    \since 5.1
-
-    Defaults to true when the editor is editable, and false
-    when read-only.
-
-    If true, the user can use the keyboard to select text
-    even if the editor is read-only. If false, the user
-    cannot use the keyboard to select text even if the
-    editor is editable.
-
-    \sa readOnly
-*/
-bool TextEdit::selectByKeyboard() const
-{
-    Q_D(const TextEdit);
-    if (d->selectByKeyboardSet)
-        return d->selectByKeyboard;
-    return !isReadOnly();
-}
-
-void TextEdit::setSelectByKeyboard(bool on)
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    bool was = selectByKeyboard();
-    if (!d->selectByKeyboardSet || was != on) {
-        d->selectByKeyboardSet = true;
-        d->selectByKeyboard = on;
-        if (on)
-            d->control->setTextInteractionFlags(d->control->textInteractionFlags() | Qt::TextSelectableByKeyboard);
-        else
-            d->control->setTextInteractionFlags(d->control->textInteractionFlags() & ~Qt::TextSelectableByKeyboard);
-        emit selectByKeyboardChanged(on);
-    }
-}
-
-/*!
-    \qmlproperty bool QtQuick::TextEdit::selectByMouse
-
-    Defaults to false.
-
-    If true, the user can use the mouse to select text in some
-    platform-specific way. Note that for some platforms this may
-    not be an appropriate interaction; it may conflict with how
-    the text needs to behave inside a Flickable, for example.
-*/
-bool TextEdit::selectByMouse() const
-{
-    Q_D(const TextEdit);
-    return d->selectByMouse;
-}
-
-void TextEdit::setSelectByMouse(bool on)
-{
-    Q_D(TextEdit);
-
-    d->selectByMouse = on;
-    setKeepMouseGrab(on);
-    if (on) {
-        if (d->control) d->control->setTextInteractionFlags(d->control->textInteractionFlags() | Qt::TextSelectableByMouse);
-    }
-    else if (d->control)
-        d->control->setTextInteractionFlags(d->control->textInteractionFlags() & ~Qt::TextSelectableByMouse);
-    emit selectByMouseChanged(on);
-
-}
-
-/*!
-    \qmlproperty enumeration QtQuick::TextEdit::mouseSelectionMode
-
-    Specifies how text should be selected using a mouse.
-
-    \list
-    \li TextEdit.SelectCharacters - The selection is updated with individual characters. (Default)
-    \li TextEdit.SelectWords - The selection is updated with whole words.
-    \endlist
-
-    This property only applies when \l selectByMouse is true.
-*/
-TextEdit::SelectionMode TextEdit::mouseSelectionMode() const
-{
-    Q_D(const TextEdit);
-    return d->mouseSelectionMode;
-}
-
-void TextEdit::setMouseSelectionMode(SelectionMode mode)
-{
-    Q_D(TextEdit);
-
-    d->mouseSelectionMode = mode;
-    if (d->control) d->control->setWordSelectionEnabled(mode == SelectWords);
-    emit mouseSelectionModeChanged(mode);
-}
-
-/*!
-    \qmlproperty bool QtQuick::TextEdit::readOnly
-
-    Whether the user can interact with the TextEdit item. If this
-    property is set to true the text cannot be edited by user interaction.
-
-    By default this property is false.
-*/
-void TextEdit::setReadOnly(bool r)
-{
-    Q_D(TextEdit);
-
-    d->readOnly = r;
-#ifndef QT_NO_IM
-    setFlag(QQuickItem::ItemAcceptsInputMethod, !d->readOnly);
-#endif
-    Qt::TextInteractionFlags flags = Qt::LinksAccessibleByMouse;
-    if (d->selectByMouse)
-        flags = flags | Qt::TextSelectableByMouse;
-    if (d->selectByKeyboardSet && d->selectByKeyboard)
-        flags = flags | Qt::TextSelectableByKeyboard;
-    else if (!d->selectByKeyboardSet && !d->readOnly)
-        flags = flags | Qt::TextSelectableByKeyboard;
-    if (!d->readOnly)
-        flags = flags | Qt::TextEditable;
-    if (d->control)
-    {
-        d->control->setTextInteractionFlags(flags);
-        d->control->moveCursor(QTextCursor::End);
-    }
-
-#ifndef QT_NO_IM
-    updateInputMethod(Qt::ImEnabled);
-#endif
-    q_canPasteChanged();
-    emit readOnlyChanged(d->readOnly);
-    if (!d->selectByKeyboardSet)
-        emit selectByKeyboardChanged(!d->readOnly);
-    if (d->readOnly) {
-        setCursorVisible(false);
-    } else if (hasActiveFocus()) {
-        setCursorVisible(true);
-    }
-}
-
-bool TextEdit::isReadOnly() const
-{
-    Q_D(const TextEdit);
-    return d->readOnly;
-}
-
-/*!
-    \qmlproperty rectangle QtQuick::TextEdit::cursorRectangle
-
-    The rectangle where the standard text cursor is rendered
-    within the text edit. Read-only.
-
-    The position and height of a custom cursorDelegate are updated to follow the cursorRectangle
-    automatically when it changes.  The width of the delegate is unaffected by changes in the
-    cursor rectangle.
-*/
-QRectF TextEdit::cursorRectangle() const
-{
-    Q_D(const TextEdit);
-    if (!d->document || !d->control) return QRectF();
-
-    return d->control->cursorRect().translated(d->xoff, d->yoff);
-}
-
-bool TextEdit::event(QEvent *event)
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return QQuickItem::event(event);
-
-    if (event->type() == QEvent::ShortcutOverride) {
-        d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
-        return event->isAccepted();
-    }
-    return QQuickItem::event(event);
-}
-
-/*!
-\overload
-Handles the given key \a event.
-*/
-void TextEdit::keyPressEvent(QKeyEvent *event)
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control)
-    {
-        QQuickItem::keyPressEvent(event);
-        return;
-    }
-
-    d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
-    if (!event->isAccepted())
-        QQuickItem::keyPressEvent(event);
-}
-
-/*!
-\overload
-Handles the given key \a event.
-*/
-void TextEdit::keyReleaseEvent(QKeyEvent *event)
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control)
-    {
-        QQuickItem::keyReleaseEvent(event);
-        return;
-    }
-    d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
-    if (!event->isAccepted())
-        QQuickItem::keyReleaseEvent(event);
-}
-
-/*!
-    \qmlmethod QtQuick::TextEdit::deselect()
-
-    Removes active text selection.
-*/
-void TextEdit::deselect()
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    QTextCursor c = d->control->textCursor();
-    c.clearSelection();
-    d->control->setTextCursor(c);
-}
-
-/*!
-    \qmlmethod QtQuick::TextEdit::selectAll()
-
-    Causes all text to be selected.
-*/
-void TextEdit::selectAll()
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    d->control->selectAll();
-}
-
-/*!
-    \qmlmethod QtQuick::TextEdit::selectWord()
-
-    Causes the word closest to the current cursor position to be selected.
-*/
-void TextEdit::selectWord()
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    QTextCursor c = d->control->textCursor();
-    c.select(QTextCursor::WordUnderCursor);
-    d->control->setTextCursor(c);
-}
-
-/*!
-    \qmlmethod QtQuick::TextEdit::select(int start, int end)
-
-    Causes the text from \a start to \a end to be selected.
-
-    If either start or end is out of range, the selection is not changed.
-
-    After calling this, selectionStart will become the lesser
-    and selectionEnd will become the greater (regardless of the order passed
-    to this method).
-
-    \sa selectionStart, selectionEnd
-*/
-void TextEdit::select(int start, int end)
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    if (start < 0 || end < 0 || start >= d->document->characterCount() || end >= d->document->characterCount())
-        return;
-    QTextCursor cursor = d->control->textCursor();
-    cursor.beginEditBlock();
-    cursor.setPosition(start, QTextCursor::MoveAnchor);
-    cursor.setPosition(end, QTextCursor::KeepAnchor);
-    cursor.endEditBlock();
-    d->control->setTextCursor(cursor);
-
-    // QTBUG-11100
-    updateSelection();
-    updateInputMethod();
-}
-
-/*!
-    \qmlmethod QtQuick::TextEdit::isRightToLeft(int start, int end)
-
-    Returns true if the natural reading direction of the editor text
-    found between positions \a start and \a end is right to left.
-*/
-bool TextEdit::isRightToLeft(int start, int end)
-{
-    if (start > end) {
-        qmlInfo(this) << "isRightToLeft(start, end) called with the end property being smaller than the start.";
-        return false;
-    } else {
-        return getText(start, end).isRightToLeft();
-    }
-}
-
-#ifndef QT_NO_CLIPBOARD
-/*!
-    \qmlmethod QtQuick::TextEdit::cut()
-
-    Moves the currently selected text to the system clipboard.
-*/
-void TextEdit::cut()
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    d->control->cut();
-}
-
-/*!
-    \qmlmethod QtQuick::TextEdit::copy()
-
-    Copies the currently selected text to the system clipboard.
-*/
-void TextEdit::copy()
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    d->control->copy();
-}
-
-/*!
-    \qmlmethod QtQuick::TextEdit::paste()
-
-    Replaces the currently selected text by the contents of the system clipboard.
-*/
-void TextEdit::paste()
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    d->control->paste();
-}
-#endif // QT_NO_CLIPBOARD
-
-
-/*!
-    \qmlmethod QtQuick::TextEdit::undo()
-
-    Undoes the last operation if undo is \l {canUndo}{available}. Deselects any
-    current selection, and updates the selection start to the current cursor
-    position.
-*/
-
-void TextEdit::undo()
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    d->control->undo();
-}
-
-/*!
-    \qmlmethod QtQuick::TextEdit::redo()
-
-    Redoes the last operation if redo is \l {canRedo}{available}.
-*/
-
-void TextEdit::redo()
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    d->control->redo();
-}
-
-/*!
-\overload
-Handles the given mouse \a event.
-*/
-void TextEdit::mousePressEvent(QMouseEvent *event)
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control)
-    {
-        QQuickItem::mousePressEvent(event);
-        return;
-    }
-
-    d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
-    if (d->focusOnPress){
-        bool hadActiveFocus = hasActiveFocus();
-        forceActiveFocus(Qt::MouseFocusReason);
-        // re-open input panel on press if already focused
-#ifndef QT_NO_IM
-        if (hasActiveFocus() && hadActiveFocus && !isReadOnly())
-            qGuiApp->inputMethod()->show();
-#else
-        Q_UNUSED(hadActiveFocus);
-#endif
-    }
-    if (!event->isAccepted())
-        QQuickItem::mousePressEvent(event);
-}
-
-/*!
-\overload
-Handles the given mouse \a event.
-*/
-void TextEdit::mouseReleaseEvent(QMouseEvent *event)
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control)
-    {
-        QQuickItem::mouseReleaseEvent(event);
-        return;
-    }
-    d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
-
-    if (!event->isAccepted())
-        QQuickItem::mouseReleaseEvent(event);
-}
-
-/*!
-\overload
-Handles the given mouse \a event.
-*/
-void TextEdit::mouseDoubleClickEvent(QMouseEvent *event)
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control)
-    {
-        QQuickItem::mouseDoubleClickEvent(event);
-        return;
-    }
-    d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
-    if (!event->isAccepted())
-        QQuickItem::mouseDoubleClickEvent(event);
-}
-
-/*!
-\overload
-Handles the given mouse \a event.
-*/
-void TextEdit::mouseMoveEvent(QMouseEvent *event)
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control)
-    {
-        QQuickItem::mouseMoveEvent(event);
-        return;
-    }
-    d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
-    if (!event->isAccepted())
-        QQuickItem::mouseMoveEvent(event);
-}
-
-#ifndef QT_NO_IM
-/*!
-\overload
-Handles the given input method \a event.
-*/
-void TextEdit::inputMethodEvent(QInputMethodEvent *event)
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-    const bool wasComposing = isInputMethodComposing();
-    d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
-    setCursorVisible(d->control->cursorVisible());
-    if (wasComposing != isInputMethodComposing())
-        emit inputMethodComposingChanged();
-}
-
-/*!
-\overload
-Returns the value of the given \a property and \a argument.
-*/
-QVariant TextEdit::inputMethodQuery(Qt::InputMethodQuery property, QVariant argument) const
-{
-    Q_D(const TextEdit);
-
-    QVariant v;
-    switch (property) {
-    case Qt::ImEnabled:
-        v = static_cast<bool>(flags() & ItemAcceptsInputMethod);
-        break;
-    case Qt::ImHints:
-        v = static_cast<int>(d->effectiveInputMethodHints());
-        break;
-    case Qt::ImInputItemClipRectangle:
-        v = QQuickItem::inputMethodQuery(property);
-        break;
-    default:
-        if (property == Qt::ImCursorPosition && !argument.isNull())
-            argument = QVariant(argument.toPointF() - QPointF(d->xoff, d->yoff));
-        if (!d->document || !d->control) break;
-        v = d->control->inputMethodQuery(property, argument);
-        if (property == Qt::ImCursorRectangle || property == Qt::ImAnchorRectangle)
-            v = QVariant(v.toRectF().translated(d->xoff, d->yoff));
-        break;
-    }
-    return v;
-}
-
-/*!
-\overload
-Returns the value of the given \a property.
-*/
-QVariant TextEdit::inputMethodQuery(Qt::InputMethodQuery property) const
-{
-    return inputMethodQuery(property, QVariant());
-}
-#endif // QT_NO_IM
-
-void TextEdit::triggerPreprocess()
-{
-    Q_D(TextEdit);
-    if (d->updateType == TextEditPrivate::UpdateNone)
-        d->updateType = TextEditPrivate::UpdateOnlyPreprocess;
-    polish();
-    update();
-}
-
-typedef QList<TextEditPrivate::Node*>::iterator TextNodeIterator;
-
-
-static bool comesBefore(TextEditPrivate::Node* n1, TextEditPrivate::Node* n2)
-{
-    return n1->startPos() < n2->startPos();
-}
-
-static inline void updateNodeTransform(TextNode* node, const QPointF &topLeft)
-{
-    QMatrix4x4 transformMatrix;
-    transformMatrix.translate(static_cast<float>(topLeft.x()), static_cast<float>(topLeft.y()));
-    node->setMatrix(transformMatrix);
-}
-
-/*!
- * \internal
- *
- * Invalidates font caches owned by the text objects owned by the element
- * to work around the fact that text objects cannot be used from multiple threads.
- */
-void TextEdit::invalidateFontCaches()
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-
-    QTextBlock block;
-    for (block = d->document->firstBlock(); block.isValid(); block = block.next()) {
-        if (block.layout() != nullptr && block.layout()->engine() != nullptr)
-            block.layout()->engine()->resetFontEngineCache();
-    }
-}
-
-inline void resetEngine(TextNodeEngine *engine, const QColor& textColor, const QColor& selectedTextColor, const QColor& selectionColor)
-{
-    *engine = TextNodeEngine();
-    engine->setTextColor(textColor);
-    engine->setSelectedTextColor(selectedTextColor);
-    engine->setSelectionColor(selectionColor);
-}
-
-QSGNode *TextEdit::updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData *updatePaintNodeData)
-{
-    Q_UNUSED(updatePaintNodeData);
-    Q_D(TextEdit);
-
-    if (!d->document || !d->control) {
-        if (oldNode) delete oldNode;
-        return nullptr;
-    }
-
-    if (d->updateType != TextEditPrivate::UpdatePaintNode && oldNode != nullptr) {
-        // Update done in preprocess() in the nodes
-        d->updateType = TextEditPrivate::UpdateNone;
-        return oldNode;
-    }
-
-    d->updateType = TextEditPrivate::UpdateNone;
-
-    if (!oldNode) {
-        // If we had any QQuickTextNode node references, they were deleted along with the root node
-        // But here we must delete the Node structures in textNodeMap
-        qDeleteAll(d->textNodeMap);
-        d->textNodeMap.clear();
-    }
-
-    RootNode *rootNode = static_cast<RootNode *>(oldNode);
-    TextNodeIterator nodeIterator = d->textNodeMap.begin();
-
-    while (nodeIterator != d->textNodeMap.end() && !(*nodeIterator)->dirty())
-        ++nodeIterator;
-
-    TextNodeEngine engine;
-    TextNodeEngine frameDecorationsEngine;
-
-    d->lastHighlightChangeStart = INT_MAX;
-    d->lastHighlightChangeEnd   = 0;
-
-    if (!oldNode || nodeIterator < d->textNodeMap.end()) {
-
-        if (!oldNode)
-            rootNode = new RootNode;
-
-        int firstDirtyPos = 0;
-        if (nodeIterator != d->textNodeMap.end()) {
-            firstDirtyPos = (*nodeIterator)->startPos();
-            do {
-                rootNode->removeChildNode((*nodeIterator)->textNode());
-                delete (*nodeIterator)->textNode();
-                delete *nodeIterator;
-                nodeIterator = d->textNodeMap.erase(nodeIterator);
-            } while (nodeIterator != d->textNodeMap.end() && (d->invalidUntilTheEnd || (*nodeIterator)->dirty()));
-        }
-
-        // FIXME: the text decorations could probably be handled separately (only updated for affected textFrames)
-        rootNode->resetFrameDecorations(d->createTextNode());
-        resetEngine(&frameDecorationsEngine, d->color, d->selectedTextColor, d->selectionColor);
-
-        TextNode *node = nullptr;
-
-        int currentNodeSize = 0;
-        int nodeStart = firstDirtyPos;
-        QPointF basePosition(d->xoff, d->yoff);
-        QMatrix4x4 basePositionMatrix;
-        basePositionMatrix.translate(static_cast<float>(basePosition.x()), static_cast<float>(basePosition.y()));
-        rootNode->setMatrix(basePositionMatrix);
-
-        QPointF nodeOffset;
-        TextEditPrivate::Node *firstCleanNode = (nodeIterator != d->textNodeMap.end() && !d->invalidUntilTheEnd) ? *nodeIterator : nullptr;
-
-        d->invalidUntilTheEnd = false;
-
-        if (d->document && d->control) {
-            QList<QTextFrame *> frames;
-            frames.append(d->document->rootFrame());
-
-            while (!frames.isEmpty()) { //INFO: Root frame
-                QTextFrame *textFrame = frames.takeFirst();
-                frames.append(textFrame->childFrames());
-                frameDecorationsEngine.addFrameDecorations(d->document, textFrame);
-
-                if (textFrame->lastPosition() < firstDirtyPos || (firstCleanNode && textFrame->firstPosition() >= firstCleanNode->startPos()))
-                    continue;
-
-                //INFO: creating the text node
-                node = d->createTextNode();
-                resetEngine(&engine, d->color, d->selectedTextColor, d->selectionColor);
-
-                if (textFrame->firstPosition() > textFrame->lastPosition()
-                        && textFrame->frameFormat().position() != QTextFrameFormat::InFlow) {
-
-                    updateNodeTransform(node, dynamic_cast<TextDocumentLayout*>(d->document->documentLayout())->frameBoundingRect(textFrame).topLeft());
-                    const int pos = textFrame->firstPosition() - 1;
-                    ProtectedLayoutAccessor *a = static_cast<ProtectedLayoutAccessor *>(d->document->documentLayout());
-                    QTextCharFormat format = a->formatAccessor(pos);
-                    QTextBlock block = textFrame->firstCursorPosition().block();
-                    engine.setCurrentLine(block.layout()->lineForTextPosition(pos - block.position()));
-                    engine.addTextObject(QPointF(0, 0), format, TextNodeEngine::Unselected, d->document,
-                                                  pos, textFrame->frameFormat().position());
-                    nodeStart = pos;
-                } else {
-                    // Having nodes spanning across frame boundaries will break the current bookkeeping mechanism. We need to prevent that.
-                    QList<int> frameBoundaries;
-                    frameBoundaries.reserve(frames.size());
-                    Q_FOREACH (QTextFrame *frame, frames)
-                        frameBoundaries.append(frame->firstPosition());
-                    std::sort(frameBoundaries.begin(), frameBoundaries.end());
-
-                    QTextFrame::iterator it = textFrame->begin();
-
-                    while (!it.atEnd()) {
-
-                        QTextBlock block = it.currentBlock();
-                        ++it;
-
-                        if (block.position() < firstDirtyPos)
-                            continue;
-
-                        if (!block.isVisible()) continue;
-
-                        if (!engine.hasContents()) {
-                            nodeOffset = dynamic_cast<TextDocumentLayout*>(d->document->documentLayout())->blockBoundingRect(block).topLeft();
-                            updateNodeTransform(node, nodeOffset);
-
-                            // PALETTE
-                            int offset = d->paletteManager->drawingOffset(block.blockNumber(), false);
-                            nodeOffset.setY(nodeOffset.y() - offset);
-
-                            nodeStart = block.position();
-                        }
-
-                        engine.addTextBlock(d->document, block, -nodeOffset, d->color, QColor(), selectionStart(), selectionEnd() - 1);
-                        currentNodeSize += block.length();
-
-                        if ((it.atEnd()) || (firstCleanNode && block.next().position() >= firstCleanNode->startPos())) // last node that needed replacing or last block of the frame
-                            break;
-
-                        QList<int>::const_iterator lowerBound = std::lower_bound(frameBoundaries.constBegin(), frameBoundaries.constEnd(), block.next().position());
-                        if (currentNodeSize > nodeBreakingSize || lowerBound == frameBoundaries.constEnd() || *lowerBound > nodeStart) {
-                            currentNodeSize = 0;
-                            d->addCurrentTextNodeToRoot(&engine, rootNode, node, nodeIterator, nodeStart);
-                            node = d->createTextNode();
-                            resetEngine(&engine, d->color, d->selectedTextColor, d->selectionColor);
-                            nodeStart = block.next().position();
-                        }
-                    }
-                }
-                d->addCurrentTextNodeToRoot(&engine, rootNode, node, nodeIterator, nodeStart);
-            }
-        }
-
-
-        frameDecorationsEngine.addToSceneGraph(rootNode->frameDecorationsNode, QQuickText::Normal, QColor());
-        // Now prepend the frame decorations since we want them rendered first, with the text nodes and cursor in front.
-        rootNode->prependChildNode(rootNode->frameDecorationsNode);
-
-        Q_ASSERT(nodeIterator == d->textNodeMap.end() || (*nodeIterator) == firstCleanNode);
-        // Update the position of the subsequent text blocks.
-        if (d->document && firstCleanNode) {
-            QPointF oldOffset = firstCleanNode->textNode()->matrix().map(QPointF(0,0));
-            QPointF currentOffset = dynamic_cast<TextDocumentLayout*>(d->document->documentLayout())->blockBoundingRect(d->document->findBlock(firstCleanNode->startPos())).topLeft();
-            QPointF delta = currentOffset - oldOffset;
-            while (nodeIterator != d->textNodeMap.end()) {
-                QMatrix4x4 transformMatrix = (*nodeIterator)->textNode()->matrix();
-                transformMatrix.translate(static_cast<float>(delta.x()), static_cast<float>(delta.y()));
-                (*nodeIterator)->textNode()->setMatrix(transformMatrix);
-                ++nodeIterator;
-            }
-
-        }
-
-        // Since we iterate over blocks from different text frames that are potentially not sorted
-        // we need to ensure that our list of nodes is sorted again:
-        std::sort(d->textNodeMap.begin(), d->textNodeMap.end(), &comesBefore);
-    }
-
-    if (d->document && d->control && d->cursorComponent == nullptr) {
-        QSGRectangleNode* cursor = nullptr;
-#if (QT_VERSION > QT_VERSION_CHECK(5,7,1))
-        if (!isReadOnly() && d->cursorVisible && d->control->cursorOn()){ // change for 5.11
-            cursor = d->sceneGraphContext()->createRectangleNode();
-            cursor->setRect(d->control->cursorRect());
-            cursor->setColor(d->color);
-        }
-#else
-        if (!isReadOnly() && d->cursorVisible && d->control->cursorOn())
-            cursor = d->sceneGraphContext()->createRectangleNode(d->control->cursorRect(), d->color);
-#endif
-        rootNode->resetCursorNode(cursor);
-    }
-
-    invalidateFontCaches();
-
-    return rootNode;
-}
-
-void TextEdit::updatePolish()
-{
-    invalidateFontCaches();
-}
-
-/*!
-    \qmlproperty bool QtQuick::TextEdit::canPaste
-
-    Returns true if the TextEdit is writable and the content of the clipboard is
-    suitable for pasting into the TextEdit.
-*/
-bool TextEdit::canPaste() const
-{
-    Q_D(const TextEdit);
-    if (!d->document || !d->control) return false;
-
-    if (!d->canPasteValid) {
-        const_cast<TextEditPrivate *>(d)->canPaste = d->control->canPaste();
-        const_cast<TextEditPrivate *>(d)->canPasteValid = true;
-    }
-    return d->canPaste;
-}
-
-/*!
-    \qmlproperty bool QtQuick::TextEdit::canUndo
-
-    Returns true if the TextEdit is writable and there are previous operations
-    that can be undone.
-*/
-
-bool TextEdit::canUndo() const
-{
-    Q_D(const TextEdit);
-    if (!d->document) return false;
-
-    return d->document->isUndoAvailable();
-}
-
-/*!
-    \qmlproperty bool QtQuick::TextEdit::canRedo
-
-    Returns true if the TextEdit is writable and there are \l {undo}{undone}
-    operations that can be redone.
-*/
-
-bool TextEdit::canRedo() const
-{
-    Q_D(const TextEdit);
-    if (!d->document) return false;
-
-    return d->document->isRedoAvailable();
-}
-
-/*!
-    \qmlproperty bool QtQuick::TextEdit::inputMethodComposing
-
-
-    This property holds whether the TextEdit has partial text input from an
-    input method.
-
-    While it is composing an input method may rely on mouse or key events from
-    the TextEdit to edit or commit the partial text.  This property can be used
-    to determine when to disable events handlers that may interfere with the
-    correct operation of an input method.
-*/
-bool TextEdit::isInputMethodComposing() const
-{
-#ifdef QT_NO_IM
-    return false;
-#else
-    Q_D(const TextEdit);
-    if (!d->document || !d->control) return false;
-    return d->control->hasImState();
-#endif // QT_NO_IM
-}
-
-TextEditPrivate::ExtraData::ExtraData()
-    : padding(0)
-    , topPadding(0)
-    , leftPadding(0)
-    , rightPadding(0)
-    , bottomPadding(0)
-    , explicitTopPadding(false)
-    , explicitLeftPadding(false)
-    , explicitRightPadding(false)
-    , explicitBottomPadding(false)
-    , implicitResize(true)
-{
-}
-
-void TextEditPrivate::setTextDocument(QTextDocument *doc)
-{
-
-    if (document)
-        unsetTextDocument();
-    Q_Q(TextEdit);
-    document = doc;
-    if (q->getDocumentLayout()->lineManagerParentDocument() != document)
-    {
-        q->getDocumentLayout()->setLineManagerParentDocument(document);
-    }
-
-    if (lineSurface)
-        lineSurface->setDocument(q->getDocumentLayout()->lineDocument());
-
-    control = new TextControl(document, q);
-    control->setTextInteractionFlags(Qt::LinksAccessibleByMouse | Qt::TextSelectableByKeyboard | Qt::TextEditable);
-    control->setAcceptRichText(false);
-    control->setCursorIsFocusIndicator(true);
-
-    control->setTextEdit(q);
-
-    lv_qmlobject_connect(control, TextControl, SIGNAL(updateCursorRequest()), q, TextEdit, SLOT(updateCursor()));
-    lv_qmlobject_connect(control, TextControl, SIGNAL(selectionChanged()), q, TextEdit, SIGNAL(selectedTextChanged()));
-    lv_qmlobject_connect(control, TextControl, SIGNAL(selectionChanged()), q, TextEdit, SLOT(updateSelection()));
-    lv_qmlobject_connect(control, TextControl, SIGNAL(cursorPositionChanged()), q, TextEdit, SLOT(updateSelection()));
-    lv_qmlobject_connect(control, TextControl, SIGNAL(cursorPositionChanged()), q, TextEdit, SIGNAL(cursorPositionChanged()));
-    lv_qmlobject_connect(control, TextControl, SIGNAL(cursorPositionChanged()), q, TextEdit, SIGNAL(lineNumberChanged()));
-    lv_qmlobject_connect(control, TextControl, SIGNAL(cursorPositionChanged()), q, TextEdit, SIGNAL(columnNumberChanged()));
-    lv_qmlobject_connect(control, TextControl, SIGNAL(cursorRectangleChanged()), q, TextEdit, SLOT(moveCursorDelegate()));
-    lv_qmlobject_connect(control, TextControl, SIGNAL(linkActivated(QString)), q, TextEdit, SIGNAL(linkActivated(QString)));
-    lv_qmlobject_connect(control, TextControl, SIGNAL(linkHovered(QString)), q, TextEdit, SIGNAL(linkHovered(QString)));
-    lv_qmlobject_connect(control, TextControl, SIGNAL(textChanged()), q, TextEdit, SLOT(q_textChanged()));
-    lv_qmlobject_connect(control, TextControl, SIGNAL(preeditTextChanged()), q, TextEdit, SIGNAL(preeditTextChanged()));
-    /*#if QT_CONFIG(clipboard)
-        qmlobject_connect(QGuiApplication::clipboard(), QClipboard, SIGNAL(dataChanged()), q, QQuickTextEdit, SLOT(q_canPasteChanged()));
-    #endif*/
-    lv_qmlobject_connect(document, QTextDocument, SIGNAL(undoAvailable(bool)), q, TextEdit, SIGNAL(canUndoChanged()));
-    lv_qmlobject_connect(document, QTextDocument, SIGNAL(redoAvailable(bool)), q, TextEdit, SIGNAL(canRedoChanged()));
-
-    if (document->defaultFont() != font && font.pixelSize() > 0)
-    {
-        q->getDocumentLayout()->setLineDocumentFont(font);
-        document->setDefaultFont(font);
-    }
-
-
-    if (document->documentMargin() != textMargin)
-    {
-        document->setDocumentMargin(textMargin);
-    }
-    document->setUndoRedoEnabled(false); // flush undo buffer.
-    document->setUndoRedoEnabled(true);
-
-    q->setCursorVisible(cursorVisible);
-    q->setSelectByMouse(selectByMouse);
-    q->setMouseSelectionMode(mouseSelectionMode);
-    q->setReadOnly(readOnly);
-    updateDefaultTextOption();
-    q->updateSize();
-
-    q->getDocumentLayout()->textDocumentFinishedUpdating(document->blockCount());
-
-    QObject::connect(document, &QTextDocument::contentsChange, q, &TextEdit::q_contentsChange);
-    QObject::connect(document->documentLayout(), &QAbstractTextDocumentLayout::updateBlock, q, &TextEdit::invalidateBlock);
-    QObject::connect(document->documentLayout(), &QAbstractTextDocumentLayout::update, q, &TextEdit::highlightingDone);
-    QObject::connect(q->getDocumentLayout(), &TextDocumentLayout::linesCollapsed,
-                     q, &TextEdit::handleCursorDuringCollapse);
-    QObject::connect(q->getDocumentLayout(), &TextDocumentLayout::linesCollapsed,
-                     q, &TextEdit::checkPalettesWhenCollapsed);
-    QObject::connect(q->getDocumentLayout(), &TextDocumentLayout::updateLineSurfaceSignal,
-                     q, &TextEdit::updateLineSurface);
-
-    document->setTextWidth(-1);
-    auto rect = q->getDocumentLayout()->blockBoundingRect(document->rootFrame()->begin().currentBlock());
-    paletteManager->setLineHeight(static_cast<int>(rect.height()));
-    q->updateFragmentVisibility();
-}
-
-void TextEditPrivate::unsetTextDocument()
-{
-    Q_Q(TextEdit);
-    if ( document ){
-
-        q->markDirtyNodesForRange(0, document->characterCount(), 0);
-        lineSurface->unsetTextDocument();
-
-        QObject::disconnect(document, &QTextDocument::undoAvailable, q, &TextEdit::canUndoChanged);
-        QObject::disconnect(document, &QTextDocument::redoAvailable, q, &TextEdit::canRedoChanged);
-
-        QObject::disconnect(document, &QTextDocument::contentsChange, q, &TextEdit::q_contentsChange);
-        QObject::disconnect(document->documentLayout(), &QAbstractTextDocumentLayout::updateBlock, q, &TextEdit::invalidateBlock);
-        QObject::disconnect(document->documentLayout(), &QAbstractTextDocumentLayout::update, q, &TextEdit::highlightingDone);
-    }
-
-
-    if (control)
-    {
-        control->disconnect();
-        delete control;
-        control = nullptr;
-    }
-
-    document = nullptr;
-
-    q->polish();
-    if (q->isComponentComplete()) {
-        updateType = TextEditPrivate::UpdatePaintNode;
-        q->update();
-    }
-
-}
-
-void TextEditPrivate::init()
-{
-    Q_Q(TextEdit);
-
-#ifndef QT_NO_CLIPBOARD
-    if (QGuiApplication::clipboard()->supportsSelection())
-        q->setAcceptedMouseButtons(Qt::LeftButton | Qt::MiddleButton);
-    else
-#endif
-        q->setAcceptedMouseButtons(Qt::LeftButton);
-
-#ifndef QT_NO_IM
-    q->setFlag(QQuickItem::ItemAcceptsInputMethod);
-#endif
-    q->setFlag(QQuickItem::ItemHasContents);
-
-    q->setAcceptHoverEvents(true);
-
-
-#ifndef QT_NO_CLIPBOARD
-    lv_qmlobject_connect(QGuiApplication::clipboard(), QClipboard, SIGNAL(dataChanged()), q, TextEdit, SLOT(q_canPasteChanged()));
-#endif
-
-    fragmentStartPalette = new QQuickItem(q);
-    fragmentEndPalette = new QQuickItem(q);
-    fragmentStartPalette->setObjectName("fragmentStartPalette");
-    fragmentEndPalette->setObjectName("fragmentEndPalette");
-
-    paletteManager->setTextEdit(q);
-}
-
-void TextEditPrivate::resetInputMethod()
-{
-    Q_Q(TextEdit);
-    if (!q->isReadOnly() && q->hasActiveFocus() && qGuiApp)
-        QGuiApplication::inputMethod()->reset();
-}
-
-void TextEdit::q_textChanged()
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-    d->textCached = false;
-    for (QTextBlock it = d->document->begin(); it != d->document->end(); it = it.next()) {
-        d->contentDirection = d->textDirection(it.text());
-        if (d->contentDirection != Qt::LayoutDirectionAuto)
-            break;
-    }
-    d->determineHorizontalAlignment();
-    d->updateDefaultTextOption();
-    updateSize();
-    emit textChanged();
-}
-
-void TextEdit::markDirtyNodesForRange(int start, int end, int charDelta)
-{
-    Q_D(TextEdit);
-    if (start == end)
-        return;
-
-    int oldEnd = end;
-    bool nodesUpdate = true;
-
-    if ( start < d->lastHighlightChangeStart && end > d->lastHighlightChangeEnd ){ // stretch both ways
-        d->lastHighlightChangeStart = start;
-        d->lastHighlightChangeEnd   = end;
-    } else if ( start < d->lastHighlightChangeStart ){ // stretch left
-        end = d->lastHighlightChangeStart;
-        d->lastHighlightChangeStart = start;
-    } else if ( end > d->lastHighlightChangeEnd ){ // stretch right
-        start = d->lastHighlightChangeEnd;
-        d->lastHighlightChangeEnd = end;
-    } else {
-        nodesUpdate = false; // this is inside the interval we're updating
-    }
-
-    if (start == end) nodesUpdate = false;
-
-    TextEditPrivate::Node dummyNode(start, nullptr);
-    TextNodeIterator it = std::lower_bound(d->textNodeMap.begin(), d->textNodeMap.end(), &dummyNode, &comesBefore);
-    if (nodesUpdate || charDelta)
-    {
-        // qLowerBound gives us the first node past the start of the affected portion, rewind to the first node
-        // that starts at the last position before the edit position. (there might be several because of images)
-        if (it != d->textNodeMap.begin()) {
-            --it;
-            TextEditPrivate::Node otherDummy((*it)->startPos(), nullptr);
-            it = std::lower_bound(d->textNodeMap.begin(), d->textNodeMap.end(), &otherDummy, &comesBefore);
-        }
-    }
-
-    TextNodeIterator otherIt = it;
-
-    if (nodesUpdate)
-    {
-        while (it != d->textNodeMap.end() && (*it)->startPos() <= end)
-        {
-            (*it)->setDirty(); ++it;
-        }
-    }
-
-    if (charDelta)
-    {
-        while (otherIt != d->textNodeMap.end() && (*otherIt)->startPos() <= oldEnd)
-        {
-            ++otherIt;
-        }
-
-        while (otherIt != d->textNodeMap.end())
-        {
-            (*otherIt)->moveStartPos(charDelta);
-            ++otherIt;
-        }
-    }
-}
-
-void TextEdit::q_contentsChange(int pos, int charsRemoved, int charsAdded)
-{
-    Q_D(TextEdit);
-
-
-    const int editRange = pos + qMax(charsAdded, charsRemoved);
-    const int delta = charsAdded - charsRemoved;
-
-    std::list<QQuickItem*> results = getPaletteManager()->updatePaletteBounds(pos, charsRemoved, charsAdded);
-    if (!results.empty())
-    {
-        for (auto it = results.begin(); it != results.end(); ++it)
-        {
-            QMetaObject::invokeMethod(*it, "close", Qt::DirectConnection);
-        }
-    }
-
-
-    if (d->document && dynamic_cast<TextDocumentLayout*>(d->document->documentLayout()))
-    {
-        d->dirtyPosition = d->document->findBlock(pos).blockNumber();
-        getDocumentLayout()->setDirtyPos(d->dirtyPosition);
-        getPaletteManager()->setDirtyPos(d->dirtyPosition);
-    }
-
-    markDirtyNodesForRange(pos, editRange, delta);
-
-    d->highlightingInProgress = true;
-
-    polish();
-    if (isComponentComplete()) {
-        d->updateType = TextEditPrivate::UpdatePaintNode;
-        update();
-    }
-}
-
-void TextEdit::moveCursorDelegate()
-{
-    Q_D(TextEdit);
-#ifndef QT_NO_IM
-    updateInputMethod();
-#endif
-    emit cursorRectangleChanged();
-    if (!d->cursorItem)
-        return;
-    QRectF cursorRect = cursorRectangle();
-    d->cursorItem->setX(cursorRect.x());
-    d->cursorItem->setY(cursorRect.y());
-}
-
-void TextEdit::updateSelection()
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    // No need for node updates when we go from an empty selection to another empty selection
-    if (d->control->textCursor().hasSelection() || d->hadSelection) {
-        markDirtyNodesForRange(qMin(d->lastSelectionStart, d->control->textCursor().selectionStart()), qMax(d->control->textCursor().selectionEnd(), d->lastSelectionEnd), 0);
-        polish();
-        if (isComponentComplete()) {
-            d->updateType = TextEditPrivate::UpdatePaintNode;
-            update();
-        }
-    }
-
-    d->hadSelection = d->control->textCursor().hasSelection();
-
-    if (d->lastSelectionStart != d->control->textCursor().selectionStart()) {
-        d->lastSelectionStart = d->control->textCursor().selectionStart();
-        emit selectionStartChanged();
-    }
-    if (d->lastSelectionEnd != d->control->textCursor().selectionEnd()) {
-        d->lastSelectionEnd = d->control->textCursor().selectionEnd();
-        emit selectionEndChanged();
-    }
-}
-
-QRectF TextEdit::boundingRect() const
-{
-    Q_D(const TextEdit);
-    if (!d->document || !d->control) return QRectF();
-
-    QRectF r(
-            TextUtil::alignedX(d->contentSize.width(), width(), effectiveHAlign()),
-            d->yoff,
-            d->contentSize.width(),
-            d->contentSize.height());
-
-    int cursorWidth = 1;
-    if (d->cursorItem)
-        cursorWidth = 0;
-    else if (!d->document->isEmpty())
-        cursorWidth += 3;// ### Need a better way of accounting for space between char and cursor
-
-    // Could include font max left/right bearings to either side of rectangle.
-    r.setRight(r.right() + cursorWidth);
-
-    return r;
-}
-
-QRectF TextEdit::clipRect() const
-{
-    Q_D(const TextEdit);
-    QRectF r = QQuickItem::clipRect();
-    if (!d->document || !d->control) return r;
-
-    int cursorWidth = 1;
-    if (d->cursorItem)
-        cursorWidth = static_cast<int>(d->cursorItem->width());
-    if (!d->document->isEmpty())
-        cursorWidth += 3;// ### Need a better way of accounting for space between char and cursor
-
-    // Could include font max left/right bearings to either side of rectangle.
-
-    r.setRight(r.right() + cursorWidth);
-    return r;
-}
-
-qreal TextEditPrivate::getImplicitWidth() const
-{
-    Q_Q(const TextEdit);
-    if (!requireImplicitWidth) {
-        // We don't calculate implicitWidth unless it is required.
-        // We need to force a size update now to ensure implicitWidth is calculated
-        const_cast<TextEditPrivate*>(this)->requireImplicitWidth = true;
-        const_cast<TextEdit*>(q)->updateSize();
-    }
-    return implicitWidth;
-}
-
-//### we should perhaps be a bit smarter here -- depending on what has changed, we shouldn't
-//    need to do all the calculations each time
-void TextEdit::updateSize()
-{
-    Q_D(TextEdit);
-
-    if (!isComponentComplete()) {
-        d->dirty = true;
-        return;
-    }
-
-    if (!d->document || !d->control) return;
-
-    if (d->document->textWidth() != -1 )
-        d->document->setTextWidth(-1);
-
-    qreal naturalWidth = d->implicitWidth - leftPadding() - rightPadding();
-
-
-    qreal newWidth = d->document->idealWidth();
-    // ### assumes that if the width is set, the text will fill to edges
-    // ### (unless wrap is false, then clipping will occur)
-    if (widthValid()) {
-        if (!d->requireImplicitWidth) {
-            emit implicitWidthChanged();
-            // if the implicitWidth is used, then updateSize() has already been called (recursively)
-            if (d->requireImplicitWidth)
-                return;
-        }
-        if (d->requireImplicitWidth) {
-            d->document->setTextWidth(-1);
-            naturalWidth = d->document->idealWidth();
-
-            const bool wasInLayout = d->inLayout;
-            d->inLayout = true;
-            if (d->isImplicitResizeEnabled())
-                setImplicitWidth(naturalWidth + leftPadding() + rightPadding());
-            d->inLayout = wasInLayout;
-            if (d->inLayout)    // probably the result of a binding loop, but by letting it
-                return;         // get this far we'll get a warning to that effect.
-        }
-//        d->document->setTextWidth(-1);
-//        if (abs(d->document->textWidth() - width()) > LV_ACCURACY) {
-//            d->document->setTextWidth(width() - leftPadding() - rightPadding());
-//            newWidth = d->document->idealWidth();
-//        }
-        //### need to confirm cost of always setting these
-    } else if (d->wrapMode == NoWrap && abs(d->document->textWidth() - newWidth) > LV_ACCURACY) {
-//        d->document->setTextWidth(newWidth); // ### Text does not align if width is not set or the idealWidth exceeds the textWidth (QTextDoc bug)
-    } else {
-//        d->document->setTextWidth(-1);
-    }
-
-    QFontMetricsF fm(d->font);
-    qreal newHeight = d->document->isEmpty() ? qCeil(fm.height()) : d->document->size().height();
-
-    if (d->isImplicitResizeEnabled()) {
-        // ### Setting the implicitWidth triggers another updateSize(), and unless there are bindings nothing has changed.
-        if (!widthValid() && !d->requireImplicitWidth)
-            setImplicitSize(newWidth + leftPadding() + rightPadding(), newHeight + topPadding() + bottomPadding());
-        else
-            setImplicitHeight(newHeight + topPadding() + bottomPadding());
-    }
-
-    d->xoff = leftPadding() + qMax(qreal(0), TextUtil::alignedX(d->document->size().width(), width() - leftPadding() - rightPadding(), effectiveHAlign()));
-    d->yoff = topPadding() + TextUtil::alignedY(d->document->size().height(), height() - topPadding() - bottomPadding(), d->vAlign);
-    setBaselineOffset(fm.ascent() + d->yoff + d->textMargin);
-
-    auto contentStart = d->document->findBlockByNumber(std::max(0,d->fragmentStart));
-    int contentSpan = std::min(d->fragmentEnd, d->document->blockCount()-1) - std::max(0, d->fragmentStart) + 1;
-    int width = 0, height = 0;
-    int lineHeight = 0;
-    for (int i = 0; i < contentSpan; i++)
-    {
-        auto rect = d->document->documentLayout()->blockBoundingRect(contentStart);
-        width = std::max(width, static_cast<int>(rect.width()));
-        if (lineHeight == 0) lineHeight = static_cast<int>(rect.height());
-        height += static_cast<int>(rect.height());
-        contentStart = contentStart.next();
-    }
-
-    d->paintedWidth = width;
-    d->paintedHeight = height;
-
-    if (d->paletteManager){
-        d->paintedHeight -= d->paletteManager->totalOffset()*lineHeight;
-    }
-
-    QSizeF size(d->paintedWidth, d->paintedHeight);
-    if (d->contentSize != size) {
-        d->contentSize = size;
-        emit contentSizeChanged();
-        updateTotalLines();
-    }
-}
-
-void TextEdit::updateWholeDocument()
-{
-    Q_D(TextEdit);
-    if (!d->textNodeMap.isEmpty()) {
-        Q_FOREACH (TextEditPrivate::Node* node, d->textNodeMap)
-            node->setDirty();
-    }
-
-    polish();
-    if (isComponentComplete()) {
-        d->updateType = TextEditPrivate::UpdatePaintNode;
-        update();
-    }
-}
-
-void TextEdit::highlightingDone(const QRectF &)
-{
-    Q_D(TextEdit);
-
-    if (d->highlightingInProgress)
-    {
-        d->highlightingInProgress = false;
-        getDocumentLayout()->textDocumentFinishedUpdating(d->document->blockCount());
-    }
-}
-
-void TextEdit::stateChangeHandler(const QTextBlock &block)
-{
-    Q_D(TextEdit);
-    ProjectDocumentBlockData* userData = static_cast<ProjectDocumentBlockData*>(block.userData());
-
-    if (userData && userData->stateChangeFlag())
-    {
-        userData->setStateChangeFlag(false);
-        dynamic_cast<TextDocumentLayout*>(d->document->documentLayout())->stateChangeUpdate(block.blockNumber());
-        getPaletteManager()->setDirtyPos(block.blockNumber());
-    }
-}
-
-void TextEdit::invalidateBlock(const QTextBlock &block)
-{
-    Q_D(TextEdit);
-
-    markDirtyNodesForRange(block.position(), block.position() + block.length(), 0);
-
-    stateChangeHandler(block);
-
-    polish();
-    if (isComponentComplete()) {
-        updateSize();
-        d->updateType = TextEditPrivate::UpdatePaintNode;
-        update();
-    }
-}
-
-void TextEdit::updateCursor()
-{
-    Q_D(TextEdit);
-    polish();
-    if (isComponentComplete()) {
-        d->updateType = TextEditPrivate::UpdatePaintNode;
-        update();
-    }
-}
-
-void TextEdit::q_updateAlignment()
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    if (d->determineHorizontalAlignment()) {
-        d->updateDefaultTextOption();
-        d->xoff = qMax(qreal(0), TextUtil::alignedX(d->document->size().width(), width(), effectiveHAlign()));
-        moveCursorDelegate();
-    }
-}
-
-void TextEdit::updateTotalLines()
-{
-    Q_D(TextEdit);
-
-    int subLines = 0;
-    if (!d->document || !d->control) return;
-
-    for (QTextBlock it = d->document->begin(); it != d->document->end(); it = it.next()) {
-        QTextLayout *layout = it.layout();
-        if (!layout)
-            continue;
-        subLines += layout->lineCount()-1;
-    }
-
-    int newTotalLines = d->document->lineCount() + subLines;
-    if (d->lineCount != newTotalLines) {
-        if (d->lineCount != 0) updateFragmentBounds(newTotalLines - d->lineCount);
-        d->lineCount = newTotalLines;
-        emit lineCountChanged();
-        updateFragmentVisibility();
-    }
-}
-
-void TextEditPrivate::updateDefaultTextOption()
-{
-    Q_Q(TextEdit);
-    if (!document || !control) return;
-
-    QTextOption opt = document->defaultTextOption();
-    int oldAlignment = opt.alignment();
-    Qt::LayoutDirection oldTextDirection = opt.textDirection();
-
-    TextEdit::HAlignment horizontalAlignment = q->effectiveHAlign();
-    if (contentDirection == Qt::RightToLeft) {
-        if (horizontalAlignment == TextEdit::AlignLeft)
-            horizontalAlignment = TextEdit::AlignRight;
-        else if (horizontalAlignment == TextEdit::AlignRight)
-            horizontalAlignment = TextEdit::AlignLeft;
-    }
-    if (!hAlignImplicit)
-        opt.setAlignment(static_cast<Qt::Alignment>(static_cast<int>(horizontalAlignment | vAlign)));
-    else
-        opt.setAlignment(Qt::Alignment(vAlign));
-
-#ifndef QT_NO_IM
-    if (contentDirection == Qt::LayoutDirectionAuto) {
-        opt.setTextDirection(qGuiApp->inputMethod()->inputDirection());
-    } else
-#endif
-    {
-        opt.setTextDirection(contentDirection);
-    }
-
-    QTextOption::WrapMode oldWrapMode = opt.wrapMode();
-    opt.setWrapMode(QTextOption::WrapMode(wrapMode));
-
-    bool oldUseDesignMetrics = opt.useDesignMetrics();
-    opt.setUseDesignMetrics(renderType != TextEdit::NativeRendering);
-
-    if (oldWrapMode != opt.wrapMode() || oldAlignment != opt.alignment()
-        || oldTextDirection != opt.textDirection()
-        || oldUseDesignMetrics != opt.useDesignMetrics()) {
-        document->setDefaultTextOption(opt);
-    }
-}
-
-void TextEdit::focusInEvent(QFocusEvent *event)
-{
-    Q_D(TextEdit);
-    d->handleFocusEvent(event);
-    QQuickItem::focusInEvent(event);
-}
-
-void TextEdit::focusOutEvent(QFocusEvent *event)
-{
-    Q_D(TextEdit);
-    d->handleFocusEvent(event);
-    QQuickItem::focusOutEvent(event);
-}
-
-void TextEditPrivate::handleFocusEvent(QFocusEvent *event)
-{
-    Q_Q(TextEdit);
-    if (!document || !control) return;
-    bool focus = event->type() == QEvent::FocusIn;
-    if (!q->isReadOnly())
-        q->setCursorVisible(focus);
-    control->processEvent(event, QPointF(-xoff, -yoff));
-    if (focus) {
-        q->q_updateAlignment();
-#ifndef QT_NO_IM
-        if (focusOnPress && !q->isReadOnly())
-            qGuiApp->inputMethod()->show();
-        q->connect(QGuiApplication::inputMethod(), SIGNAL(inputDirectionChanged(Qt::LayoutDirection)),
-                q, SLOT(q_updateAlignment()));
-#endif
-    } else {
-#ifndef QT_NO_IM
-        q->disconnect(QGuiApplication::inputMethod(), SIGNAL(inputDirectionChanged(Qt::LayoutDirection)),
-                   q, SLOT(q_updateAlignment()));
-#endif
-        emit q->editingFinished();
-    }
-}
-
-void TextEditPrivate::addCurrentTextNodeToRoot(TextNodeEngine *engine, QSGTransformNode *root, TextNode *node, TextNodeIterator &it, int startPos)
-{
-    engine->addToSceneGraph(node, QQuickText::Normal, QColor());
-    it = textNodeMap.insert(it, new TextEditPrivate::Node(startPos, node));
-    ++it;
-    root->appendChildNode(node);
-}
-
-TextNode *TextEditPrivate::createTextNode()
-{
-    Q_Q(TextEdit);
-    TextNode* node = new TextNode(q);
-    node->setUseNativeRenderer(renderType == TextEdit::NativeRendering);
-    return node;
-}
-
-void TextEdit::q_canPasteChanged()
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-    bool old = d->canPaste;
-    d->canPaste = d->control->canPaste();
-    bool changed = old!=d->canPaste || !d->canPasteValid;
-    d->canPasteValid = true;
-    if (changed)
-        emit canPasteChanged();
-}
-
-/*!
-    \qmlmethod string QtQuick::TextEdit::getText(int start, int end)
-
-    Returns the section of text that is between the \a start and \a end positions.
-
-    The returned text does not include any rich text formatting.
-*/
-
-QString TextEdit::getText(int start, int end) const
-{
-    Q_D(const TextEdit);
-    if (!d->document || !d->control) return QString();
-
-    start = qBound(0, start, d->document->characterCount() - 1);
-    end = qBound(0, end, d->document->characterCount() - 1);
-    QTextCursor cursor(d->document);
-    cursor.setPosition(start, QTextCursor::MoveAnchor);
-    cursor.setPosition(end, QTextCursor::KeepAnchor);
-#ifndef QT_NO_TEXTHTMLPARSER
-    return d->richText
-            ? cursor.selectedText()
-            : cursor.selection().toPlainText();
-#else
-    return cursor.selection().toPlainText();
-#endif
-}
-
-/*!
-    \qmlmethod string QtQuick::TextEdit::getFormattedText(int start, int end)
-
-    Returns the section of text that is between the \a start and \a end positions.
-
-    The returned text will be formatted according the \l textFormat property.
-*/
-
-QString TextEdit::getFormattedText(int start, int end) const
-{
-    Q_D(const TextEdit);
-    if (!d->document || !d->control) return QString();
-
-
-    start = qBound(0, start, d->document->characterCount() - 1);
-    end = qBound(0, end, d->document->characterCount() - 1);
-
-    QTextCursor cursor(d->document);
-    cursor.setPosition(start, QTextCursor::MoveAnchor);
-    cursor.setPosition(end, QTextCursor::KeepAnchor);
-
-    if (d->richText) {
-#ifndef QT_NO_TEXTHTMLPARSER
-        return cursor.selection().toHtml();
-#else
-        return cursor.selection().toPlainText();
-#endif
-    } else {
-        return cursor.selection().toPlainText();
-    }
-}
-
-/*!
-    \qmlmethod QtQuick::TextEdit::insert(int position, string text)
-
-    Inserts \a text into the TextEdit at position.
-*/
-void TextEdit::insert(int position, const QString &text)
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    if (position < 0 || position >= d->document->characterCount())
-        return;
-    QTextCursor cursor(d->document);
-    cursor.setPosition(position);
-    d->richText = d->richText || (d->format == AutoText && Qt::mightBeRichText(text));
-    if (d->richText) {
-#ifndef QT_NO_TEXTHTMLPARSER
-        cursor.insertHtml(text);
-#else
-        cursor.insertText(text);
-#endif
-    } else {
-        cursor.insertText(text);
-    }
-    d->control->updateCursorRectangle(false);
-}
-
-/*!
-    \qmlmethod string QtQuick::TextEdit::remove(int start, int end)
-
-    Removes the section of text that is between the \a start and \a end positions from the TextEdit.
-*/
-
-void TextEdit::remove(int start, int end)
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    start = qBound(0, start, d->document->characterCount() - 1);
-    end = qBound(0, end, d->document->characterCount() - 1);
-    QTextCursor cursor(d->document);
-    cursor.setPosition(start, QTextCursor::MoveAnchor);
-    cursor.setPosition(end, QTextCursor::KeepAnchor);
-    cursor.removeSelectedText();
-    d->control->updateCursorRectangle(false);
-}
-
-bool TextEditPrivate::isLinkHoveredConnected()
-{
-    Q_Q(TextEdit);
-    LV_IS_SIGNAL_CONNECTED(q, TextEdit, linkHovered, (const QString &));
-}
-
-/*!
-    \qmlsignal QtQuick::TextEdit::linkHovered(string link)
-    \since 5.2
-
-    This signal is emitted when the user hovers a link embedded in the text.
-    The link must be in rich text or HTML format and the
-    \a link string provides access to the particular link.
-
-    The corresponding handler is \c onLinkHovered.
-
-    \sa hoveredLink, linkAt()
-*/
-
-/*!
-    \qmlsignal QtQuick::TextEdit::editingFinished()
-    \since 5.6
-
-    This signal is emitted when the text edit loses focus.
-
-    The corresponding handler is \c onEditingFinished.
-*/
-
-/*!
-    \qmlproperty string QtQuick::TextEdit::hoveredLink
-    \since 5.2
-
-    This property contains the link string when the user hovers a link
-    embedded in the text. The link must be in rich text or HTML format
-    and the link string provides access to the particular link.
-
-    \sa linkHovered, linkAt()
-*/
-
-QString TextEdit::hoveredLink() const
-{
-    Q_D(const TextEdit);
-    if (!d->document || !d->control) return QString();
-
-    if (const_cast<TextEditPrivate *>(d)->isLinkHoveredConnected()) {
-        return d->control->hoveredLink();
-    } else {
-#ifndef QT_NO_CURSOR
-        if (QQuickWindow *wnd = window()) {
-            QPointF pos = QCursor::pos(wnd->screen()) - wnd->position() - mapToScene(QPointF(0, 0));
-            return d->control->anchorAt(pos);
-        }
-#endif // QT_NO_CURSOR
-    }
-    return QString();
-}
-
-void TextEdit::hoverEnterEvent(QHoverEvent *event)
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    if (d->isLinkHoveredConnected())
-        d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
-}
-
-void TextEdit::hoverMoveEvent(QHoverEvent *event)
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    if (d->isLinkHoveredConnected())
-        d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
-}
-
-void TextEdit::hoverLeaveEvent(QHoverEvent *event)
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    if (d->isLinkHoveredConnected())
-        d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
-}
-
-/*!
-    \qmlmethod void QtQuick::TextEdit::append(string text)
-    \since 5.2
-
-    Appends a new paragraph with \a text to the end of the TextEdit.
-
-    In order to append without inserting a new paragraph,
-    call \c myTextEdit.insert(myTextEdit.length, text) instead.
-*/
-void TextEdit::append(const QString &text)
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-    QTextCursor cursor(d->document);
-    cursor.beginEditBlock();
-    cursor.movePosition(QTextCursor::End);
-
-    if (!d->document->isEmpty())
-        cursor.insertBlock();
-
-#ifndef QT_NO_TEXTHTMLPARSER
-    if (d->format == RichText || (d->format == AutoText && Qt::mightBeRichText(text))) {
-        cursor.insertHtml(text);
-    } else {
-        cursor.insertText(text);
-    }
-#else
-    cursor.insertText(text);
-#endif // QT_NO_TEXTHTMLPARSER
-
-    cursor.endEditBlock();
-    d->control->updateCursorRectangle(false);
-}
-
-/*!
-    \qmlmethod QtQuick::TextEdit::linkAt(real x, real y)
-    \since 5.3
-
-    Returns the link string at point \a x, \a y in content coordinates,
-    or an empty string if no link exists at that point.
-
-    \sa hoveredLink
-*/
-QString TextEdit::linkAt(qreal x, qreal y) const
-{
-    Q_D(const TextEdit);
-    if (!d->document || !d->control) return QString();
-
-    return d->control->anchorAt(QPointF(x + topPadding(), y + leftPadding()));
-}
-
-/*!
-    \since 5.6
-    \qmlproperty real QtQuick::TextEdit::padding
-    \qmlproperty real QtQuick::TextEdit::topPadding
-    \qmlproperty real QtQuick::TextEdit::leftPadding
-    \qmlproperty real QtQuick::TextEdit::bottomPadding
-    \qmlproperty real QtQuick::TextEdit::rightPadding
-
-    These properties hold the padding around the content. This space is reserved
-    in addition to the contentWidth and contentHeight.
-*/
-qreal TextEdit::padding() const
-{
-    Q_D(const TextEdit);
-    return d->padding();
-}
-
-void TextEdit::setPadding(qreal padding)
-{
-    Q_D(TextEdit);
-    if (qFuzzyCompare(d->padding(), padding))
-        return;
-
-    d->extra.value().padding = padding;
-    updateSize();
-    if (isComponentComplete()) {
-        d->updateType = TextEditPrivate::UpdatePaintNode;
-        update();
-    }
-    emit paddingChanged();
-    if (!d->extra.isAllocated() || !d->extra->explicitTopPadding)
-        emit topPaddingChanged();
-    if (!d->extra.isAllocated() || !d->extra->explicitLeftPadding)
-        emit leftPaddingChanged();
-    if (!d->extra.isAllocated() || !d->extra->explicitRightPadding)
-        emit rightPaddingChanged();
-    if (!d->extra.isAllocated() || !d->extra->explicitBottomPadding)
-        emit bottomPaddingChanged();
-}
-
-void TextEdit::resetPadding()
-{
-    setPadding(0);
-}
-
-qreal TextEdit::topPadding() const
-{
-    Q_D(const TextEdit);
-    if (d->extra.isAllocated() && d->extra->explicitTopPadding)
-        return d->extra->topPadding;
-    return d->padding();
-}
-
-void TextEdit::setTopPadding(qreal padding)
-{
-    Q_D(TextEdit);
-    d->setTopPadding(padding);
-}
-
-void TextEdit::resetTopPadding()
-{
-    Q_D(TextEdit);
-    d->setTopPadding(0, true);
-}
-
-qreal TextEdit::leftPadding() const
-{
-    Q_D(const TextEdit);
-    if (d->extra.isAllocated() && d->extra->explicitLeftPadding)
-        return d->extra->leftPadding;
-    return d->padding();
-}
-
-void TextEdit::setLeftPadding(qreal padding)
-{
-    Q_D(TextEdit);
-    d->setLeftPadding(padding);
-}
-
-void TextEdit::resetLeftPadding()
-{
-    Q_D(TextEdit);
-    d->setLeftPadding(0, true);
-}
-
-qreal TextEdit::rightPadding() const
-{
-    Q_D(const TextEdit);
-    if (d->extra.isAllocated() && d->extra->explicitRightPadding)
-        return d->extra->rightPadding;
-    return d->padding();
-}
-
-void TextEdit::setRightPadding(qreal padding)
-{
-    Q_D(TextEdit);
-    d->setRightPadding(padding);
-}
-
-void TextEdit::resetRightPadding()
-{
-    Q_D(TextEdit);
-    d->setRightPadding(0, true);
-}
-
-qreal TextEdit::bottomPadding() const
-{
-    Q_D(const TextEdit);
-    if (d->extra.isAllocated() && d->extra->explicitBottomPadding)
-        return d->extra->bottomPadding;
-    return d->padding();
-}
-
-void TextEdit::setBottomPadding(qreal padding)
-{
-    Q_D(TextEdit);
-    d->setBottomPadding(padding);
-}
-
-void TextEdit::resetBottomPadding()
-{
-    Q_D(TextEdit);
-    d->setBottomPadding(0, true);
-}
-
-/*!
-    \qmlmethod QtQuick::TextEdit::clear()
-    \since 5.7
-
-    Clears the contents of the text edit
-    and resets partial text input from an input method.
-
-    Use this method instead of setting the \l text property to an empty string.
-
-    \sa QInputMethod::reset()
-*/
-void TextEdit::clear()
-{
-    Q_D(TextEdit);
-    if (!d->document || !d->control) return;
-
-    d->resetInputMethod();
-    d->control->clear();
-}
-
-
-void TextEditPrivate::implicitWidthChanged()
-{
-    Q_Q(TextEdit);
-    QQuickImplicitSizeItemPrivate::implicitWidthChanged();
-#if (QT_VERSION > QT_VERSION_CHECK(5,7,1))
-    emit q->implicitWidthChanged(); // change for 5.11
-#else
-    emit q->implicitWidthChanged2();
-#endif
-}
-
-void TextEditPrivate::implicitHeightChanged()
-{
-    Q_Q(TextEdit);
-    QQuickImplicitSizeItemPrivate::implicitHeightChanged();
-#if (QT_VERSION > QT_VERSION_CHECK(5,7,1))
-    emit q->implicitHeightChanged(); // change for 5.11
-#else
-    emit q->implicitHeightChanged2();
-#endif
-}
-
-DocumentHandler* TextEdit::documentHandler()
-{
-    Q_D(TextEdit);
-    return d->documentHandler;
-}
-
-void TextEdit::setDocumentHandler(DocumentHandler *dh)
-{
-    Q_D(TextEdit);
-    d->documentHandler = dh;
-    dh->setTextEdit(this);
-}
-
-void TextEdit::linePaletteAdded(int lineStart, int lineEnd, int height, QQuickItem *palette)
-{
-    Q_D(TextEdit);
-    auto startBlock = d->document->findBlockByNumber(lineStart-1);
-    auto endBlock = d->document->findBlockByNumber(lineEnd-1);
-    int startPos = startBlock.position();
-    int endPos = endBlock.position() + endBlock.length();
-    d->paletteManager->paletteAdded(lineStart-1, lineEnd - lineStart + 1, height, palette, startPos, endPos);
-    d->invalidUntilTheEnd = true;
-    for (int i = lineStart - 1; i < d->document->blockCount(); ++i)
-        invalidateBlock(d->document->findBlockByNumber(i));
-
-    emit paletteChange(lineStart - 1);
-}
-
-void TextEdit::linePaletteRemoved(QQuickItem *palette)
-{
-    Q_D(TextEdit);
-    int result = d->paletteManager->removePalette(palette);
-    if (result == -1) return;
-
-    d->invalidUntilTheEnd = true;
-
-    for (int i = result; i < d->document->blockCount(); ++i)
-    {
-        invalidateBlock(d->document->findBlockByNumber(i));
-    }
-    emit paletteChange(result);
-}
-
-void TextEdit::linePaletteHeightChanged(QQuickItem *palette, int newHeight)
-{
-    Q_D(TextEdit);
-    int result = d->paletteManager->resizePalette(palette, newHeight);
-    if (result == -1) return;
-    d->invalidUntilTheEnd = true;
-    for (int i = result; i < d->document->blockCount(); ++i)
-    {
-        invalidateBlock(d->document->findBlockByNumber(i));
-    }
-    emit paletteChange(result);
-}
-
-
-
-void TextEdit::clearSelectionOnFocus(bool value){
-    Q_D(TextEdit);
-    d->control->clearSelectionOnFocus(value);
-}
-
-void TextEdit::setTextDocument(QTextDocument *td)
-{
-    Q_D(TextEdit);
-    if (td)
-    {
-        d->setTextDocument(td);
-    }
-    else d->unsetTextDocument();
-}
-
-TextDocumentLayout *TextEdit::getDocumentLayout()
-{
-    Q_D(TextEdit);
-    return dynamic_cast<TextDocumentLayout*>(d->document->documentLayout());
-}
-
-void TextEdit::manageExpandCollapse(int pos, bool collapsed)
-{
-    Q_D(TextEdit);
-    QTextBlock matchingBlock = d->document->findBlockByNumber(pos);
-    ProjectDocumentBlockData* userData = static_cast<ProjectDocumentBlockData*>(matchingBlock.userData());
-
-    if (collapsed)
-    {
-        userData->collapse();
-        userData->setStateChangeFlag(true);
-        int num; QString repl;
-        userData->onCollapse()(matchingBlock, num, repl);
-        userData->setNumOfCollapsedLines(num);
-        userData->setReplacementString(repl);
-        getDocumentLayout()->collapseLines(pos, userData->numOfCollapsedLines());
-        stateChangeHandler(matchingBlock);
-    } else {
-        userData->expand();
-        userData->setStateChangeFlag(true);
-        getDocumentLayout()->expandLines(pos, userData->numOfCollapsedLines());
-        stateChangeHandler(matchingBlock);
-    }
-}
-
-void TextEdit::updateLineSurface(int oldLineNum, int newLineNum, int dirtyPos)
-{
-    Q_D(TextEdit);
-    if (d->lineSurface) d->lineSurface->triggerUpdate(oldLineNum, newLineNum, dirtyPos);
-}
-
-void TextEdit::handleCursorDuringCollapse(int pos, int num)
-{
-    Q_D(TextEdit);
-
-    QTextCursor cursor = d->control->textCursor();
-    int cursorBlock = cursor.block().blockNumber();
-
-    if (cursorBlock > pos && cursorBlock <= pos + num)
-    {
-        cursor.beginEditBlock();
-        for (int i = 0; i < cursorBlock - pos; i++)
-        {
-            d->control->moveCursor(QTextCursor::MoveOperation::Up);
-        }
-        cursor.endEditBlock();
-    }
-}
-
-void TextEdit::checkPalettesWhenCollapsed(int pos, int num)
-{
-    auto result = getPaletteManager()->deletedOnCollapse(pos, num);
-
-    if (!result.empty())
-    {
-        for (auto it = result.begin(); it != result.end(); ++it)
-        {
-            QMetaObject::invokeMethod(*it, "close", Qt::DirectConnection);
-        }
-    }
-}
-
-void TextEdit::updateFragmentVisibility()
-{
-    Q_D(TextEdit);
-    if (!d->document) return;
-    d->paletteManager->removePalette(d->fragmentStartPalette);
-    d->paletteManager->removePalette(d->fragmentEndPalette);
-
-    // handle fragment start palette
-    int lastPosition;
-    if (d->fragmentStart <= 0)
-    {
-        lastPosition = 0;
-    }
-    else
-    {
-        QTextBlock endBlock = d->document->findBlockByNumber(d->fragmentStart-1);
-        lastPosition = endBlock.position() + endBlock.length();
-    }
-    d->paletteManager->paletteAdded(0, std::max(d->fragmentStart, 0), 0, d->fragmentStartPalette, 0, lastPosition);
-
-    // handle fragment start end
-    int firstPosition;
-    int span;
-    if (d->fragmentEnd >= d->document->blockCount()-1)
-    {
-        firstPosition = d->document->characterCount();
-        span = 0;
-    }
-    else
-    {
-        QTextBlock startBlock = d->document->findBlockByNumber(d->fragmentEnd + 1);
-        firstPosition = startBlock.position();
-        span = d->document->blockCount()-d->fragmentEnd - 1;
-    }
-    d->paletteManager->paletteAdded(std::min(d->fragmentEnd + 1, d->document->blockCount()-1),span,0,d->fragmentEndPalette, firstPosition, d->document->characterCount());
-
-    getPaletteManager()->setDirtyPos(0);
-    getDocumentLayout()->setDirtyPos(0);
-    getDocumentLayout()->textDocumentFinishedUpdating(d->document->blockCount());
-
-    markDirtyNodesForRange(0, d->document->characterCount(), 0);
-}
-
-void TextEdit::updateFragmentBounds(int delta)
-{
-    Q_D(TextEdit);
-    if (d->dirtyPosition < d->fragmentStart) d->fragmentStart += delta;
-    if (d->dirtyPosition <= d->fragmentEnd && d->fragmentEnd != INT_MAX) d->fragmentEnd += delta;
-}
-
-}
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtQuick module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#include "textedit_p.h"
+#include "textedit_p_p.h"
+#include "textcontrol_p.h"
+#include "qquickwindow.h"
+#include "textnodeengine_p.h"
+#include "textutil_p.h"
+
+#include <QtCore/qmath.h>
+#include <QtGui/qguiapplication.h>
+#include <QtGui/qevent.h>
+#include <QtGui/qpainter.h>
+#include <QtGui/qtextobject.h>
+#include <QtGui/qtexttable.h>
+#include <QtQml/qqmlinfo.h>
+#include <QtQuick/qsgsimplerectnode.h>
+#include <QTimer>
+#include "textdocumentlayout.h"
+#include "linesurface.h"
+
+#include <QtGlobal>
+
+#if (QT_VERSION > QT_VERSION_CHECK(5,7,1))
+#include <QSGRectangleNode> // change for 5.11
+#endif
+
+#include "private/qquicktextnode_p.h"
+#include "private/qquickevents_p_p.h"
+#include "private/qqmlproperty_p.h"
+#include "private/qtextengine_p.h"
+#include "private/qsgadaptationlayer_p.h"
+#include <algorithm>
+
+#ifdef LV_EDITOR_DEBUG
+#include "live/viewcontext.h"
+#include "live/viewengine.h"
+#include "live/lockedfileiosession.h"
+#include "qqmlapplicationengine.h"
+#endif
+
+#define LV_ACCURACY 1e-7
+#define lv_qmlobject_connect(Sender, SenderType, Signal, Receiver, ReceiverType, Method) \
+{ \
+    SenderType *sender = (Sender); \
+    ReceiverType *receiver = (Receiver); \
+    const char *signal = (Signal); \
+    const char *method = (Method); \
+    static int signalIdx = -1; \
+    static int methodIdx = -1; \
+    if (signalIdx < 0) { \
+        Q_ASSERT((static_cast<int>(*signal) - '0') == QSIGNAL_CODE); \
+        signalIdx = SenderType::staticMetaObject.indexOfSignal(signal+1); \
+    } \
+    if (methodIdx < 0) { \
+        int code = (static_cast<int>(*method) - '0'); \
+        Q_ASSERT(code == QSLOT_CODE || code == QSIGNAL_CODE); \
+        if (code == QSLOT_CODE) \
+            methodIdx = ReceiverType::staticMetaObject.indexOfSlot(method+1); \
+        else \
+            methodIdx = ReceiverType::staticMetaObject.indexOfSignal(method+1); \
+    } \
+    Q_ASSERT(signalIdx != -1 && methodIdx != -1); \
+    QMetaObject::connect(sender, signalIdx, receiver, methodIdx, Qt::DirectConnection); \
+}
+#define LV_IS_SIGNAL_CONNECTED(Sender, SenderType, Name, Arguments) \
+do { \
+    QObject *sender = (Sender); \
+    void (SenderType::*signal)Arguments = &SenderType::Name; \
+    static QMetaMethod method = QMetaMethod::fromSignal(signal); \
+    static uint signalIdx = static_cast<uint>(QMetaObjectPrivate::signalIndex(method)); \
+    return QObjectPrivate::get(sender)->isSignalConnected(signalIdx); \
+} while (0)
+
+namespace lv {
+
+/*!
+    \qmltype TextEdit
+    \instantiates QQuickTextEdit
+    \inqmlmodule QtQuick
+    \ingroup qtquick-visual
+    \ingroup qtquick-input
+    \inherits Item
+    \brief Displays multiple lines of editable formatted text
+
+    The TextEdit item displays a block of editable, formatted text.
+
+    It can display both plain and rich text. For example:
+
+    \qml
+TextEdit {
+    width: 240
+    text: "<b>Hello</b> <i>World!</i>"
+    font.family: "Helvetica"
+    font.pointSize: 20
+    color: "blue"
+    focus: true
+}
+    \endqml
+
+    \image declarative-textedit.gif
+
+    Setting \l {Item::focus}{focus} to \c true enables the TextEdit item to receive keyboard focus.
+
+    Note that the TextEdit does not implement scrolling, following the cursor, or other behaviors specific
+    to a look-and-feel. For example, to add flickable scrolling that follows the cursor:
+
+    \snippet qml/texteditor.qml 0
+
+    A particular look-and-feel might use smooth scrolling (eg. using SmoothedAnimation), might have a visible
+    scrollbar, or a scrollbar that fades in to show location, etc.
+
+    Clipboard support is provided by the cut(), copy(), and paste() functions, and the selection can
+    be handled in a traditional "mouse" mechanism by setting selectByMouse, or handled completely
+    from QML by manipulating selectionStart and selectionEnd, or using selectAll() or selectWord().
+
+    You can translate between cursor positions (characters from the start of the document) and pixel
+    points using positionAt() and positionToRectangle().
+
+    \sa Text, TextInput
+*/
+
+/*!
+    \qmlsignal QtQuick::TextEdit::linkActivated(string link)
+
+    This signal is emitted when the user clicks on a link embedded in the text.
+    The link must be in rich text or HTML format and the
+    \a link string provides access to the particular link.
+
+    The corresponding handler is \c onLinkActivated.
+*/
+
+// This is a pretty arbitrary figure. The idea is that we don't want to break down the document
+// into text nodes corresponding to a text block each so that the glyph node grouping doesn't become pointless.
+static const int nodeBreakingSize = 300;
+
+namespace {
+    class ProtectedLayoutAccessor: public QAbstractTextDocumentLayout
+    {
+    public:
+        inline QTextCharFormat formatAccessor(int pos)
+        {
+            return format(pos);
+        }
+    };
+
+    class RootNode : public QSGTransformNode
+    {
+    public:
+        RootNode() : cursorNode(nullptr), frameDecorationsNode(nullptr)
+        { }
+
+        void resetFrameDecorations(TextNode* newNode)
+        {
+            if (frameDecorationsNode) {
+                removeChildNode(frameDecorationsNode);
+                delete frameDecorationsNode;
+            }
+            frameDecorationsNode = newNode;
+            newNode->setFlag(QSGNode::OwnedByParent);
+        }
+
+        void resetCursorNode(QSGRectangleNode* newNode)
+        {
+            if (cursorNode)
+                removeChildNode(cursorNode);
+            delete cursorNode;
+            cursorNode = newNode;
+            if (cursorNode) {
+                appendChildNode(cursorNode);
+                cursorNode->setFlag(QSGNode::OwnedByParent);
+            }
+        }
+
+        QSGRectangleNode *cursorNode;
+        TextNode* frameDecorationsNode;
+
+    };
+}
+
+TextEdit::TextEdit(QQuickImplicitSizeItem *parent, bool test)
+: QQuickImplicitSizeItem(*(new TextEditPrivate), parent)
+{
+    Q_D(TextEdit);
+    if (!test) d->init();
+}
+
+TextEdit::TextEdit(TextEditPrivate &dd, QQuickImplicitSizeItem *parent, bool test)
+: QQuickImplicitSizeItem(dd, parent)
+{
+    Q_D(TextEdit);
+    if (!test) d->init();
+}
+
+PaletteManager *TextEdit::getPaletteManager()
+{
+    Q_D(TextEdit);
+    return d->paletteManager;
+}
+
+LineControl *TextEdit::lineControl()
+{
+    Q_D(TextEdit);
+    return d->lineControl;
+}
+
+void TextEdit::setLineSurface(LineSurface *ls)
+{
+    Q_D(TextEdit);
+    d->lineSurface = ls;
+    d->lineSurface->setDocument(d->lineControl->lineDocument());
+
+}
+
+QString TextEdit::text() const
+{
+    Q_D(const TextEdit);
+    if (!d->document || !d->control) return QString();
+    if (!d->textCached && isComponentComplete()) {
+        TextEditPrivate *d = const_cast<TextEditPrivate *>(d_func());
+#ifndef QT_NO_TEXTHTMLPARSER
+        if (d->richText)
+            d->text = d->control->toHtml();
+        else
+#endif
+            d->text = d->control->toPlainText();
+        d->textCached = true;
+    }
+    return d->text;
+}
+
+/*!
+    \qmlproperty string QtQuick::TextEdit::font.family
+
+    Sets the family name of the font.
+
+    The family name is case insensitive and may optionally include a foundry name, e.g. "Helvetica [Cronyx]".
+    If the family is available from more than one foundry and the foundry isn't specified, an arbitrary foundry is chosen.
+    If the family isn't available a family will be set using the font matching algorithm.
+*/
+
+/*!
+    \qmlproperty string QtQuick::TextEdit::font.styleName
+    \since 5.6
+
+    Sets the style name of the font.
+
+    The style name is case insensitive. If set, the font will be matched against style name instead
+    of the font properties \l font.weight, \l font.bold and \l font.italic.
+*/
+
+
+/*!
+    \qmlproperty bool QtQuick::TextEdit::font.bold
+
+    Sets whether the font weight is bold.
+*/
+
+/*!
+    \qmlproperty enumeration QtQuick::TextEdit::font.weight
+
+    Sets the font's weight.
+
+    The weight can be one of:
+    \list
+    \li Font.Thin
+    \li Font.Light
+    \li Font.ExtraLight
+    \li Font.Normal - the default
+    \li Font.Medium
+    \li Font.DemiBold
+    \li Font.Bold
+    \li Font.ExtraBold
+    \li Font.Black
+    \endlist
+
+    \qml
+    TextEdit { text: "Hello"; font.weight: Font.DemiBold }
+    \endqml
+*/
+
+/*!
+    \qmlproperty bool QtQuick::TextEdit::font.italic
+
+    Sets whether the font has an italic style.
+*/
+
+/*!
+    \qmlproperty bool QtQuick::TextEdit::font.underline
+
+    Sets whether the text is underlined.
+*/
+
+/*!
+    \qmlproperty bool QtQuick::TextEdit::font.strikeout
+
+    Sets whether the font has a strikeout style.
+*/
+
+/*!
+    \qmlproperty real QtQuick::TextEdit::font.pointSize
+
+    Sets the font size in points. The point size must be greater than zero.
+*/
+
+/*!
+    \qmlproperty int QtQuick::TextEdit::font.pixelSize
+
+    Sets the font size in pixels.
+
+    Using this function makes the font device dependent.  Use
+    \l{TextEdit::font.pointSize} to set the size of the font in a
+    device independent manner.
+*/
+
+/*!
+    \qmlproperty real QtQuick::TextEdit::font.letterSpacing
+
+    Sets the letter spacing for the font.
+
+    Letter spacing changes the default spacing between individual letters in the font.
+    A positive value increases the letter spacing by the corresponding pixels; a negative value decreases the spacing.
+*/
+
+/*!
+    \qmlproperty real QtQuick::TextEdit::font.wordSpacing
+
+    Sets the word spacing for the font.
+
+    Word spacing changes the default spacing between individual words.
+    A positive value increases the word spacing by a corresponding amount of pixels,
+    while a negative value decreases the inter-word spacing accordingly.
+*/
+
+/*!
+    \qmlproperty enumeration QtQuick::TextEdit::font.capitalization
+
+    Sets the capitalization for the text.
+
+    \list
+    \li Font.MixedCase - This is the normal text rendering option where no capitalization change is applied.
+    \li Font.AllUppercase - This alters the text to be rendered in all uppercase type.
+    \li Font.AllLowercase - This alters the text to be rendered in all lowercase type.
+    \li Font.SmallCaps - This alters the text to be rendered in small-caps type.
+    \li Font.Capitalize - This alters the text to be rendered with the first character of each word as an uppercase character.
+    \endlist
+
+    \qml
+    TextEdit { text: "Hello"; font.capitalization: Font.AllLowercase }
+    \endqml
+*/
+
+/*!
+    \qmlproperty string QtQuick::TextEdit::text
+
+    The text to display.  If the text format is AutoText the text edit will
+    automatically determine whether the text should be treated as
+    rich text.  This determination is made using Qt::mightBeRichText().
+
+    The text-property is mostly suitable for setting the initial content and
+    handling modifications to relatively small text content. The append(),
+    insert() and remove() methods provide more fine-grained control and
+    remarkably better performance for modifying especially large rich text
+    content.
+
+    \sa clear()
+*/
+void TextEdit::setText(const QString &text)
+{
+
+    Q_D(TextEdit);
+    if (TextEdit::text() == text)
+        return;
+
+    d->richText = d->format == RichText || (d->format == AutoText && Qt::mightBeRichText(text));
+    if (!isComponentComplete()) {
+        d->text = text;
+    } else if (d->control) {
+        if (d->richText) {
+        #ifndef QT_NO_TEXTHTMLPARSER
+                d->control->setHtml(text);
+        #else
+                d->control->setPlainText(text);
+        #endif
+        } else {
+            d->control->setPlainText(text);
+        }
+    }
+}
+
+/*!
+    \qmlproperty string QtQuick::TextEdit::preeditText
+    \readonly
+    \since 5.7
+
+    This property contains partial text input from an input method.
+*/
+QString TextEdit::preeditText() const
+{
+    Q_D(const TextEdit);
+    if (!d->document || !d->control) return QString();
+    return d->control->preeditText();
+}
+
+/*!
+    \qmlproperty enumeration QtQuick::TextEdit::textFormat
+
+    The way the text property should be displayed.
+
+    \list
+    \li TextEdit.AutoText
+    \li TextEdit.PlainText
+    \li TextEdit.RichText
+    \endlist
+
+    The default is TextEdit.PlainText.  If the text format is TextEdit.AutoText the text edit
+    will automatically determine whether the text should be treated as
+    rich text.  This determination is made using Qt::mightBeRichText().
+
+    \table
+    \row
+    \li
+    \qml
+Column {
+    TextEdit {
+        font.pointSize: 24
+        text: "<b>Hello</b> <i>World!</i>"
+    }
+    TextEdit {
+        font.pointSize: 24
+        textFormat: TextEdit.RichText
+        text: "<b>Hello</b> <i>World!</i>"
+    }
+    TextEdit {
+        font.pointSize: 24
+        textFormat: TextEdit.PlainText
+        text: "<b>Hello</b> <i>World!</i>"
+    }
+}
+    \endqml
+    \li \image declarative-textformat.png
+    \endtable
+*/
+TextEdit::TextFormat TextEdit::textFormat() const
+{
+    Q_D(const TextEdit);
+    return d->format;
+}
+
+void TextEdit::setTextFormat(TextFormat format)
+{
+    Q_D(TextEdit);
+
+    if (format == d->format)
+        return;
+
+    bool wasRich = d->richText;
+    d->richText = format == RichText || (format == AutoText && (wasRich || Qt::mightBeRichText(text())));
+
+#ifndef QT_NO_TEXTHTMLPARSER
+    if (isComponentComplete()) {
+        if (wasRich && !d->richText) {
+            if (d->control) d->control->setPlainText(!d->textCached ? d->control->toHtml() : d->text);
+            updateSize();
+        } else if (!wasRich && d->richText) {
+            if (d->control) d->control->setHtml(!d->textCached ? d->control->toPlainText() : d->text);
+            updateSize();
+        }
+    }
+#endif
+
+    d->format = format;
+    d->control->setAcceptRichText(d->format != PlainText);
+    emit textFormatChanged(d->format);
+}
+
+/*!
+    \qmlproperty enumeration QtQuick::TextEdit::renderType
+
+    Override the default rendering type for this component.
+
+    Supported render types are:
+    \list
+    \li Text.QtRendering - the default
+    \li Text.NativeRendering
+    \endlist
+
+    Select Text.NativeRendering if you prefer text to look native on the target platform and do
+    not require advanced features such as transformation of the text. Using such features in
+    combination with the NativeRendering render type will lend poor and sometimes pixelated
+    results.
+*/
+TextEdit::RenderType TextEdit::renderType() const
+{
+    Q_D(const TextEdit);
+    return d->renderType;
+}
+
+void TextEdit::setRenderType(TextEdit::RenderType renderType)
+{
+    Q_D(TextEdit);
+    if (d->renderType == renderType)
+        return;
+
+    d->renderType = renderType;
+    emit renderTypeChanged();
+    d->updateDefaultTextOption();
+
+    if (isComponentComplete())
+        updateSize();
+}
+
+QFont TextEdit::font() const
+{
+    Q_D(const TextEdit);
+    return d->sourceFont;
+}
+
+void TextEdit::setFont(const QFont &font)
+{
+    Q_D(TextEdit);
+    if (d->sourceFont == font)
+        return;
+
+    d->sourceFont = font;
+    QFont oldFont = d->font;
+    d->font = font;
+    if (static_cast<int>(d->font.pointSizeF()) != -1) {
+        // 0.5pt resolution
+        qreal size = qRound(d->font.pointSizeF()*2.0);
+        d->font.setPointSizeF(size/2.0);
+    }
+
+    if (oldFont != d->font && d->font.pixelSize() > 0) {
+        if (d->document) d->document->setDefaultFont(d->font);
+        if (d->cursorItem) {
+            d->cursorItem->setHeight(QFontMetrics(d->font).height());
+            moveCursorDelegate();
+        }
+        updateSize();
+        updateWholeDocument();
+#ifndef QT_NO_IM
+        updateInputMethod(Qt::ImCursorRectangle | Qt::ImAnchorRectangle | Qt::ImFont);
+#endif
+    }
+
+    d->lineControl->setLineDocumentFont(font);
+    emit fontChanged(d->sourceFont);
+}
+
+/*!
+    \qmlproperty color QtQuick::TextEdit::color
+
+    The text color.
+
+    \qml
+    // green text using hexadecimal notation
+    TextEdit { color: "#00FF00" }
+    \endqml
+
+    \qml
+    // steelblue text using SVG color name
+    TextEdit { color: "steelblue" }
+    \endqml
+*/
+QColor TextEdit::color() const
+{
+    Q_D(const TextEdit);
+    return d->color;
+}
+
+void TextEdit::setColor(const QColor &color)
+{
+    Q_D(TextEdit);
+    if (d->color == color)
+        return;
+
+    d->color = color;
+
+    updateWholeDocument();
+    emit colorChanged(d->color);
+}
+
+/*!
+    \qmlproperty color QtQuick::TextEdit::selectionColor
+
+    The text highlight color, used behind selections.
+*/
+QColor TextEdit::selectionColor() const
+{
+    Q_D(const TextEdit);
+    return d->selectionColor;
+}
+
+void TextEdit::setSelectionColor(const QColor &color)
+{
+    Q_D(TextEdit);
+    if (d->selectionColor == color)
+        return;
+
+    d->selectionColor = color;
+    updateWholeDocument();
+    emit selectionColorChanged(d->selectionColor);
+}
+
+/*!
+    \qmlproperty color QtQuick::TextEdit::selectedTextColor
+
+    The selected text color, used in selections.
+*/
+QColor TextEdit::selectedTextColor() const
+{
+    Q_D(const TextEdit);
+    return d->selectedTextColor;
+}
+
+void TextEdit::setSelectedTextColor(const QColor &color)
+{
+    Q_D(TextEdit);
+    if (d->selectedTextColor == color)
+        return;
+
+    d->selectedTextColor = color;
+    updateWholeDocument();
+    emit selectedTextColorChanged(d->selectedTextColor);
+}
+
+void TextEdit::setFragmentStart(int frStart) {
+    Q_D(TextEdit);
+    if (d->fragmentStartPalette)
+    {
+        d->lineControl->removePalette(d->fragmentStartPalette, false);
+    }
+
+    if (frStart <= 0) return;
+
+    if (!d->document)
+    {
+        // save in buffer
+        d->fragmentStart = frStart;
+        return;
+    }
+
+    addStartPalette(frStart);
+}
+
+void TextEdit::setFragmentEnd(int frEnd) {
+    Q_D(TextEdit);
+    if (d->fragmentEndPalette)
+        d->lineControl->removePalette(d->fragmentEndPalette, false);
+
+    if (frEnd == -1) return;
+
+    if (!d->document) {
+        d->fragmentEnd = frEnd;
+        return;
+    }
+
+    addEndPalette(frEnd);
+
+}
+
+void TextEdit::resetFragmentStart() {
+    setFragmentStart(0);
+}
+
+void TextEdit::resetFragmentEnd() {
+    setFragmentEnd(INT_MAX);
+}
+
+int TextEdit::lineNumber() const
+{
+    Q_D(const TextEdit);
+    if (!d->document || !d->control) return 0;
+
+    return d->control->textCursor().block().blockNumber() + 1;
+}
+
+int TextEdit::columnNumber() const
+{
+    Q_D(const TextEdit);
+    if (!d->document || !d->control) return 0;
+
+    return d->control->textCursor().position() - d->control->textCursor().block().position();
+}
+
+/*!
+    \qmlproperty enumeration QtQuick::TextEdit::horizontalAlignment
+    \qmlproperty enumeration QtQuick::TextEdit::verticalAlignment
+    \qmlproperty enumeration QtQuick::TextEdit::effectiveHorizontalAlignment
+
+    Sets the horizontal and vertical alignment of the text within the TextEdit item's
+    width and height. By default, the text alignment follows the natural alignment
+    of the text, for example text that is read from left to right will be aligned to
+    the left.
+
+    Valid values for \c horizontalAlignment are:
+    \list
+    \li TextEdit.AlignLeft (default)
+    \li TextEdit.AlignRight
+    \li TextEdit.AlignHCenter
+    \li TextEdit.AlignJustify
+    \endlist
+
+    Valid values for \c verticalAlignment are:
+    \list
+    \li TextEdit.AlignTop (default)
+    \li TextEdit.AlignBottom
+    \li TextEdit.AlignVCenter
+    \endlist
+
+    When using the attached property LayoutMirroring::enabled to mirror application
+    layouts, the horizontal alignment of text will also be mirrored. However, the property
+    \c horizontalAlignment will remain unchanged. To query the effective horizontal alignment
+    of TextEdit, use the read-only property \c effectiveHorizontalAlignment.
+*/
+TextEdit::HAlignment TextEdit::hAlign() const
+{
+    Q_D(const TextEdit);
+    return d->hAlign;
+}
+
+void TextEdit::setHAlign(HAlignment align)
+{
+    Q_D(TextEdit);
+    bool forceAlign = d->hAlignImplicit && d->effectiveLayoutMirror;
+    d->hAlignImplicit = false;
+    if (d->setHAlign(align, forceAlign) && isComponentComplete()) {
+        d->updateDefaultTextOption();
+        updateSize();
+    }
+}
+
+void TextEdit::resetHAlign()
+{
+    Q_D(TextEdit);
+    d->hAlignImplicit = true;
+    if (d->determineHorizontalAlignment() && isComponentComplete()) {
+        d->updateDefaultTextOption();
+        updateSize();
+    }
+}
+
+TextEdit::HAlignment TextEdit::effectiveHAlign() const
+{
+    Q_D(const TextEdit);
+    TextEdit::HAlignment effectiveAlignment = d->hAlign;
+    if (!d->hAlignImplicit && d->effectiveLayoutMirror) {
+        switch (d->hAlign) {
+        case TextEdit::AlignLeft:
+            effectiveAlignment = TextEdit::AlignRight;
+            break;
+        case TextEdit::AlignRight:
+            effectiveAlignment = TextEdit::AlignLeft;
+            break;
+        default:
+            break;
+        }
+    }
+    return effectiveAlignment;
+}
+
+bool TextEditPrivate::setHAlign(TextEdit::HAlignment alignment, bool forceAlign)
+{
+    Q_Q(TextEdit);
+    if (hAlign != alignment || forceAlign) {
+        TextEdit::HAlignment oldEffectiveHAlign = q->effectiveHAlign();
+        hAlign = alignment;
+        emit q->horizontalAlignmentChanged(alignment);
+        if (oldEffectiveHAlign != q->effectiveHAlign())
+            emit q->effectiveHorizontalAlignmentChanged();
+        return true;
+    }
+    return false;
+}
+
+
+Qt::LayoutDirection TextEditPrivate::textDirection(const QString &text) const
+{
+    const QChar *character = text.constData();
+    while (!character->isNull()) {
+        switch (character->direction()) {
+        case QChar::DirL:
+            return Qt::LeftToRight;
+        case QChar::DirR:
+        case QChar::DirAL:
+        case QChar::DirAN:
+            return Qt::RightToLeft;
+        default:
+            break;
+        }
+        character++;
+    }
+    return Qt::LayoutDirectionAuto;
+}
+
+bool TextEditPrivate::determineHorizontalAlignment()
+{
+    Q_Q(TextEdit);
+    if (!document || !control) return false;
+
+    if (hAlignImplicit && q->isComponentComplete()) {
+        Qt::LayoutDirection direction = contentDirection;
+#ifndef QT_NO_IM
+        if (direction == Qt::LayoutDirectionAuto) {
+            const QString preeditText = control->textCursor().block().layout()->preeditAreaText();
+            direction = textDirection(preeditText);
+        }
+        if (direction == Qt::LayoutDirectionAuto)
+            direction = qGuiApp->inputMethod()->inputDirection();
+#endif
+
+        return setHAlign(direction == Qt::RightToLeft ? TextEdit::AlignRight : TextEdit::AlignLeft);
+    }
+    return false;
+}
+
+void TextEditPrivate::mirrorChange()
+{
+    Q_Q(TextEdit);
+    if (q->isComponentComplete()) {
+        if (!hAlignImplicit && (hAlign == TextEdit::AlignRight || hAlign == TextEdit::AlignLeft)) {
+            updateDefaultTextOption();
+            q->updateSize();
+            emit q->effectiveHorizontalAlignmentChanged();
+        }
+    }
+}
+
+#ifndef QT_NO_IM
+Qt::InputMethodHints TextEditPrivate::effectiveInputMethodHints() const
+{
+    return inputMethodHints | Qt::ImhMultiLine;
+}
+#endif
+
+void TextEditPrivate::setTopPadding(qreal value, bool reset)
+{
+    Q_Q(TextEdit);
+    qreal oldPadding = q->topPadding();
+    if (!reset || extra.isAllocated()) {
+        extra.value().topPadding = value;
+        extra.value().explicitTopPadding = !reset;
+    }
+    if ((!reset && !qFuzzyCompare(oldPadding, value)) || (reset && !qFuzzyCompare(oldPadding, padding()))) {
+        q->updateSize();
+        emit q->topPaddingChanged();
+    }
+}
+
+void TextEditPrivate::setLeftPadding(qreal value, bool reset)
+{
+    Q_Q(TextEdit);
+    qreal oldPadding = q->leftPadding();
+    if (!reset || extra.isAllocated()) {
+        extra.value().leftPadding = value;
+        extra.value().explicitLeftPadding = !reset;
+    }
+    if ((!reset && !qFuzzyCompare(oldPadding, value)) || (reset && !qFuzzyCompare(oldPadding, padding()))) {
+        q->updateSize();
+        emit q->leftPaddingChanged();
+    }
+}
+
+void TextEditPrivate::setRightPadding(qreal value, bool reset)
+{
+    Q_Q(TextEdit);
+    qreal oldPadding = q->rightPadding();
+    if (!reset || extra.isAllocated()) {
+        extra.value().rightPadding = value;
+        extra.value().explicitRightPadding = !reset;
+    }
+    if ((!reset && !qFuzzyCompare(oldPadding, value)) || (reset && !qFuzzyCompare(oldPadding, padding()))) {
+        q->updateSize();
+        emit q->rightPaddingChanged();
+    }
+}
+
+void TextEditPrivate::setBottomPadding(qreal value, bool reset)
+{
+    Q_Q(TextEdit);
+    qreal oldPadding = q->bottomPadding();
+    if (!reset || extra.isAllocated()) {
+        extra.value().bottomPadding = value;
+        extra.value().explicitBottomPadding = !reset;
+    }
+    if ((!reset && !qFuzzyCompare(oldPadding, value)) || (reset && !qFuzzyCompare(oldPadding, padding()))) {
+        q->updateSize();
+        emit q->bottomPaddingChanged();
+    }
+}
+
+bool TextEditPrivate::isImplicitResizeEnabled() const
+{
+    return !extra.isAllocated() || extra->implicitResize;
+}
+
+void TextEditPrivate::setImplicitResizeEnabled(bool enabled)
+{
+    if (!enabled)
+        extra.value().implicitResize = false;
+    else if (extra.isAllocated())
+        extra->implicitResize = true;
+}
+
+TextEdit::VAlignment TextEdit::vAlign() const
+{
+    Q_D(const TextEdit);
+    return d->vAlign;
+}
+
+void TextEdit::setVAlign(TextEdit::VAlignment alignment)
+{
+    Q_D(TextEdit);
+    if (alignment == d->vAlign)
+        return;
+    d->vAlign = alignment;
+    d->updateDefaultTextOption();
+    updateSize();
+    moveCursorDelegate();
+    emit verticalAlignmentChanged(d->vAlign);
+}
+/*!
+    \qmlproperty enumeration QtQuick::TextEdit::wrapMode
+
+    Set this property to wrap the text to the TextEdit item's width.
+    The text will only wrap if an explicit width has been set.
+
+    \list
+    \li TextEdit.NoWrap - no wrapping will be performed. If the text contains insufficient newlines, then implicitWidth will exceed a set width.
+    \li TextEdit.WordWrap - wrapping is done on word boundaries only. If a word is too long, implicitWidth will exceed a set width.
+    \li TextEdit.WrapAnywhere - wrapping is done at any point on a line, even if it occurs in the middle of a word.
+    \li TextEdit.Wrap - if possible, wrapping occurs at a word boundary; otherwise it will occur at the appropriate point on the line, even in the middle of a word.
+    \endlist
+
+    The default is TextEdit.NoWrap. If you set a width, consider using TextEdit.Wrap.
+*/
+TextEdit::WrapMode TextEdit::wrapMode() const
+{
+    Q_D(const TextEdit);
+    return d->wrapMode;
+}
+
+void TextEdit::setWrapMode(WrapMode mode)
+{
+    Q_D(TextEdit);
+    if (mode == d->wrapMode)
+        return;
+    d->wrapMode = mode;
+    d->updateDefaultTextOption();
+    updateSize();
+    emit wrapModeChanged();
+}
+
+/*!
+    \qmlproperty int QtQuick::TextEdit::lineCount
+
+    Returns the total number of lines in the textEdit item.
+*/
+int TextEdit::lineCount() const
+{
+    Q_D(const TextEdit);
+    return d->lineCount;
+}
+
+/*!
+    \qmlproperty int QtQuick::TextEdit::length
+
+    Returns the total number of plain text characters in the TextEdit item.
+
+    As this number doesn't include any formatting markup it may not be the same as the
+    length of the string returned by the \l text property.
+
+    This property can be faster than querying the length the \l text property as it doesn't
+    require any copying or conversion of the TextEdit's internal string data.
+*/
+
+int TextEdit::length() const
+{
+    Q_D(const TextEdit);
+    if (!d->document) return 0;
+    // QTextDocument::characterCount() includes the terminating null character.
+    return qMax(0, d->document->characterCount() - 1);
+}
+
+/*!
+    \qmlproperty real QtQuick::TextEdit::contentWidth
+
+    Returns the width of the text, including the width past the width
+    which is covered due to insufficient wrapping if \l wrapMode is set.
+*/
+qreal TextEdit::contentWidth() const
+{
+    Q_D(const TextEdit);
+    return d->paintedWidth;
+}
+
+/*!
+    \qmlproperty real QtQuick::TextEdit::contentHeight
+
+    Returns the height of the text, including the height past the height
+    that is covered if the text does not fit within the set height.
+*/
+qreal TextEdit::contentHeight() const
+{
+    Q_D(const TextEdit);
+    return d->paintedHeight;
+}
+
+/*!
+    \qmlproperty url QtQuick::TextEdit::baseUrl
+
+    This property specifies a base URL which is used to resolve relative URLs
+    within the text.
+
+    The default value is the url of the QML file instantiating the TextEdit item.
+*/
+
+QUrl TextEdit::baseUrl() const
+{
+    Q_D(const TextEdit);
+    if (d->baseUrl.isEmpty()) {
+        if (QQmlContext *context = qmlContext(this))
+            const_cast<TextEditPrivate *>(d)->baseUrl = context->baseUrl();
+    }
+    return d->baseUrl;
+}
+
+void TextEdit::setBaseUrl(const QUrl &url)
+{
+    Q_D(TextEdit);
+    if (baseUrl() != url) {
+        d->baseUrl = url;
+
+        if (d->document) d->document->setBaseUrl(url);
+        emit baseUrlChanged();
+    }
+}
+
+void TextEdit::resetBaseUrl()
+{
+    if (QQmlContext *context = qmlContext(this))
+        setBaseUrl(context->baseUrl());
+    else
+        setBaseUrl(QUrl());
+}
+
+/*!
+    \qmlmethod rectangle QtQuick::TextEdit::positionToRectangle(position)
+
+    Returns the rectangle at the given \a position in the text. The x, y,
+    and height properties correspond to the cursor that would describe
+    that position.
+*/
+QRectF TextEdit::positionToRectangle(int pos) const
+{
+    Q_D(const TextEdit);
+    if (!d->document || !d->control) return QRectF();
+    QTextCursor c(d->document);
+    c.setPosition(pos);
+    return d->control->cursorRect(c).translated(d->xoff, d->yoff);
+
+}
+
+/*!
+    \qmlmethod int QtQuick::TextEdit::positionAt(int x, int y)
+
+    Returns the text position closest to pixel position (\a x, \a y).
+
+    Position 0 is before the first character, position 1 is after the first character
+    but before the second, and so on until position \l {text}.length, which is after all characters.
+*/
+int TextEdit::positionAt(qreal x, qreal y) const
+{
+    Q_D(const TextEdit);
+    if (!d->document) return -1;
+    x -= d->xoff;
+    y -= d->yoff;
+
+    int r = dynamic_cast<TextDocumentLayout*>(d->document->documentLayout())->hitTest(QPointF(x, y), Qt::FuzzyHit);
+#ifndef QT_NO_IM
+    QTextCursor cursor = d->control->textCursor();
+    if (r > cursor.position()) {
+        // The cursor position includes positions within the preedit text, but only positions in the
+        // same text block are offset so it is possible to get a position that is either part of the
+        // preedit or the next text block.
+        QTextLayout *layout = cursor.block().layout();
+        const int preeditLength = layout
+                ? layout->preeditAreaText().length()
+                : 0;
+        if (preeditLength > 0
+                && dynamic_cast<TextDocumentLayout*>(d->document->documentLayout())->blockBoundingRect(cursor.block()).contains(x, y)) {
+            r = r > cursor.position() + preeditLength
+                    ? r - preeditLength
+                    : cursor.position();
+        }
+    }
+#endif
+    return r;
+}
+
+/*!
+    \qmlmethod QtQuick::TextEdit::moveCursorSelection(int position, SelectionMode mode = TextEdit.SelectCharacters)
+
+    Moves the cursor to \a position and updates the selection according to the optional \a mode
+    parameter. (To only move the cursor, set the \l cursorPosition property.)
+
+    When this method is called it additionally sets either the
+    selectionStart or the selectionEnd (whichever was at the previous cursor position)
+    to the specified position. This allows you to easily extend and contract the selected
+    text range.
+
+    The selection mode specifies whether the selection is updated on a per character or a per word
+    basis.  If not specified the selection mode will default to TextEdit.SelectCharacters.
+
+    \list
+    \li TextEdit.SelectCharacters - Sets either the selectionStart or selectionEnd (whichever was at
+    the previous cursor position) to the specified position.
+    \li TextEdit.SelectWords - Sets the selectionStart and selectionEnd to include all
+    words between the specified position and the previous cursor position.  Words partially in the
+    range are included.
+    \endlist
+
+    For example, take this sequence of calls:
+
+    \code
+        cursorPosition = 5
+        moveCursorSelection(9, TextEdit.SelectCharacters)
+        moveCursorSelection(7, TextEdit.SelectCharacters)
+    \endcode
+
+    This moves the cursor to position 5, extend the selection end from 5 to 9
+    and then retract the selection end from 9 to 7, leaving the text from position 5 to 7
+    selected (the 6th and 7th characters).
+
+    The same sequence with TextEdit.SelectWords will extend the selection start to a word boundary
+    before or on position 5 and extend the selection end to a word boundary on or past position 9.
+*/
+void TextEdit::moveCursorSelection(int pos)
+{
+    //Note that this is the same as setCursorPosition but with the KeepAnchor flag set
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    QTextCursor cursor = d->control->textCursor();
+    if (cursor.position() == pos)
+        return;
+    cursor.setPosition(pos, QTextCursor::KeepAnchor);
+    d->control->setTextCursor(cursor);
+}
+
+void TextEdit::moveCursorSelection(int pos, SelectionMode mode)
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    QTextCursor cursor = d->control->textCursor();
+    if (cursor.position() == pos)
+        return;
+    if (mode == SelectCharacters) {
+        cursor.setPosition(pos, QTextCursor::KeepAnchor);
+    } else if (cursor.anchor() < pos || (cursor.anchor() == pos && cursor.position() < pos)) {
+        if (cursor.anchor() > cursor.position()) {
+            cursor.setPosition(cursor.anchor(), QTextCursor::MoveAnchor);
+            cursor.movePosition(QTextCursor::StartOfWord, QTextCursor::KeepAnchor);
+            if (cursor.position() == cursor.anchor())
+                cursor.movePosition(QTextCursor::PreviousWord, QTextCursor::MoveAnchor);
+            else
+                cursor.setPosition(cursor.position(), QTextCursor::MoveAnchor);
+        } else {
+            cursor.setPosition(cursor.anchor(), QTextCursor::MoveAnchor);
+            cursor.movePosition(QTextCursor::StartOfWord, QTextCursor::MoveAnchor);
+        }
+
+        cursor.setPosition(pos, QTextCursor::KeepAnchor);
+        cursor.movePosition(QTextCursor::StartOfWord, QTextCursor::KeepAnchor);
+        if (cursor.position() != pos)
+            cursor.movePosition(QTextCursor::EndOfWord, QTextCursor::KeepAnchor);
+    } else if (cursor.anchor() > pos || (cursor.anchor() == pos && cursor.position() > pos)) {
+        if (cursor.anchor() < cursor.position()) {
+            cursor.setPosition(cursor.anchor(), QTextCursor::MoveAnchor);
+            cursor.movePosition(QTextCursor::EndOfWord, QTextCursor::MoveAnchor);
+        } else {
+            cursor.setPosition(cursor.anchor(), QTextCursor::MoveAnchor);
+            cursor.movePosition(QTextCursor::PreviousCharacter, QTextCursor::KeepAnchor);
+            cursor.movePosition(QTextCursor::EndOfWord, QTextCursor::KeepAnchor);
+            if (cursor.position() != cursor.anchor()) {
+                cursor.setPosition(cursor.anchor(), QTextCursor::MoveAnchor);
+                cursor.movePosition(QTextCursor::EndOfWord, QTextCursor::MoveAnchor);
+            }
+        }
+
+        cursor.setPosition(pos, QTextCursor::KeepAnchor);
+        cursor.movePosition(QTextCursor::EndOfWord, QTextCursor::KeepAnchor);
+        if (cursor.position() != pos) {
+            cursor.movePosition(QTextCursor::PreviousCharacter, QTextCursor::KeepAnchor);
+            cursor.movePosition(QTextCursor::StartOfWord, QTextCursor::KeepAnchor);
+        }
+    }
+    d->control->setTextCursor(cursor);
+}
+
+/*!
+    \qmlproperty bool QtQuick::TextEdit::cursorVisible
+    If true the text edit shows a cursor.
+
+    This property is set and unset when the text edit gets active focus, but it can also
+    be set directly (useful, for example, if a KeyProxy might forward keys to it).
+*/
+bool TextEdit::isCursorVisible() const
+{
+    Q_D(const TextEdit);
+    return d->cursorVisible;
+}
+
+void TextEdit::setCursorVisible(bool on)
+{
+    Q_D(TextEdit);
+    d->cursorVisible = on;
+    if (on && isComponentComplete())
+        TextUtil::createCursor(d);
+    if (!on && !d->persistentSelection)
+        if (d->control) d->control->setCursorIsFocusIndicator(true);
+    if (d->control) d->control->setCursorVisible(on);
+    emit cursorVisibleChanged(d->cursorVisible);
+}
+
+/*!
+    \qmlproperty int QtQuick::TextEdit::cursorPosition
+    The position of the cursor in the TextEdit.
+*/
+int TextEdit::cursorPosition() const
+{
+    Q_D(const TextEdit);
+    if (!d->document || !d->control) return -1;
+
+    return d->control->textCursor().position();
+}
+
+void TextEdit::setCursorPosition(int pos)
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+    if (pos < 0 || pos >= d->document->characterCount()) // characterCount includes the terminating null.
+        return;
+    QTextCursor cursor = d->control->textCursor();
+    if (cursor.position() == pos && cursor.anchor() == pos)
+        return;
+    cursor.setPosition(pos);
+    d->control->setTextCursor(cursor);
+    d->control->updateCursorRectangle(true);
+}
+
+/*!
+    \qmlproperty Component QtQuick::TextEdit::cursorDelegate
+    The delegate for the cursor in the TextEdit.
+
+    If you set a cursorDelegate for a TextEdit, this delegate will be used for
+    drawing the cursor instead of the standard cursor. An instance of the
+    delegate will be created and managed by the text edit when a cursor is
+    needed, and the x and y properties of delegate instance will be set so as
+    to be one pixel before the top left of the current character.
+
+    Note that the root item of the delegate component must be a QQuickItem or
+    QQuickItem derived item.
+*/
+QQmlComponent* TextEdit::cursorDelegate() const
+{
+    Q_D(const TextEdit);
+    return d->cursorComponent;
+}
+
+void TextEdit::setCursorDelegate(QQmlComponent* c)
+{
+    Q_D(TextEdit);
+    TextUtil::setCursorDelegate(d, c);
+}
+
+void TextEdit::createCursor()
+{
+    Q_D(TextEdit);
+    d->cursorPending = true;
+    TextUtil::createCursor(d);
+}
+
+/*!
+    \qmlproperty int QtQuick::TextEdit::selectionStart
+
+    The cursor position before the first character in the current selection.
+
+    This property is read-only. To change the selection, use select(start,end),
+    selectAll(), or selectWord().
+
+    \sa selectionEnd, cursorPosition, selectedText
+*/
+int TextEdit::selectionStart() const
+{
+    Q_D(const TextEdit);
+    if (!d->document || !d->control) return -1;
+
+    return d->control->textCursor().selectionStart();
+}
+
+/*!
+    \qmlproperty int QtQuick::TextEdit::selectionEnd
+
+    The cursor position after the last character in the current selection.
+
+    This property is read-only. To change the selection, use select(start,end),
+    selectAll(), or selectWord().
+
+    \sa selectionStart, cursorPosition, selectedText
+*/
+int TextEdit::selectionEnd() const
+{
+    Q_D(const TextEdit);
+    if (!d->document || !d->control) return -1;
+
+    return d->control->textCursor().selectionEnd();
+}
+
+/*!
+    \qmlproperty string QtQuick::TextEdit::selectedText
+
+    This read-only property provides the text currently selected in the
+    text edit.
+
+    It is equivalent to the following snippet, but is faster and easier
+    to use.
+    \code
+    //myTextEdit is the id of the TextEdit
+    myTextEdit.text.toString().substring(myTextEdit.selectionStart,
+            myTextEdit.selectionEnd);
+    \endcode
+*/
+QString TextEdit::selectedText() const
+{
+    Q_D(const TextEdit);
+    if (!d->document || !d->control) return QString();
+
+#ifndef QT_NO_TEXTHTMLPARSER
+    return d->richText
+            ? d->control->textCursor().selectedText()
+            : d->control->textCursor().selection().toPlainText();
+#else
+    return d->control->textCursor().selection().toPlainText();
+#endif
+}
+
+/*!
+    \qmlproperty bool QtQuick::TextEdit::activeFocusOnPress
+
+    Whether the TextEdit should gain active focus on a mouse press. By default this is
+    set to true.
+*/
+bool TextEdit::focusOnPress() const
+{
+    Q_D(const TextEdit);
+    return d->focusOnPress;
+}
+
+void TextEdit::setFocusOnPress(bool on)
+{
+    Q_D(TextEdit);
+    if (d->focusOnPress == on)
+        return;
+    d->focusOnPress = on;
+    emit activeFocusOnPressChanged(d->focusOnPress);
+}
+
+/*!
+    \qmlproperty bool QtQuick::TextEdit::persistentSelection
+
+    Whether the TextEdit should keep the selection visible when it loses active focus to another
+    item in the scene. By default this is set to false.
+*/
+bool TextEdit::persistentSelection() const
+{
+    Q_D(const TextEdit);
+    return d->persistentSelection;
+}
+
+void TextEdit::setPersistentSelection(bool on)
+{
+    Q_D(TextEdit);
+    if (d->persistentSelection == on)
+        return;
+    d->persistentSelection = on;
+    emit persistentSelectionChanged(d->persistentSelection);
+}
+
+/*!
+   \qmlproperty real QtQuick::TextEdit::textMargin
+
+   The margin, in pixels, around the text in the TextEdit.
+*/
+qreal TextEdit::textMargin() const
+{
+    Q_D(const TextEdit);
+    return d->textMargin;
+}
+
+void TextEdit::setTextMargin(qreal margin)
+{
+    Q_D(TextEdit);
+
+    if (abs(d->textMargin - margin) < LV_ACCURACY)
+        return;
+    d->textMargin = margin;
+    if (!d->document) d->document->setDocumentMargin(d->textMargin);
+    emit textMarginChanged(d->textMargin);
+}
+
+/*!
+    \qmlproperty enumeration QtQuick::TextEdit::inputMethodHints
+
+    Provides hints to the input method about the expected content of the text edit and how it
+    should operate.
+
+    The value is a bit-wise combination of flags or Qt.ImhNone if no hints are set.
+
+    Flags that alter behaviour are:
+
+    \list
+    \li Qt.ImhHiddenText - Characters should be hidden, as is typically used when entering passwords.
+    \li Qt.ImhSensitiveData - Typed text should not be stored by the active input method
+            in any persistent storage like predictive user dictionary.
+    \li Qt.ImhNoAutoUppercase - The input method should not try to automatically switch to upper case
+            when a sentence ends.
+    \li Qt.ImhPreferNumbers - Numbers are preferred (but not required).
+    \li Qt.ImhPreferUppercase - Upper case letters are preferred (but not required).
+    \li Qt.ImhPreferLowercase - Lower case letters are preferred (but not required).
+    \li Qt.ImhNoPredictiveText - Do not use predictive text (i.e. dictionary lookup) while typing.
+
+    \li Qt.ImhDate - The text editor functions as a date field.
+    \li Qt.ImhTime - The text editor functions as a time field.
+    \endlist
+
+    Flags that restrict input (exclusive flags) are:
+
+    \list
+    \li Qt.ImhDigitsOnly - Only digits are allowed.
+    \li Qt.ImhFormattedNumbersOnly - Only number input is allowed. This includes decimal point and minus sign.
+    \li Qt.ImhUppercaseOnly - Only upper case letter input is allowed.
+    \li Qt.ImhLowercaseOnly - Only lower case letter input is allowed.
+    \li Qt.ImhDialableCharactersOnly - Only characters suitable for phone dialing are allowed.
+    \li Qt.ImhEmailCharactersOnly - Only characters suitable for email addresses are allowed.
+    \li Qt.ImhUrlCharactersOnly - Only characters suitable for URLs are allowed.
+    \endlist
+
+    Masks:
+
+    \list
+    \li Qt.ImhExclusiveInputMask - This mask yields nonzero if any of the exclusive flags are used.
+    \endlist
+*/
+
+Qt::InputMethodHints TextEdit::inputMethodHints() const
+{
+#ifdef QT_NO_IM
+    return Qt::ImhNone;
+#else
+    Q_D(const TextEdit);
+    return d->inputMethodHints;
+#endif // QT_NO_IM
+}
+
+void TextEdit::setInputMethodHints(Qt::InputMethodHints hints)
+{
+#ifdef QT_NO_IM
+    Q_UNUSED(hints);
+#else
+    Q_D(TextEdit);
+
+    if (hints == d->inputMethodHints)
+        return;
+
+    d->inputMethodHints = hints;
+    updateInputMethod(Qt::ImHints);
+    emit inputMethodHintsChanged();
+#endif // QT_NO_IM
+}
+
+void TextEdit::geometryChanged(const QRectF &newGeometry,
+                                  const QRectF &oldGeometry)
+{
+    Q_D(TextEdit);
+    if (!d->inLayout && ((abs(newGeometry.width() - oldGeometry.width()) > LV_ACCURACY && widthValid())
+        || (abs(newGeometry.height() - oldGeometry.height()) > LV_ACCURACY && heightValid()))) {
+        updateSize();
+        updateWholeDocument();
+        moveCursorDelegate();
+    }
+    QQuickItem::geometryChanged(newGeometry, oldGeometry);
+
+}
+
+/*!
+    Ensures any delayed caching or data loading the class
+    needs to performed is complete.
+*/
+void TextEdit::componentComplete()
+{
+    Q_D(TextEdit);
+
+    QQuickItem::componentComplete();
+    if (!d->document || !d->control) return;
+
+    d->document->setBaseUrl(baseUrl());
+#ifndef QT_NO_TEXTHTML_PARSER
+    if (d->richText)
+        d->control->setHtml(d->text);
+    else
+#endif
+    if (!d->text.isEmpty())
+        d->control->setPlainText(d->text);
+
+    if (d->dirty) {
+        d->determineHorizontalAlignment();
+        d->updateDefaultTextOption();
+        updateSize();
+        d->dirty = false;
+    }
+    if (d->cursorComponent && isCursorVisible())
+        TextUtil::createCursor(d);
+}
+
+/*!
+    \qmlproperty bool QtQuick::TextEdit::selectByKeyboard
+    \since 5.1
+
+    Defaults to true when the editor is editable, and false
+    when read-only.
+
+    If true, the user can use the keyboard to select text
+    even if the editor is read-only. If false, the user
+    cannot use the keyboard to select text even if the
+    editor is editable.
+
+    \sa readOnly
+*/
+bool TextEdit::selectByKeyboard() const
+{
+    Q_D(const TextEdit);
+    if (d->selectByKeyboardSet)
+        return d->selectByKeyboard;
+    return !isReadOnly();
+}
+
+void TextEdit::setSelectByKeyboard(bool on)
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    bool was = selectByKeyboard();
+    if (!d->selectByKeyboardSet || was != on) {
+        d->selectByKeyboardSet = true;
+        d->selectByKeyboard = on;
+        if (on)
+            d->control->setTextInteractionFlags(d->control->textInteractionFlags() | Qt::TextSelectableByKeyboard);
+        else
+            d->control->setTextInteractionFlags(d->control->textInteractionFlags() & ~Qt::TextSelectableByKeyboard);
+        emit selectByKeyboardChanged(on);
+    }
+}
+
+/*!
+    \qmlproperty bool QtQuick::TextEdit::selectByMouse
+
+    Defaults to false.
+
+    If true, the user can use the mouse to select text in some
+    platform-specific way. Note that for some platforms this may
+    not be an appropriate interaction; it may conflict with how
+    the text needs to behave inside a Flickable, for example.
+*/
+bool TextEdit::selectByMouse() const
+{
+    Q_D(const TextEdit);
+    return d->selectByMouse;
+}
+
+void TextEdit::setSelectByMouse(bool on)
+{
+    Q_D(TextEdit);
+
+    d->selectByMouse = on;
+    setKeepMouseGrab(on);
+    if (on) {
+        if (d->control) d->control->setTextInteractionFlags(d->control->textInteractionFlags() | Qt::TextSelectableByMouse);
+    }
+    else if (d->control)
+        d->control->setTextInteractionFlags(d->control->textInteractionFlags() & ~Qt::TextSelectableByMouse);
+    emit selectByMouseChanged(on);
+
+}
+
+/*!
+    \qmlproperty enumeration QtQuick::TextEdit::mouseSelectionMode
+
+    Specifies how text should be selected using a mouse.
+
+    \list
+    \li TextEdit.SelectCharacters - The selection is updated with individual characters. (Default)
+    \li TextEdit.SelectWords - The selection is updated with whole words.
+    \endlist
+
+    This property only applies when \l selectByMouse is true.
+*/
+TextEdit::SelectionMode TextEdit::mouseSelectionMode() const
+{
+    Q_D(const TextEdit);
+    return d->mouseSelectionMode;
+}
+
+void TextEdit::setMouseSelectionMode(SelectionMode mode)
+{
+    Q_D(TextEdit);
+
+    d->mouseSelectionMode = mode;
+    if (d->control) d->control->setWordSelectionEnabled(mode == SelectWords);
+    emit mouseSelectionModeChanged(mode);
+}
+
+/*!
+    \qmlproperty bool QtQuick::TextEdit::readOnly
+
+    Whether the user can interact with the TextEdit item. If this
+    property is set to true the text cannot be edited by user interaction.
+
+    By default this property is false.
+*/
+void TextEdit::setReadOnly(bool r)
+{
+    Q_D(TextEdit);
+
+    d->readOnly = r;
+#ifndef QT_NO_IM
+    setFlag(QQuickItem::ItemAcceptsInputMethod, !d->readOnly);
+#endif
+    Qt::TextInteractionFlags flags = Qt::LinksAccessibleByMouse;
+    if (d->selectByMouse)
+        flags = flags | Qt::TextSelectableByMouse;
+    if (d->selectByKeyboardSet && d->selectByKeyboard)
+        flags = flags | Qt::TextSelectableByKeyboard;
+    else if (!d->selectByKeyboardSet && !d->readOnly)
+        flags = flags | Qt::TextSelectableByKeyboard;
+    if (!d->readOnly)
+        flags = flags | Qt::TextEditable;
+    if (d->control)
+    {
+        d->control->setTextInteractionFlags(flags);
+        d->control->moveCursor(QTextCursor::End);
+    }
+
+#ifndef QT_NO_IM
+    updateInputMethod(Qt::ImEnabled);
+#endif
+    q_canPasteChanged();
+    emit readOnlyChanged(d->readOnly);
+    if (!d->selectByKeyboardSet)
+        emit selectByKeyboardChanged(!d->readOnly);
+    if (d->readOnly) {
+        setCursorVisible(false);
+    } else if (hasActiveFocus()) {
+        setCursorVisible(true);
+    }
+}
+
+bool TextEdit::isReadOnly() const
+{
+    Q_D(const TextEdit);
+    return d->readOnly;
+}
+
+/*!
+    \qmlproperty rectangle QtQuick::TextEdit::cursorRectangle
+
+    The rectangle where the standard text cursor is rendered
+    within the text edit. Read-only.
+
+    The position and height of a custom cursorDelegate are updated to follow the cursorRectangle
+    automatically when it changes.  The width of the delegate is unaffected by changes in the
+    cursor rectangle.
+*/
+QRectF TextEdit::cursorRectangle() const
+{
+    Q_D(const TextEdit);
+    if (!d->document || !d->control) return QRectF();
+
+    return d->control->cursorRect().translated(d->xoff, d->yoff);
+}
+
+bool TextEdit::event(QEvent *event)
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return QQuickItem::event(event);
+
+    if (event->type() == QEvent::ShortcutOverride) {
+        d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
+        return event->isAccepted();
+    }
+    return QQuickItem::event(event);
+}
+
+/*!
+\overload
+Handles the given key \a event.
+*/
+void TextEdit::keyPressEvent(QKeyEvent *event)
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control)
+    {
+        QQuickItem::keyPressEvent(event);
+        return;
+    }
+
+    d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
+    if (!event->isAccepted())
+        QQuickItem::keyPressEvent(event);
+}
+
+/*!
+\overload
+Handles the given key \a event.
+*/
+void TextEdit::keyReleaseEvent(QKeyEvent *event)
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control)
+    {
+        QQuickItem::keyReleaseEvent(event);
+        return;
+    }
+    d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
+    if (!event->isAccepted())
+        QQuickItem::keyReleaseEvent(event);
+}
+
+/*!
+    \qmlmethod QtQuick::TextEdit::deselect()
+
+    Removes active text selection.
+*/
+void TextEdit::deselect()
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    QTextCursor c = d->control->textCursor();
+    c.clearSelection();
+    d->control->setTextCursor(c);
+}
+
+/*!
+    \qmlmethod QtQuick::TextEdit::selectAll()
+
+    Causes all text to be selected.
+*/
+void TextEdit::selectAll()
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    d->control->selectAll();
+}
+
+/*!
+    \qmlmethod QtQuick::TextEdit::selectWord()
+
+    Causes the word closest to the current cursor position to be selected.
+*/
+void TextEdit::selectWord()
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    QTextCursor c = d->control->textCursor();
+    c.select(QTextCursor::WordUnderCursor);
+    d->control->setTextCursor(c);
+}
+
+/*!
+    \qmlmethod QtQuick::TextEdit::select(int start, int end)
+
+    Causes the text from \a start to \a end to be selected.
+
+    If either start or end is out of range, the selection is not changed.
+
+    After calling this, selectionStart will become the lesser
+    and selectionEnd will become the greater (regardless of the order passed
+    to this method).
+
+    \sa selectionStart, selectionEnd
+*/
+void TextEdit::select(int start, int end)
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    if (start < 0 || end < 0 || start >= d->document->characterCount() || end >= d->document->characterCount())
+        return;
+    QTextCursor cursor = d->control->textCursor();
+    cursor.beginEditBlock();
+    cursor.setPosition(start, QTextCursor::MoveAnchor);
+    cursor.setPosition(end, QTextCursor::KeepAnchor);
+    cursor.endEditBlock();
+    d->control->setTextCursor(cursor);
+
+    // QTBUG-11100
+    updateSelection();
+    updateInputMethod();
+}
+
+/*!
+    \qmlmethod QtQuick::TextEdit::isRightToLeft(int start, int end)
+
+    Returns true if the natural reading direction of the editor text
+    found between positions \a start and \a end is right to left.
+*/
+bool TextEdit::isRightToLeft(int start, int end)
+{
+    if (start > end) {
+        qmlInfo(this) << "isRightToLeft(start, end) called with the end property being smaller than the start.";
+        return false;
+    } else {
+        return getText(start, end).isRightToLeft();
+    }
+}
+
+#ifndef QT_NO_CLIPBOARD
+/*!
+    \qmlmethod QtQuick::TextEdit::cut()
+
+    Moves the currently selected text to the system clipboard.
+*/
+void TextEdit::cut()
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    d->control->cut();
+}
+
+/*!
+    \qmlmethod QtQuick::TextEdit::copy()
+
+    Copies the currently selected text to the system clipboard.
+*/
+void TextEdit::copy()
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    d->control->copy();
+}
+
+/*!
+    \qmlmethod QtQuick::TextEdit::paste()
+
+    Replaces the currently selected text by the contents of the system clipboard.
+*/
+void TextEdit::paste()
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    d->control->paste();
+}
+#endif // QT_NO_CLIPBOARD
+
+
+/*!
+    \qmlmethod QtQuick::TextEdit::undo()
+
+    Undoes the last operation if undo is \l {canUndo}{available}. Deselects any
+    current selection, and updates the selection start to the current cursor
+    position.
+*/
+
+void TextEdit::undo()
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    d->control->undo();
+}
+
+/*!
+    \qmlmethod QtQuick::TextEdit::redo()
+
+    Redoes the last operation if redo is \l {canRedo}{available}.
+*/
+
+void TextEdit::redo()
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    d->control->redo();
+}
+
+/*!
+\overload
+Handles the given mouse \a event.
+*/
+void TextEdit::mousePressEvent(QMouseEvent *event)
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control)
+    {
+        QQuickItem::mousePressEvent(event);
+        return;
+    }
+
+    d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
+    if (d->focusOnPress){
+        bool hadActiveFocus = hasActiveFocus();
+        forceActiveFocus(Qt::MouseFocusReason);
+        // re-open input panel on press if already focused
+#ifndef QT_NO_IM
+        if (hasActiveFocus() && hadActiveFocus && !isReadOnly())
+            qGuiApp->inputMethod()->show();
+#else
+        Q_UNUSED(hadActiveFocus);
+#endif
+    }
+    if (!event->isAccepted())
+        QQuickItem::mousePressEvent(event);
+}
+
+/*!
+\overload
+Handles the given mouse \a event.
+*/
+void TextEdit::mouseReleaseEvent(QMouseEvent *event)
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control)
+    {
+        QQuickItem::mouseReleaseEvent(event);
+        return;
+    }
+    d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
+
+    if (!event->isAccepted())
+        QQuickItem::mouseReleaseEvent(event);
+}
+
+/*!
+\overload
+Handles the given mouse \a event.
+*/
+void TextEdit::mouseDoubleClickEvent(QMouseEvent *event)
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control)
+    {
+        QQuickItem::mouseDoubleClickEvent(event);
+        return;
+    }
+    d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
+    if (!event->isAccepted())
+        QQuickItem::mouseDoubleClickEvent(event);
+}
+
+/*!
+\overload
+Handles the given mouse \a event.
+*/
+void TextEdit::mouseMoveEvent(QMouseEvent *event)
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control)
+    {
+        QQuickItem::mouseMoveEvent(event);
+        return;
+    }
+    d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
+    if (!event->isAccepted())
+        QQuickItem::mouseMoveEvent(event);
+}
+
+#ifndef QT_NO_IM
+/*!
+\overload
+Handles the given input method \a event.
+*/
+void TextEdit::inputMethodEvent(QInputMethodEvent *event)
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+    const bool wasComposing = isInputMethodComposing();
+    d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
+    setCursorVisible(d->control->cursorVisible());
+    if (wasComposing != isInputMethodComposing())
+        emit inputMethodComposingChanged();
+}
+
+/*!
+\overload
+Returns the value of the given \a property and \a argument.
+*/
+QVariant TextEdit::inputMethodQuery(Qt::InputMethodQuery property, QVariant argument) const
+{
+    Q_D(const TextEdit);
+
+    QVariant v;
+    switch (property) {
+    case Qt::ImEnabled:
+        v = static_cast<bool>(flags() & ItemAcceptsInputMethod);
+        break;
+    case Qt::ImHints:
+        v = static_cast<int>(d->effectiveInputMethodHints());
+        break;
+    case Qt::ImInputItemClipRectangle:
+        v = QQuickItem::inputMethodQuery(property);
+        break;
+    default:
+        if (property == Qt::ImCursorPosition && !argument.isNull())
+            argument = QVariant(argument.toPointF() - QPointF(d->xoff, d->yoff));
+        if (!d->document || !d->control) break;
+        v = d->control->inputMethodQuery(property, argument);
+        if (property == Qt::ImCursorRectangle || property == Qt::ImAnchorRectangle)
+            v = QVariant(v.toRectF().translated(d->xoff, d->yoff));
+        break;
+    }
+    return v;
+}
+
+/*!
+\overload
+Returns the value of the given \a property.
+*/
+QVariant TextEdit::inputMethodQuery(Qt::InputMethodQuery property) const
+{
+    return inputMethodQuery(property, QVariant());
+}
+#endif // QT_NO_IM
+
+void TextEdit::triggerPreprocess()
+{
+    Q_D(TextEdit);
+    if (d->updateType == TextEditPrivate::UpdateNone)
+        d->updateType = TextEditPrivate::UpdateOnlyPreprocess;
+    polish();
+    update();
+}
+
+typedef QList<TextEditPrivate::Node*>::iterator TextNodeIterator;
+
+
+static bool comesBefore(TextEditPrivate::Node* n1, TextEditPrivate::Node* n2)
+{
+    return n1->startPos() < n2->startPos();
+}
+
+static inline void updateNodeTransform(TextNode* node, const QPointF &topLeft)
+{
+    QMatrix4x4 transformMatrix;
+    transformMatrix.translate(static_cast<float>(topLeft.x()), static_cast<float>(topLeft.y()));
+    node->setMatrix(transformMatrix);
+}
+
+/*!
+ * \internal
+ *
+ * Invalidates font caches owned by the text objects owned by the element
+ * to work around the fact that text objects cannot be used from multiple threads.
+ */
+void TextEdit::invalidateFontCaches()
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+
+    QTextBlock block;
+    for (block = d->document->firstBlock(); block.isValid(); block = block.next()) {
+        if (block.layout() != nullptr && block.layout()->engine() != nullptr)
+            block.layout()->engine()->resetFontEngineCache();
+    }
+}
+
+void TextEdit::addStartPalette(int frStart)
+{
+    Q_D(TextEdit);
+
+    d->fragmentStartPalette = new QQuickItem(this);
+    d->fragmentStartPalette->setHeight(0);
+    // handle fragment start palette
+    int lastPosition;
+    if (frStart == 1)
+    {
+        lastPosition = 0;
+    }
+    else
+    {
+        QTextBlock endBlock = d->document->findBlockByNumber(frStart-2);
+        if (endBlock != QTextBlock())
+            lastPosition = endBlock.position() + endBlock.length();
+        else
+            lastPosition = 0;
+    }
+
+    d->lineControl->addPalette(0, frStart-1, d->fragmentStartPalette, 0, lastPosition);
+}
+
+void TextEdit::addEndPalette(int frEnd)
+{
+    Q_D(TextEdit);
+
+    if (frEnd > d->document->blockCount()) return;
+
+    d->fragmentEndPalette = new QQuickItem(this);
+    d->fragmentEndPalette->setHeight(0);
+    // handle fragment end
+    int firstPosition;
+    int span;
+    if (frEnd == d->document->blockCount())
+    {
+        firstPosition = d->document->characterCount();
+        span = 0;
+    }
+    else
+    {
+        QTextBlock startBlock = d->document->findBlockByNumber(frEnd);
+        firstPosition = startBlock.position();
+        span = d->document->blockCount()-frEnd;
+    }
+    d->lineControl->addPalette(frEnd,span, d->fragmentEndPalette, firstPosition, d->document->characterCount());
+
+}
+
+inline void resetEngine(TextNodeEngine *engine, const QColor& textColor, const QColor& selectedTextColor, const QColor& selectionColor)
+{
+    *engine = TextNodeEngine();
+    engine->setTextColor(textColor);
+    engine->setSelectedTextColor(selectedTextColor);
+    engine->setSelectionColor(selectionColor);
+}
+
+QSGNode *TextEdit::updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData *updatePaintNodeData)
+{
+    Q_UNUSED(updatePaintNodeData);
+    Q_D(TextEdit);
+
+    if (!d->document || !d->control) {
+        if (oldNode) delete oldNode;
+        return nullptr;
+    }
+
+    if (d->updateType != TextEditPrivate::UpdatePaintNode && oldNode != nullptr) {
+        // Update done in preprocess() in the nodes
+        d->updateType = TextEditPrivate::UpdateNone;
+        return oldNode;
+    }
+
+    d->updateType = TextEditPrivate::UpdateNone;
+
+    if (!oldNode) {
+        // If we had any QQuickTextNode node references, they were deleted along with the root node
+        // But here we must delete the Node structures in textNodeMap
+        qDeleteAll(d->textNodeMap);
+        d->textNodeMap.clear();
+    }
+
+    RootNode *rootNode = static_cast<RootNode *>(oldNode);
+    TextNodeIterator nodeIterator = d->textNodeMap.begin();
+
+    while (nodeIterator != d->textNodeMap.end() && !(*nodeIterator)->dirty())
+        ++nodeIterator;
+
+    TextNodeEngine engine;
+    TextNodeEngine frameDecorationsEngine;
+
+    d->lastHighlightChangeStart = INT_MAX;
+    d->lastHighlightChangeEnd   = 0;
+
+    if (!oldNode || nodeIterator < d->textNodeMap.end()) {
+
+        if (!oldNode)
+            rootNode = new RootNode;
+
+        int firstDirtyPos = 0;
+        if (nodeIterator != d->textNodeMap.end()) {
+            firstDirtyPos = (*nodeIterator)->startPos();
+            do {
+                rootNode->removeChildNode((*nodeIterator)->textNode());
+                delete (*nodeIterator)->textNode();
+                delete *nodeIterator;
+                nodeIterator = d->textNodeMap.erase(nodeIterator);
+            } while (nodeIterator != d->textNodeMap.end() && (d->invalidUntilTheEnd || (*nodeIterator)->dirty()));
+        }
+
+        // FIXME: the text decorations could probably be handled separately (only updated for affected textFrames)
+        rootNode->resetFrameDecorations(d->createTextNode());
+        resetEngine(&frameDecorationsEngine, d->color, d->selectedTextColor, d->selectionColor);
+
+        TextNode *node = nullptr;
+
+        int currentNodeSize = 0;
+        int nodeStart = firstDirtyPos;
+        QPointF basePosition(d->xoff, d->yoff);
+        QMatrix4x4 basePositionMatrix;
+        basePositionMatrix.translate(static_cast<float>(basePosition.x()), static_cast<float>(basePosition.y()));
+        rootNode->setMatrix(basePositionMatrix);
+
+        QPointF nodeOffset;
+        TextEditPrivate::Node *firstCleanNode = (nodeIterator != d->textNodeMap.end() && !d->invalidUntilTheEnd) ? *nodeIterator : nullptr;
+
+        d->invalidUntilTheEnd = false;
+
+        if (d->document && d->control) {
+            QList<QTextFrame *> frames;
+            frames.append(d->document->rootFrame());
+
+            while (!frames.isEmpty()) { //INFO: Root frame
+                QTextFrame *textFrame = frames.takeFirst();
+                frames.append(textFrame->childFrames());
+                frameDecorationsEngine.addFrameDecorations(d->document, textFrame);
+
+                if (textFrame->lastPosition() < firstDirtyPos || (firstCleanNode && textFrame->firstPosition() >= firstCleanNode->startPos()))
+                    continue;
+
+                //INFO: creating the text node
+                node = d->createTextNode();
+                resetEngine(&engine, d->color, d->selectedTextColor, d->selectionColor);
+
+                if (textFrame->firstPosition() > textFrame->lastPosition()
+                        && textFrame->frameFormat().position() != QTextFrameFormat::InFlow) {
+
+                    updateNodeTransform(node, dynamic_cast<TextDocumentLayout*>(d->document->documentLayout())->frameBoundingRect(textFrame).topLeft());
+                    const int pos = textFrame->firstPosition() - 1;
+                    ProtectedLayoutAccessor *a = static_cast<ProtectedLayoutAccessor *>(d->document->documentLayout());
+                    QTextCharFormat format = a->formatAccessor(pos);
+                    QTextBlock block = textFrame->firstCursorPosition().block();
+                    engine.setCurrentLine(block.layout()->lineForTextPosition(pos - block.position()));
+                    engine.addTextObject(QPointF(0, 0), format, TextNodeEngine::Unselected, d->document,
+                                                  pos, textFrame->frameFormat().position());
+                    nodeStart = pos;
+                } else {
+                    // Having nodes spanning across frame boundaries will break the current bookkeeping mechanism. We need to prevent that.
+                    QList<int> frameBoundaries;
+                    frameBoundaries.reserve(frames.size());
+                    Q_FOREACH (QTextFrame *frame, frames)
+                        frameBoundaries.append(frame->firstPosition());
+                    std::sort(frameBoundaries.begin(), frameBoundaries.end());
+
+                    QTextFrame::iterator it = textFrame->begin();
+
+                    while (!it.atEnd()) {
+
+                        QTextBlock block = it.currentBlock();
+                        ++it;
+
+                        if (block.position() < firstDirtyPos)
+                            continue;
+
+                        if (!block.isVisible()) continue;
+
+                        if (!engine.hasContents()) {
+                            nodeOffset = getDocumentLayout()->blockBoundingRect(block).topLeft();
+                            updateNodeTransform(node, nodeOffset);
+
+                            // PALETTE
+                            // int offset = d->paletteManager->drawingOffset(block.blockNumber(), false);
+                            int offset = d->lineControl->drawingOffset(block.blockNumber(), false);
+                            nodeOffset.setY(nodeOffset.y() - offset);
+
+                            nodeStart = block.position();
+                        }
+
+                        engine.addTextBlock(d->document, block, -nodeOffset, d->color, QColor(), selectionStart(), selectionEnd() - 1);
+                        currentNodeSize += block.length();
+
+                        if ((it.atEnd()) || (firstCleanNode && block.next().position() >= firstCleanNode->startPos())) // last node that needed replacing or last block of the frame
+                            break;
+
+                        QList<int>::const_iterator lowerBound = std::lower_bound(frameBoundaries.constBegin(), frameBoundaries.constEnd(), block.next().position());
+                        if (currentNodeSize > nodeBreakingSize || lowerBound == frameBoundaries.constEnd() || *lowerBound > nodeStart) {
+                            currentNodeSize = 0;
+                            d->addCurrentTextNodeToRoot(&engine, rootNode, node, nodeIterator, nodeStart);
+                            node = d->createTextNode();
+                            resetEngine(&engine, d->color, d->selectedTextColor, d->selectionColor);
+                            nodeStart = block.next().position();
+                        }
+                    }
+                }
+                d->addCurrentTextNodeToRoot(&engine, rootNode, node, nodeIterator, nodeStart);
+            }
+        }
+
+
+        frameDecorationsEngine.addToSceneGraph(rootNode->frameDecorationsNode, QQuickText::Normal, QColor());
+        // Now prepend the frame decorations since we want them rendered first, with the text nodes and cursor in front.
+        rootNode->prependChildNode(rootNode->frameDecorationsNode);
+
+        Q_ASSERT(nodeIterator == d->textNodeMap.end() || (*nodeIterator) == firstCleanNode);
+        // Update the position of the subsequent text blocks.
+        if (d->document && firstCleanNode) {
+            QPointF oldOffset = firstCleanNode->textNode()->matrix().map(QPointF(0,0));
+            QPointF currentOffset = dynamic_cast<TextDocumentLayout*>(d->document->documentLayout())->blockBoundingRect(d->document->findBlock(firstCleanNode->startPos())).topLeft();
+            QPointF delta = currentOffset - oldOffset;
+            while (nodeIterator != d->textNodeMap.end()) {
+                QMatrix4x4 transformMatrix = (*nodeIterator)->textNode()->matrix();
+                transformMatrix.translate(static_cast<float>(delta.x()), static_cast<float>(delta.y()));
+                (*nodeIterator)->textNode()->setMatrix(transformMatrix);
+                ++nodeIterator;
+            }
+
+        }
+
+        // Since we iterate over blocks from different text frames that are potentially not sorted
+        // we need to ensure that our list of nodes is sorted again:
+        std::sort(d->textNodeMap.begin(), d->textNodeMap.end(), &comesBefore);
+    }
+
+    if (d->document && d->control && d->cursorComponent == nullptr) {
+        QSGRectangleNode* cursor = nullptr;
+#if (QT_VERSION > QT_VERSION_CHECK(5,7,1))
+        if (!isReadOnly() && d->cursorVisible && d->control->cursorOn()){ // change for 5.11
+            cursor = d->sceneGraphContext()->createRectangleNode();
+            cursor->setRect(d->control->cursorRect());
+            cursor->setColor(d->color);
+        }
+#else
+        if (!isReadOnly() && d->cursorVisible && d->control->cursorOn())
+            cursor = d->sceneGraphContext()->createRectangleNode(d->control->cursorRect(), d->color);
+#endif
+        rootNode->resetCursorNode(cursor);
+    }
+
+    invalidateFontCaches();
+
+    return rootNode;
+}
+
+void TextEdit::updatePolish()
+{
+    invalidateFontCaches();
+}
+
+/*!
+    \qmlproperty bool QtQuick::TextEdit::canPaste
+
+    Returns true if the TextEdit is writable and the content of the clipboard is
+    suitable for pasting into the TextEdit.
+*/
+bool TextEdit::canPaste() const
+{
+    Q_D(const TextEdit);
+    if (!d->document || !d->control) return false;
+
+    if (!d->canPasteValid) {
+        const_cast<TextEditPrivate *>(d)->canPaste = d->control->canPaste();
+        const_cast<TextEditPrivate *>(d)->canPasteValid = true;
+    }
+    return d->canPaste;
+}
+
+/*!
+    \qmlproperty bool QtQuick::TextEdit::canUndo
+
+    Returns true if the TextEdit is writable and there are previous operations
+    that can be undone.
+*/
+
+bool TextEdit::canUndo() const
+{
+    Q_D(const TextEdit);
+    if (!d->document) return false;
+
+    return d->document->isUndoAvailable();
+}
+
+/*!
+    \qmlproperty bool QtQuick::TextEdit::canRedo
+
+    Returns true if the TextEdit is writable and there are \l {undo}{undone}
+    operations that can be redone.
+*/
+
+bool TextEdit::canRedo() const
+{
+    Q_D(const TextEdit);
+    if (!d->document) return false;
+
+    return d->document->isRedoAvailable();
+}
+
+/*!
+    \qmlproperty bool QtQuick::TextEdit::inputMethodComposing
+
+
+    This property holds whether the TextEdit has partial text input from an
+    input method.
+
+    While it is composing an input method may rely on mouse or key events from
+    the TextEdit to edit or commit the partial text.  This property can be used
+    to determine when to disable events handlers that may interfere with the
+    correct operation of an input method.
+*/
+bool TextEdit::isInputMethodComposing() const
+{
+#ifdef QT_NO_IM
+    return false;
+#else
+    Q_D(const TextEdit);
+    if (!d->document || !d->control) return false;
+    return d->control->hasImState();
+#endif // QT_NO_IM
+}
+
+TextEditPrivate::ExtraData::ExtraData()
+    : padding(0)
+    , topPadding(0)
+    , leftPadding(0)
+    , rightPadding(0)
+    , bottomPadding(0)
+    , explicitTopPadding(false)
+    , explicitLeftPadding(false)
+    , explicitRightPadding(false)
+    , explicitBottomPadding(false)
+    , implicitResize(true)
+{
+}
+
+void TextEditPrivate::setTextDocument(QTextDocument *doc)
+{
+
+    if (document)
+        unsetTextDocument();
+    Q_Q(TextEdit);
+    document = doc;
+    
+    if (lineSurface)
+        lineSurface->setDocument(lineControl->lineDocument());
+
+    control = new TextControl(document, q);
+    control->setTextInteractionFlags(Qt::LinksAccessibleByMouse | Qt::TextSelectableByKeyboard | Qt::TextEditable);
+    control->setAcceptRichText(false);
+    control->setCursorIsFocusIndicator(true);
+
+    control->setTextEdit(q);
+
+    lv_qmlobject_connect(control, TextControl, SIGNAL(updateCursorRequest()), q, TextEdit, SLOT(updateCursor()));
+    lv_qmlobject_connect(control, TextControl, SIGNAL(selectionChanged()), q, TextEdit, SIGNAL(selectedTextChanged()));
+    lv_qmlobject_connect(control, TextControl, SIGNAL(selectionChanged()), q, TextEdit, SLOT(updateSelection()));
+    lv_qmlobject_connect(control, TextControl, SIGNAL(cursorPositionChanged()), q, TextEdit, SLOT(updateSelection()));
+    lv_qmlobject_connect(control, TextControl, SIGNAL(cursorPositionChanged()), q, TextEdit, SIGNAL(cursorPositionChanged()));
+    lv_qmlobject_connect(control, TextControl, SIGNAL(cursorPositionChanged()), q, TextEdit, SIGNAL(lineNumberChanged()));
+    lv_qmlobject_connect(control, TextControl, SIGNAL(cursorPositionChanged()), q, TextEdit, SIGNAL(columnNumberChanged()));
+    lv_qmlobject_connect(control, TextControl, SIGNAL(cursorRectangleChanged()), q, TextEdit, SLOT(moveCursorDelegate()));
+    lv_qmlobject_connect(control, TextControl, SIGNAL(linkActivated(QString)), q, TextEdit, SIGNAL(linkActivated(QString)));
+    lv_qmlobject_connect(control, TextControl, SIGNAL(linkHovered(QString)), q, TextEdit, SIGNAL(linkHovered(QString)));
+    lv_qmlobject_connect(control, TextControl, SIGNAL(textChanged()), q, TextEdit, SLOT(q_textChanged()));
+    lv_qmlobject_connect(control, TextControl, SIGNAL(preeditTextChanged()), q, TextEdit, SIGNAL(preeditTextChanged()));
+    /*#if QT_CONFIG(clipboard)
+        qmlobject_connect(QGuiApplication::clipboard(), QClipboard, SIGNAL(dataChanged()), q, QQuickTextEdit, SLOT(q_canPasteChanged()));
+    #endif*/
+    lv_qmlobject_connect(document, QTextDocument, SIGNAL(undoAvailable(bool)), q, TextEdit, SIGNAL(canUndoChanged()));
+    lv_qmlobject_connect(document, QTextDocument, SIGNAL(redoAvailable(bool)), q, TextEdit, SIGNAL(canRedoChanged()));
+
+    if (document->defaultFont() != font && font.pixelSize() > 0)
+    {
+        document->setDefaultFont(font);
+    }
+
+
+    if (document->documentMargin() != textMargin)
+    {
+        document->setDocumentMargin(textMargin);
+    }
+    document->setUndoRedoEnabled(false); // flush undo buffer.
+    document->setUndoRedoEnabled(true);
+
+    q->setCursorVisible(cursorVisible);
+    q->setSelectByMouse(selectByMouse);
+    q->setMouseSelectionMode(mouseSelectionMode);
+    q->setReadOnly(readOnly);
+    updateDefaultTextOption();
+    q->updateSize();
+
+#ifdef LV_EDITOR_DEBUG
+    debugModel->updateModel(0, document->blockCount());
+#endif
+    QObject::connect(document, &QTextDocument::contentsChange, q, &TextEdit::q_contentsChange);
+    QObject::connect(document->documentLayout(), &QAbstractTextDocumentLayout::updateBlock, q, &TextEdit::invalidateBlock);
+    QObject::connect(document->documentLayout(), &QAbstractTextDocumentLayout::update, q, &TextEdit::highlightingDone);
+
+    document->setTextWidth(-1);
+    auto rect = q->getDocumentLayout()->blockBoundingRect(document->rootFrame()->begin().currentBlock());
+    lineControl->setBlockHeight(static_cast<int>(rect.height()));
+    lineControl->setDirtyPos(0);
+    lineControl->lineNumberChange();
+
+    // handle buffered palettes
+    if (fragmentStart != -1)
+    {
+        q->addStartPalette(fragmentStart);
+        fragmentStart = -1;
+    }
+
+    if (fragmentEnd != -1)
+    {
+        q->addEndPalette(fragmentEnd);
+        fragmentEnd = -1;
+    }
+}
+
+void TextEditPrivate::unsetTextDocument()
+{
+    Q_Q(TextEdit);
+    if ( document ){
+
+        q->markDirtyNodesForRange(0, document->characterCount(), 0);
+        lineSurface->unsetTextDocument();
+
+        QObject::disconnect(document, &QTextDocument::undoAvailable, q, &TextEdit::canUndoChanged);
+        QObject::disconnect(document, &QTextDocument::redoAvailable, q, &TextEdit::canRedoChanged);
+
+        QObject::disconnect(document, &QTextDocument::contentsChange, q, &TextEdit::q_contentsChange);
+        QObject::disconnect(document->documentLayout(), &QAbstractTextDocumentLayout::updateBlock, q, &TextEdit::invalidateBlock);
+        QObject::disconnect(document->documentLayout(), &QAbstractTextDocumentLayout::update, q, &TextEdit::highlightingDone);
+    }
+
+
+    if (control)
+    {
+        control->disconnect();
+        delete control;
+        control = nullptr;
+    }
+
+    document = nullptr;
+    lineControl->reset();
+
+    q->polish();
+    if (q->isComponentComplete()) {
+        updateType = TextEditPrivate::UpdatePaintNode;
+        q->update();
+    }
+
+}
+
+void TextEditPrivate::init()
+{
+    Q_Q(TextEdit);
+
+#ifndef QT_NO_CLIPBOARD
+    if (QGuiApplication::clipboard()->supportsSelection())
+        q->setAcceptedMouseButtons(Qt::LeftButton | Qt::MiddleButton);
+    else
+#endif
+        q->setAcceptedMouseButtons(Qt::LeftButton);
+
+#ifndef QT_NO_IM
+    q->setFlag(QQuickItem::ItemAcceptsInputMethod);
+#endif
+    q->setFlag(QQuickItem::ItemHasContents);
+
+    q->setAcceptHoverEvents(true);
+
+
+#ifndef QT_NO_CLIPBOARD
+    lv_qmlobject_connect(QGuiApplication::clipboard(), QClipboard, SIGNAL(dataChanged()), q, TextEdit, SLOT(q_canPasteChanged()));
+#endif
+
+#ifdef LV_EDITOR_DEBUG
+    debugModel = new TextEditNodeDebugModel(q);
+#endif
+    lineControl = new LineControl(q);
+}
+
+void TextEditPrivate::resetInputMethod()
+{
+    Q_Q(TextEdit);
+    if (!q->isReadOnly() && q->hasActiveFocus() && qGuiApp)
+        QGuiApplication::inputMethod()->reset();
+}
+
+void TextEdit::q_textChanged()
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+    d->textCached = false;
+    for (QTextBlock it = d->document->begin(); it != d->document->end(); it = it.next()) {
+        d->contentDirection = d->textDirection(it.text());
+        if (d->contentDirection != Qt::LayoutDirectionAuto)
+            break;
+    }
+    d->determineHorizontalAlignment();
+    d->updateDefaultTextOption();
+    updateSize();
+    emit textChanged();
+}
+
+void TextEdit::markDirtyNodesForRange(int start, int end, int charDelta)
+{
+    Q_D(TextEdit);
+    if (start == end)
+        return;
+
+    int oldEnd = end;
+    bool nodesUpdate = true;
+
+    if ( start < d->lastHighlightChangeStart && end > d->lastHighlightChangeEnd ){ // stretch both ways
+        d->lastHighlightChangeStart = start;
+        d->lastHighlightChangeEnd   = end;
+    } else if ( start < d->lastHighlightChangeStart ){ // stretch left
+        end = d->lastHighlightChangeStart;
+        d->lastHighlightChangeStart = start;
+    } else if ( end > d->lastHighlightChangeEnd ){ // stretch right
+        start = d->lastHighlightChangeEnd;
+        d->lastHighlightChangeEnd = end;
+    } else {
+        nodesUpdate = false; // this is inside the interval we're updating
+    }
+
+    if (start == end) nodesUpdate = false;
+
+    TextEditPrivate::Node dummyNode(start, nullptr);
+    TextNodeIterator it = std::lower_bound(d->textNodeMap.begin(), d->textNodeMap.end(), &dummyNode, &comesBefore);
+    if (nodesUpdate || charDelta)
+    {
+        // qLowerBound gives us the first node past the start of the affected portion, rewind to the first node
+        // that starts at the last position before the edit position. (there might be several because of images)
+        if (it != d->textNodeMap.begin()) {
+            --it;
+            TextEditPrivate::Node otherDummy((*it)->startPos(), nullptr);
+            it = std::lower_bound(d->textNodeMap.begin(), d->textNodeMap.end(), &otherDummy, &comesBefore);
+        }
+    }
+
+    TextNodeIterator otherIt = it;
+
+    if (nodesUpdate)
+    {
+        while (it != d->textNodeMap.end() && (*it)->startPos() <= end)
+        {
+            (*it)->setDirty(); ++it;
+        }
+    }
+
+    if (charDelta)
+    {
+        while (otherIt != d->textNodeMap.end() && (*otherIt)->startPos() <= oldEnd)
+        {
+            ++otherIt;
+        }
+
+        while (otherIt != d->textNodeMap.end())
+        {
+            (*otherIt)->moveStartPos(charDelta);
+            ++otherIt;
+        }
+    }
+}
+
+void TextEdit::q_contentsChange(int pos, int charsRemoved, int charsAdded)
+{
+    Q_D(TextEdit);
+
+    const int editRange = pos + qMax(charsAdded, charsRemoved);
+    const int delta = charsAdded - charsRemoved;
+
+    /*std::list<QQuickItem*> results = getPaletteManager()->updatePaletteBounds(pos, charsRemoved, charsAdded);
+    if (!results.empty())
+    {
+        for (auto it = results.begin(); it != results.end(); ++it)
+        {
+            QMetaObject::invokeMethod(*it, "close", Qt::DirectConnection);
+        }
+    }*/
+
+    d->lineControl->updateSectionBounds(pos, charsRemoved, charsAdded);
+
+#ifdef LV_EDITOR_DEBUG
+    QObject* livecv    = ViewContext::instance().engine()->engine()->rootContext()->contextProperty("livecv").value<QObject*>();
+    QObject* windowControls;
+    QMetaObject::invokeMethod(livecv, "windowControls", Qt::DirectConnection, Q_RETURN_ARG(QObject*, windowControls));
+    if (windowControls && !d->debugView){
+        QVariant windowVariant;
+        QMetaObject::invokeMethod(windowControls, "createNewWindow", Qt::DirectConnection, Q_RETURN_ARG(QVariant, windowVariant));
+        QQuickWindow* window = qvariant_cast<QQuickWindow*>(windowVariant);
+        QString contents(LockedFileIOSession::createInstance()->readFromFile("C:\\Users\\NeRad\\Desktop\\Github\\livecv\\application\\qml\\TextEditNodeView.qml").c_str());
+        d->debugView = static_cast<QQuickItem*>(ViewContext::instance().engine()->createObject(
+                    contents,
+                    qvariant_cast<QQuickItem*>(window->property("item")),
+                    QUrl(QStringLiteral("qrc:/TextEditNodeView.qml"))));
+
+        d->debugView->setProperty("model", QVariant::fromValue(d->debugModel));
+    }
+#endif
+    if (d->document && getDocumentLayout())
+    {
+        d->dirtyPosition = d->document->findBlock(pos).blockNumber();
+        d->lineControl->setDirtyPos(d->dirtyPosition);
+    }
+
+    markDirtyNodesForRange(pos, editRange, delta);
+
+    d->highlightingInProgress = true;
+
+    polish();
+    if (isComponentComplete()) {
+        d->updateType = TextEditPrivate::UpdatePaintNode;
+        update();
+    }
+}
+
+void TextEdit::moveCursorDelegate()
+{
+    Q_D(TextEdit);
+#ifndef QT_NO_IM
+    updateInputMethod();
+#endif
+    emit cursorRectangleChanged();
+    if (!d->cursorItem)
+        return;
+    QRectF cursorRect = cursorRectangle();
+    d->cursorItem->setX(cursorRect.x());
+    d->cursorItem->setY(cursorRect.y());
+}
+
+void TextEdit::updateSelection()
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    // No need for node updates when we go from an empty selection to another empty selection
+    if (d->control->textCursor().hasSelection() || d->hadSelection) {
+        markDirtyNodesForRange(qMin(d->lastSelectionStart, d->control->textCursor().selectionStart()), qMax(d->control->textCursor().selectionEnd(), d->lastSelectionEnd), 0);
+        polish();
+        if (isComponentComplete()) {
+            d->updateType = TextEditPrivate::UpdatePaintNode;
+            update();
+        }
+    }
+
+    d->hadSelection = d->control->textCursor().hasSelection();
+
+    if (d->lastSelectionStart != d->control->textCursor().selectionStart()) {
+        d->lastSelectionStart = d->control->textCursor().selectionStart();
+        emit selectionStartChanged();
+    }
+    if (d->lastSelectionEnd != d->control->textCursor().selectionEnd()) {
+        d->lastSelectionEnd = d->control->textCursor().selectionEnd();
+        emit selectionEndChanged();
+    }
+}
+
+QRectF TextEdit::boundingRect() const
+{
+    Q_D(const TextEdit);
+    if (!d->document || !d->control) return QRectF();
+
+    QRectF r(
+            TextUtil::alignedX(d->contentSize.width(), width(), effectiveHAlign()),
+            d->yoff,
+            d->contentSize.width(),
+            d->contentSize.height());
+
+    int cursorWidth = 1;
+    if (d->cursorItem)
+        cursorWidth = 0;
+    else if (!d->document->isEmpty())
+        cursorWidth += 3;// ### Need a better way of accounting for space between char and cursor
+
+    // Could include font max left/right bearings to either side of rectangle.
+    r.setRight(r.right() + cursorWidth);
+
+    return r;
+}
+
+QRectF TextEdit::clipRect() const
+{
+    Q_D(const TextEdit);
+    QRectF r = QQuickItem::clipRect();
+    if (!d->document || !d->control) return r;
+
+    int cursorWidth = 1;
+    if (d->cursorItem)
+        cursorWidth = static_cast<int>(d->cursorItem->width());
+    if (!d->document->isEmpty())
+        cursorWidth += 3;// ### Need a better way of accounting for space between char and cursor
+
+    // Could include font max left/right bearings to either side of rectangle.
+
+    r.setRight(r.right() + cursorWidth);
+    return r;
+}
+
+qreal TextEditPrivate::getImplicitWidth() const
+{
+    Q_Q(const TextEdit);
+    if (!requireImplicitWidth) {
+        // We don't calculate implicitWidth unless it is required.
+        // We need to force a size update now to ensure implicitWidth is calculated
+        const_cast<TextEditPrivate*>(this)->requireImplicitWidth = true;
+        const_cast<TextEdit*>(q)->updateSize();
+    }
+    return implicitWidth;
+}
+
+//### we should perhaps be a bit smarter here -- depending on what has changed, we shouldn't
+//    need to do all the calculations each time
+void TextEdit::updateSize()
+{
+    Q_D(TextEdit);
+
+    if (!isComponentComplete()) {
+        d->dirty = true;
+        return;
+    }
+
+    if (!d->document || !d->control) return;
+
+    if (d->document->textWidth() != -1 )
+        d->document->setTextWidth(-1);
+
+    qreal naturalWidth = d->implicitWidth - leftPadding() - rightPadding();
+
+
+    qreal newWidth = d->document->idealWidth();
+    // ### assumes that if the width is set, the text will fill to edges
+    // ### (unless wrap is false, then clipping will occur)
+    if (widthValid()) {
+        if (!d->requireImplicitWidth) {
+            emit implicitWidthChanged();
+            // if the implicitWidth is used, then updateSize() has already been called (recursively)
+            if (d->requireImplicitWidth)
+                return;
+        }
+        if (d->requireImplicitWidth) {
+            d->document->setTextWidth(-1);
+            naturalWidth = d->document->idealWidth();
+
+            const bool wasInLayout = d->inLayout;
+            d->inLayout = true;
+            if (d->isImplicitResizeEnabled())
+                setImplicitWidth(naturalWidth + leftPadding() + rightPadding());
+            d->inLayout = wasInLayout;
+            if (d->inLayout)    // probably the result of a binding loop, but by letting it
+                return;         // get this far we'll get a warning to that effect.
+        }
+//        d->document->setTextWidth(-1);
+//        if (abs(d->document->textWidth() - width()) > LV_ACCURACY) {
+//            d->document->setTextWidth(width() - leftPadding() - rightPadding());
+//            newWidth = d->document->idealWidth();
+//        }
+        //### need to confirm cost of always setting these
+    } else if (d->wrapMode == NoWrap && abs(d->document->textWidth() - newWidth) > LV_ACCURACY) {
+//        d->document->setTextWidth(newWidth); // ### Text does not align if width is not set or the idealWidth exceeds the textWidth (QTextDoc bug)
+    } else {
+//        d->document->setTextWidth(-1);
+    }
+
+    QFontMetricsF fm(d->font);
+    qreal newHeight = d->document->isEmpty() ? qCeil(fm.height()) : d->document->size().height();
+
+    if (d->isImplicitResizeEnabled()) {
+        // ### Setting the implicitWidth triggers another updateSize(), and unless there are bindings nothing has changed.
+        if (!widthValid() && !d->requireImplicitWidth)
+            setImplicitSize(newWidth + leftPadding() + rightPadding(), newHeight + topPadding() + bottomPadding());
+        else
+            setImplicitHeight(newHeight + topPadding() + bottomPadding());
+    }
+
+    d->xoff = leftPadding() + qMax(qreal(0), TextUtil::alignedX(d->document->size().width(), width() - leftPadding() - rightPadding(), effectiveHAlign()));
+    d->yoff = topPadding() + TextUtil::alignedY(d->document->size().height(), height() - topPadding() - bottomPadding(), d->vAlign);
+    setBaselineOffset(fm.ascent() + d->yoff + d->textMargin);
+
+    QTextBlock contentStart = d->document->findBlockByNumber(d->lineControl->firstContentLine());
+    int contentSpan = d->lineControl->lastContentLine() - d->lineControl->firstContentLine();
+    int width = 0;
+    int lineHeight = 0;
+    for (int i = 0; i < contentSpan; i++)
+    {
+        auto rect = d->document->documentLayout()->blockBoundingRect(contentStart);
+        width = std::max(width, static_cast<int>(rect.width()));
+        if (lineHeight == 0) lineHeight = static_cast<int>(rect.height());
+        contentStart = contentStart.next();
+    }
+
+    d->paintedWidth = width;
+    d->paintedHeight = (d->document->blockCount() + d->lineControl->totalOffset())*lineHeight;
+
+    QSizeF size(d->paintedWidth, d->paintedHeight);
+    if (d->contentSize != size) {
+        d->contentSize = size;
+        emit contentSizeChanged();
+        updateTotalLines();
+    }
+}
+
+void TextEdit::updateWholeDocument()
+{
+    Q_D(TextEdit);
+    if (!d->textNodeMap.isEmpty()) {
+        Q_FOREACH (TextEditPrivate::Node* node, d->textNodeMap)
+            node->setDirty();
+    }
+
+    polish();
+    if (isComponentComplete()) {
+        d->updateType = TextEditPrivate::UpdatePaintNode;
+        update();
+    }
+}
+
+void TextEdit::highlightingDone(const QRectF &)
+{
+    Q_D(TextEdit);
+
+    if (d->highlightingInProgress)
+    {
+        d->highlightingInProgress = false;
+#ifdef LV_EDITOR_DEBUG
+        d->debugModel->updateModel(d->dirtyPosition, d->document->blockCount());
+#endif
+    }
+}
+
+void TextEdit::stateChangeHandler(const QTextBlock &block)
+{
+    Q_D(TextEdit);
+    ProjectDocumentBlockData* userData = static_cast<ProjectDocumentBlockData*>(block.userData());
+
+    if (userData && userData->stateChangeFlag())
+    {
+        userData->setStateChangeFlag(false);
+        d->lineControl->setDirtyPos(block.blockNumber());
+        d->lineControl->updateLinesInDocuments();
+        d->lineSurface->triggerUpdate(d->document->blockCount(), d->dirtyPosition);
+    }
+#ifdef LV_EDITOR_DEBUG
+    d->debugModel->updateModel(block.blockNumber(), d->document->blockCount());
+#endif
+}
+
+void TextEdit::invalidateBlock(const QTextBlock &block)
+{
+    Q_D(TextEdit);
+
+    markDirtyNodesForRange(block.position(), block.position() + block.length(), 0);
+
+    stateChangeHandler(block);
+
+    polish();
+    if (isComponentComplete()) {
+        updateSize();
+        d->updateType = TextEditPrivate::UpdatePaintNode;
+        update();
+    }
+}
+
+void TextEdit::updateCursor()
+{
+    Q_D(TextEdit);
+    polish();
+    if (isComponentComplete()) {
+        d->updateType = TextEditPrivate::UpdatePaintNode;
+        update();
+    }
+}
+
+void TextEdit::q_updateAlignment()
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    if (d->determineHorizontalAlignment()) {
+        d->updateDefaultTextOption();
+        d->xoff = qMax(qreal(0), TextUtil::alignedX(d->document->size().width(), width(), effectiveHAlign()));
+        moveCursorDelegate();
+    }
+}
+
+void TextEdit::updateTotalLines()
+{
+    Q_D(TextEdit);
+
+    int subLines = 0;
+    if (!d->document || !d->control) return;
+
+    for (QTextBlock it = d->document->begin(); it != d->document->end(); it = it.next()) {
+        QTextLayout *layout = it.layout();
+        if (!layout)
+            continue;
+        subLines += layout->lineCount()-1;
+    }
+
+    int newTotalLines = d->document->lineCount() + subLines;
+    if (d->lineCount != newTotalLines) {
+        d->lineCount = newTotalLines;
+        emit lineCountChanged();
+        if (d->lineSurface) d->lineSurface->triggerUpdate(d->document->blockCount(), d->dirtyPosition);
+    }
+}
+
+void TextEditPrivate::updateDefaultTextOption()
+{
+    Q_Q(TextEdit);
+    if (!document || !control) return;
+
+    QTextOption opt = document->defaultTextOption();
+    int oldAlignment = opt.alignment();
+    Qt::LayoutDirection oldTextDirection = opt.textDirection();
+
+    TextEdit::HAlignment horizontalAlignment = q->effectiveHAlign();
+    if (contentDirection == Qt::RightToLeft) {
+        if (horizontalAlignment == TextEdit::AlignLeft)
+            horizontalAlignment = TextEdit::AlignRight;
+        else if (horizontalAlignment == TextEdit::AlignRight)
+            horizontalAlignment = TextEdit::AlignLeft;
+    }
+    if (!hAlignImplicit)
+        opt.setAlignment(static_cast<Qt::Alignment>(static_cast<int>(horizontalAlignment | vAlign)));
+    else
+        opt.setAlignment(Qt::Alignment(vAlign));
+
+#ifndef QT_NO_IM
+    if (contentDirection == Qt::LayoutDirectionAuto) {
+        opt.setTextDirection(qGuiApp->inputMethod()->inputDirection());
+    } else
+#endif
+    {
+        opt.setTextDirection(contentDirection);
+    }
+
+    QTextOption::WrapMode oldWrapMode = opt.wrapMode();
+    opt.setWrapMode(QTextOption::WrapMode(wrapMode));
+
+    bool oldUseDesignMetrics = opt.useDesignMetrics();
+    opt.setUseDesignMetrics(renderType != TextEdit::NativeRendering);
+
+    if (oldWrapMode != opt.wrapMode() || oldAlignment != opt.alignment()
+        || oldTextDirection != opt.textDirection()
+        || oldUseDesignMetrics != opt.useDesignMetrics()) {
+        document->setDefaultTextOption(opt);
+    }
+}
+
+void TextEdit::focusInEvent(QFocusEvent *event)
+{
+    Q_D(TextEdit);
+    d->handleFocusEvent(event);
+    QQuickItem::focusInEvent(event);
+}
+
+void TextEdit::focusOutEvent(QFocusEvent *event)
+{
+    Q_D(TextEdit);
+    d->handleFocusEvent(event);
+    QQuickItem::focusOutEvent(event);
+}
+
+void TextEditPrivate::handleFocusEvent(QFocusEvent *event)
+{
+    Q_Q(TextEdit);
+    if (!document || !control) return;
+    bool focus = event->type() == QEvent::FocusIn;
+    if (!q->isReadOnly())
+        q->setCursorVisible(focus);
+    control->processEvent(event, QPointF(-xoff, -yoff));
+    if (focus) {
+        q->q_updateAlignment();
+#ifndef QT_NO_IM
+        if (focusOnPress && !q->isReadOnly())
+            qGuiApp->inputMethod()->show();
+        q->connect(QGuiApplication::inputMethod(), SIGNAL(inputDirectionChanged(Qt::LayoutDirection)),
+                q, SLOT(q_updateAlignment()));
+#endif
+    } else {
+#ifndef QT_NO_IM
+        q->disconnect(QGuiApplication::inputMethod(), SIGNAL(inputDirectionChanged(Qt::LayoutDirection)),
+                   q, SLOT(q_updateAlignment()));
+#endif
+        emit q->editingFinished();
+    }
+}
+
+void TextEditPrivate::addCurrentTextNodeToRoot(TextNodeEngine *engine, QSGTransformNode *root, TextNode *node, TextNodeIterator &it, int startPos)
+{
+    engine->addToSceneGraph(node, QQuickText::Normal, QColor());
+    it = textNodeMap.insert(it, new TextEditPrivate::Node(startPos, node));
+    ++it;
+    root->appendChildNode(node);
+}
+
+TextNode *TextEditPrivate::createTextNode()
+{
+    Q_Q(TextEdit);
+    TextNode* node = new TextNode(q);
+    node->setUseNativeRenderer(renderType == TextEdit::NativeRendering);
+    return node;
+}
+
+void TextEdit::q_canPasteChanged()
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+    bool old = d->canPaste;
+    d->canPaste = d->control->canPaste();
+    bool changed = old!=d->canPaste || !d->canPasteValid;
+    d->canPasteValid = true;
+    if (changed)
+        emit canPasteChanged();
+}
+
+/*!
+    \qmlmethod string QtQuick::TextEdit::getText(int start, int end)
+
+    Returns the section of text that is between the \a start and \a end positions.
+
+    The returned text does not include any rich text formatting.
+*/
+
+QString TextEdit::getText(int start, int end) const
+{
+    Q_D(const TextEdit);
+    if (!d->document || !d->control) return QString();
+
+    start = qBound(0, start, d->document->characterCount() - 1);
+    end = qBound(0, end, d->document->characterCount() - 1);
+    QTextCursor cursor(d->document);
+    cursor.setPosition(start, QTextCursor::MoveAnchor);
+    cursor.setPosition(end, QTextCursor::KeepAnchor);
+#ifndef QT_NO_TEXTHTMLPARSER
+    return d->richText
+            ? cursor.selectedText()
+            : cursor.selection().toPlainText();
+#else
+    return cursor.selection().toPlainText();
+#endif
+}
+
+/*!
+    \qmlmethod string QtQuick::TextEdit::getFormattedText(int start, int end)
+
+    Returns the section of text that is between the \a start and \a end positions.
+
+    The returned text will be formatted according the \l textFormat property.
+*/
+
+QString TextEdit::getFormattedText(int start, int end) const
+{
+    Q_D(const TextEdit);
+    if (!d->document || !d->control) return QString();
+
+
+    start = qBound(0, start, d->document->characterCount() - 1);
+    end = qBound(0, end, d->document->characterCount() - 1);
+
+    QTextCursor cursor(d->document);
+    cursor.setPosition(start, QTextCursor::MoveAnchor);
+    cursor.setPosition(end, QTextCursor::KeepAnchor);
+
+    if (d->richText) {
+#ifndef QT_NO_TEXTHTMLPARSER
+        return cursor.selection().toHtml();
+#else
+        return cursor.selection().toPlainText();
+#endif
+    } else {
+        return cursor.selection().toPlainText();
+    }
+}
+
+/*!
+    \qmlmethod QtQuick::TextEdit::insert(int position, string text)
+
+    Inserts \a text into the TextEdit at position.
+*/
+void TextEdit::insert(int position, const QString &text)
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    if (position < 0 || position >= d->document->characterCount())
+        return;
+    QTextCursor cursor(d->document);
+    cursor.setPosition(position);
+    d->richText = d->richText || (d->format == AutoText && Qt::mightBeRichText(text));
+    if (d->richText) {
+#ifndef QT_NO_TEXTHTMLPARSER
+        cursor.insertHtml(text);
+#else
+        cursor.insertText(text);
+#endif
+    } else {
+        cursor.insertText(text);
+    }
+    d->control->updateCursorRectangle(false);
+}
+
+/*!
+    \qmlmethod string QtQuick::TextEdit::remove(int start, int end)
+
+    Removes the section of text that is between the \a start and \a end positions from the TextEdit.
+*/
+
+void TextEdit::remove(int start, int end)
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    start = qBound(0, start, d->document->characterCount() - 1);
+    end = qBound(0, end, d->document->characterCount() - 1);
+    QTextCursor cursor(d->document);
+    cursor.setPosition(start, QTextCursor::MoveAnchor);
+    cursor.setPosition(end, QTextCursor::KeepAnchor);
+    cursor.removeSelectedText();
+    d->control->updateCursorRectangle(false);
+}
+
+bool TextEditPrivate::isLinkHoveredConnected()
+{
+    Q_Q(TextEdit);
+    LV_IS_SIGNAL_CONNECTED(q, TextEdit, linkHovered, (const QString &));
+}
+
+/*!
+    \qmlsignal QtQuick::TextEdit::linkHovered(string link)
+    \since 5.2
+
+    This signal is emitted when the user hovers a link embedded in the text.
+    The link must be in rich text or HTML format and the
+    \a link string provides access to the particular link.
+
+    The corresponding handler is \c onLinkHovered.
+
+    \sa hoveredLink, linkAt()
+*/
+
+/*!
+    \qmlsignal QtQuick::TextEdit::editingFinished()
+    \since 5.6
+
+    This signal is emitted when the text edit loses focus.
+
+    The corresponding handler is \c onEditingFinished.
+*/
+
+/*!
+    \qmlproperty string QtQuick::TextEdit::hoveredLink
+    \since 5.2
+
+    This property contains the link string when the user hovers a link
+    embedded in the text. The link must be in rich text or HTML format
+    and the link string provides access to the particular link.
+
+    \sa linkHovered, linkAt()
+*/
+
+QString TextEdit::hoveredLink() const
+{
+    Q_D(const TextEdit);
+    if (!d->document || !d->control) return QString();
+
+    if (const_cast<TextEditPrivate *>(d)->isLinkHoveredConnected()) {
+        return d->control->hoveredLink();
+    } else {
+#ifndef QT_NO_CURSOR
+        if (QQuickWindow *wnd = window()) {
+            QPointF pos = QCursor::pos(wnd->screen()) - wnd->position() - mapToScene(QPointF(0, 0));
+            return d->control->anchorAt(pos);
+        }
+#endif // QT_NO_CURSOR
+    }
+    return QString();
+}
+
+void TextEdit::hoverEnterEvent(QHoverEvent *event)
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    if (d->isLinkHoveredConnected())
+        d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
+}
+
+void TextEdit::hoverMoveEvent(QHoverEvent *event)
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    if (d->isLinkHoveredConnected())
+        d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
+}
+
+void TextEdit::hoverLeaveEvent(QHoverEvent *event)
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    if (d->isLinkHoveredConnected())
+        d->control->processEvent(event, QPointF(-d->xoff, -d->yoff));
+}
+
+/*!
+    \qmlmethod void QtQuick::TextEdit::append(string text)
+    \since 5.2
+
+    Appends a new paragraph with \a text to the end of the TextEdit.
+
+    In order to append without inserting a new paragraph,
+    call \c myTextEdit.insert(myTextEdit.length, text) instead.
+*/
+void TextEdit::append(const QString &text)
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+    QTextCursor cursor(d->document);
+    cursor.beginEditBlock();
+    cursor.movePosition(QTextCursor::End);
+
+    if (!d->document->isEmpty())
+        cursor.insertBlock();
+
+#ifndef QT_NO_TEXTHTMLPARSER
+    if (d->format == RichText || (d->format == AutoText && Qt::mightBeRichText(text))) {
+        cursor.insertHtml(text);
+    } else {
+        cursor.insertText(text);
+    }
+#else
+    cursor.insertText(text);
+#endif // QT_NO_TEXTHTMLPARSER
+
+    cursor.endEditBlock();
+    d->control->updateCursorRectangle(false);
+}
+
+/*!
+    \qmlmethod QtQuick::TextEdit::linkAt(real x, real y)
+    \since 5.3
+
+    Returns the link string at point \a x, \a y in content coordinates,
+    or an empty string if no link exists at that point.
+
+    \sa hoveredLink
+*/
+QString TextEdit::linkAt(qreal x, qreal y) const
+{
+    Q_D(const TextEdit);
+    if (!d->document || !d->control) return QString();
+
+    return d->control->anchorAt(QPointF(x + topPadding(), y + leftPadding()));
+}
+
+/*!
+    \since 5.6
+    \qmlproperty real QtQuick::TextEdit::padding
+    \qmlproperty real QtQuick::TextEdit::topPadding
+    \qmlproperty real QtQuick::TextEdit::leftPadding
+    \qmlproperty real QtQuick::TextEdit::bottomPadding
+    \qmlproperty real QtQuick::TextEdit::rightPadding
+
+    These properties hold the padding around the content. This space is reserved
+    in addition to the contentWidth and contentHeight.
+*/
+qreal TextEdit::padding() const
+{
+    Q_D(const TextEdit);
+    return d->padding();
+}
+
+void TextEdit::setPadding(qreal padding)
+{
+    Q_D(TextEdit);
+    if (qFuzzyCompare(d->padding(), padding))
+        return;
+
+    d->extra.value().padding = padding;
+    updateSize();
+    if (isComponentComplete()) {
+        d->updateType = TextEditPrivate::UpdatePaintNode;
+        update();
+    }
+    emit paddingChanged();
+    if (!d->extra.isAllocated() || !d->extra->explicitTopPadding)
+        emit topPaddingChanged();
+    if (!d->extra.isAllocated() || !d->extra->explicitLeftPadding)
+        emit leftPaddingChanged();
+    if (!d->extra.isAllocated() || !d->extra->explicitRightPadding)
+        emit rightPaddingChanged();
+    if (!d->extra.isAllocated() || !d->extra->explicitBottomPadding)
+        emit bottomPaddingChanged();
+}
+
+void TextEdit::resetPadding()
+{
+    setPadding(0);
+}
+
+qreal TextEdit::topPadding() const
+{
+    Q_D(const TextEdit);
+    if (d->extra.isAllocated() && d->extra->explicitTopPadding)
+        return d->extra->topPadding;
+    return d->padding();
+}
+
+void TextEdit::setTopPadding(qreal padding)
+{
+    Q_D(TextEdit);
+    d->setTopPadding(padding);
+}
+
+void TextEdit::resetTopPadding()
+{
+    Q_D(TextEdit);
+    d->setTopPadding(0, true);
+}
+
+qreal TextEdit::leftPadding() const
+{
+    Q_D(const TextEdit);
+    if (d->extra.isAllocated() && d->extra->explicitLeftPadding)
+        return d->extra->leftPadding;
+    return d->padding();
+}
+
+void TextEdit::setLeftPadding(qreal padding)
+{
+    Q_D(TextEdit);
+    d->setLeftPadding(padding);
+}
+
+void TextEdit::resetLeftPadding()
+{
+    Q_D(TextEdit);
+    d->setLeftPadding(0, true);
+}
+
+qreal TextEdit::rightPadding() const
+{
+    Q_D(const TextEdit);
+    if (d->extra.isAllocated() && d->extra->explicitRightPadding)
+        return d->extra->rightPadding;
+    return d->padding();
+}
+
+void TextEdit::setRightPadding(qreal padding)
+{
+    Q_D(TextEdit);
+    d->setRightPadding(padding);
+}
+
+void TextEdit::resetRightPadding()
+{
+    Q_D(TextEdit);
+    d->setRightPadding(0, true);
+}
+
+qreal TextEdit::bottomPadding() const
+{
+    Q_D(const TextEdit);
+    if (d->extra.isAllocated() && d->extra->explicitBottomPadding)
+        return d->extra->bottomPadding;
+    return d->padding();
+}
+
+void TextEdit::setBottomPadding(qreal padding)
+{
+    Q_D(TextEdit);
+    d->setBottomPadding(padding);
+}
+
+void TextEdit::resetBottomPadding()
+{
+    Q_D(TextEdit);
+    d->setBottomPadding(0, true);
+}
+
+/*!
+    \qmlmethod QtQuick::TextEdit::clear()
+    \since 5.7
+
+    Clears the contents of the text edit
+    and resets partial text input from an input method.
+
+    Use this method instead of setting the \l text property to an empty string.
+
+    \sa QInputMethod::reset()
+*/
+void TextEdit::clear()
+{
+    Q_D(TextEdit);
+    if (!d->document || !d->control) return;
+
+    d->resetInputMethod();
+    d->control->clear();
+}
+
+
+void TextEditPrivate::implicitWidthChanged()
+{
+    Q_Q(TextEdit);
+    QQuickImplicitSizeItemPrivate::implicitWidthChanged();
+#if (QT_VERSION > QT_VERSION_CHECK(5,7,1))
+    emit q->implicitWidthChanged(); // change for 5.11
+#else
+    emit q->implicitWidthChanged2();
+#endif
+}
+
+void TextEditPrivate::implicitHeightChanged()
+{
+    Q_Q(TextEdit);
+    QQuickImplicitSizeItemPrivate::implicitHeightChanged();
+#if (QT_VERSION > QT_VERSION_CHECK(5,7,1))
+    emit q->implicitHeightChanged(); // change for 5.11
+#else
+    emit q->implicitHeightChanged2();
+#endif
+}
+
+DocumentHandler* TextEdit::documentHandler()
+{
+    Q_D(TextEdit);
+    return d->documentHandler;
+}
+
+void TextEdit::setDocumentHandler(DocumentHandler *dh)
+{
+    Q_D(TextEdit);
+    d->documentHandler = dh;
+    dh->setTextEdit(this);
+}
+
+void TextEdit::linePaletteAdded(int lineStart, int lineEnd, int height, QQuickItem *palette)
+{
+    Q_D(TextEdit);
+    auto startBlock = d->document->findBlockByNumber(lineStart-1);
+    auto endBlock = d->document->findBlockByNumber(lineEnd-1);
+    int startPos = startBlock.position();
+    int endPos = endBlock.position() + endBlock.length();
+
+    d->lineControl->addPalette(lineStart-1,lineEnd - lineStart + 1, palette, startPos, endPos);
+    handleCursorDuringAddingSection();
+
+    d->invalidUntilTheEnd = true;
+    for (int i = lineStart - 1; i < d->document->blockCount(); ++i)
+        invalidateBlock(d->document->findBlockByNumber(i));
+
+    emit paletteChange(lineStart - 1);
+}
+
+void TextEdit::linePaletteRemoved(QQuickItem *palette)
+{
+    Q_D(TextEdit);
+    int result = d->lineControl->removePalette(palette, false);
+
+    if (result == -1) return;
+
+    d->invalidUntilTheEnd = true;
+
+    if (d->document){
+        for (int i = result; i < d->document->blockCount(); ++i)
+        {
+            invalidateBlock(d->document->findBlockByNumber(i));
+        }
+    }
+    emit paletteChange(result);
+}
+
+void TextEdit::linePaletteHeightChanged(QQuickItem *palette, int newHeight)
+{
+    Q_D(TextEdit);
+    // int result = d->paletteManager->resizePalette(palette, newHeight);
+
+    int result = d->lineControl->resizePalette(palette);
+
+    if (result == -1) return;
+    d->invalidUntilTheEnd = true;
+    for (int i = result; i < d->document->blockCount(); ++i)
+    {
+        invalidateBlock(d->document->findBlockByNumber(i));
+    }
+    emit paletteChange(result);
+}
+
+void TextEdit::resetLineControl()
+{
+    Q_D(TextEdit);
+    d->lineControl->reset();
+}
+
+#ifdef LV_EDITOR_DEBUG
+TextEditNodeDebugModel::Entry TextEdit::getDebugEntry(int pos)
+{
+    Q_D(TextEdit);
+    if (!d->document) return TextEditNodeDebugModel::Entry();
+    QString lineText = getDocumentLayout()->lineDocument()->findBlockByNumber(pos).text();
+    QString blockText = d->document->findBlockByNumber(pos).text();
+    bool hiddenByPalette = d->paletteManager->isLineUnderPalette(pos);
+    // bool hiddenByPalette = d->lineControl->hiddenByPalette(pos);
+    bool hiddenByCollapse = getDocumentLayout()->isHiddenByCollapse(pos);
+    // bool hiddenByCollapse = d->lineControl->hiddenByCollapse(pos);
+    int offset = d->paletteManager->drawingOffset(pos, false);
+    // int offset = d->lineControl->drawingOffset(pos, false);
+    return TextEditNodeDebugModel::Entry(pos, lineText, blockText, hiddenByCollapse, hiddenByPalette, offset);
+}
+#endif
+
+void TextEdit::clearSelectionOnFocus(bool value){
+    Q_D(TextEdit);
+    d->control->clearSelectionOnFocus(value);
+}
+
+void TextEdit::setTextDocument(QTextDocument *td)
+{
+    Q_D(TextEdit);
+    if (td)
+    {
+        d->setTextDocument(td);
+    }
+    else d->unsetTextDocument();
+}
+
+TextDocumentLayout *TextEdit::getDocumentLayout()
+{
+    Q_D(TextEdit);
+    return dynamic_cast<TextDocumentLayout*>(d->document->documentLayout());
+}
+
+void TextEdit::manageExpandCollapse(int pos, bool collapsed)
+{
+    Q_D(TextEdit);
+    QTextBlock matchingBlock = d->document->findBlockByNumber(pos);
+    ProjectDocumentBlockData* userData = static_cast<ProjectDocumentBlockData*>(matchingBlock.userData());
+
+    if (collapsed)
+    {
+        int num; QString repl;
+        userData->onCollapse()(matchingBlock, num, repl);
+        userData->setNumOfCollapsedLines(num);
+        userData->setReplacementString(repl);
+        d->lineControl->addCollapse(pos, userData->numOfCollapsedLines());
+
+        handleCursorDuringAddingSection();
+    } else {
+        d->lineControl->removeCollapse(pos);
+    }
+    userData->setStateChangeFlag(true);
+    stateChangeHandler(matchingBlock);
+
+    d->invalidUntilTheEnd = true;
+    for (int i = pos; i < d->document->blockCount(); ++i)
+    {
+        invalidateBlock(d->document->findBlockByNumber(i));
+    }
+}
+
+void TextEdit::updateLineSurface(int oldLineNum, int newLineNum, int dirtyPos)
+{
+    Q_D(TextEdit);
+    if (d->lineSurface) d->lineSurface->triggerUpdate(newLineNum, dirtyPos);
+}
+
+void TextEdit::handleCursorDuringAddingSection()
+{
+    Q_D(TextEdit);
+
+    QTextCursor cursor = d->control->textCursor();
+    int cursorBlock = cursor.block().blockNumber();
+
+    int firstBlock = d->lineControl->firstBlockOfTextBefore(cursorBlock);
+    if (firstBlock != cursorBlock){
+        cursor.beginEditBlock();
+        for (int i = 0; i < cursorBlock-firstBlock; i++)
+        {
+            d->control->moveCursor(QTextCursor::MoveOperation::Up);
+        }
+        cursor.endEditBlock();
+    }
+}
+
+void TextEdit::checkPalettesWhenCollapsed(int pos, int num)
+{
+    /*auto result = getPaletteManager()->deletedOnCollapse(pos, num);
+
+    if (!result.empty())
+    {
+        for (auto it = result.begin(); it != result.end(); ++it)
+        {
+            QMetaObject::invokeMethod(*it, "close", Qt::DirectConnection);
+        }
+    }*/
+}
+
+}
diff --git a/lib/lveditor/3rdparty/textedit_p.h b/lib/lveditor/3rdparty/textedit_p.h
index 79f6f41..5b51b62 100644
--- a/lib/lveditor/3rdparty/textedit_p.h
+++ b/lib/lveditor/3rdparty/textedit_p.h
@@ -1,457 +1,468 @@
-/****************************************************************************
-**
-** Copyright (C) 2016 The Qt Company Ltd.
-** Contact: https://www.qt.io/licensing/
-**
-** This file is part of the QtQuick module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and The Qt Company. For licensing terms
-** and conditions see https://www.qt.io/terms-conditions. For further
-** information use the contact form at https://www.qt.io/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 2.0 or (at your option) the GNU General
-** Public license version 3 or any later version approved by the KDE Free
-** Qt Foundation. The licenses are as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
-** included in the packaging of this file. Please review the following
-** information to ensure the GNU General Public License requirements will
-** be met: https://www.gnu.org/licenses/gpl-2.0.html and
-** https://www.gnu.org/licenses/gpl-3.0.html.
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef LVTEXTEDIT_P_H
-#define LVTEXTEDIT_P_H
-
-
-#include "private/qquickimplicitsizeitem_p.h"
-#include <QtGui/qtextoption.h>
-#include "documenthandler.h"
-#include "qquickpainteditem.h"
-
-class QTextBlock;
-
-namespace lv {
-
-class TextDocumentLayout;
-class TextEditPrivate;
-class PaletteManager;
-class LineManager;
-class LineSurface;
-
-class TextEdit : public QQuickImplicitSizeItem
-{
-    Q_OBJECT
-
-    Q_PROPERTY(QString text READ text WRITE setText NOTIFY textChanged)
-    Q_PROPERTY(QColor color READ color WRITE setColor NOTIFY colorChanged)
-    Q_PROPERTY(QColor selectionColor READ selectionColor WRITE setSelectionColor NOTIFY selectionColorChanged)
-    Q_PROPERTY(QColor selectedTextColor READ selectedTextColor WRITE setSelectedTextColor NOTIFY selectedTextColorChanged)
-    Q_PROPERTY(QFont font READ font WRITE setFont NOTIFY fontChanged)
-    Q_PROPERTY(HAlignment horizontalAlignment READ hAlign WRITE setHAlign RESET resetHAlign NOTIFY horizontalAlignmentChanged)
-    Q_PROPERTY(HAlignment effectiveHorizontalAlignment READ effectiveHAlign NOTIFY effectiveHorizontalAlignmentChanged)
-    Q_PROPERTY(VAlignment verticalAlignment READ vAlign WRITE setVAlign NOTIFY verticalAlignmentChanged)
-    Q_PROPERTY(WrapMode wrapMode READ wrapMode WRITE setWrapMode NOTIFY wrapModeChanged)
-    Q_PROPERTY(int lineCount READ lineCount NOTIFY lineCountChanged)
-    Q_PROPERTY(int length READ length NOTIFY textChanged)
-    Q_PROPERTY(qreal contentWidth READ contentWidth NOTIFY contentSizeChanged)
-    Q_PROPERTY(qreal contentHeight READ contentHeight NOTIFY contentSizeChanged)
-    Q_PROPERTY(qreal paintedWidth READ contentWidth NOTIFY contentSizeChanged)  // Compatibility
-    Q_PROPERTY(qreal paintedHeight READ contentHeight NOTIFY contentSizeChanged)
-    Q_PROPERTY(TextFormat textFormat READ textFormat WRITE setTextFormat NOTIFY textFormatChanged)
-    Q_PROPERTY(bool readOnly READ isReadOnly WRITE setReadOnly NOTIFY readOnlyChanged)
-    Q_PROPERTY(bool cursorVisible READ isCursorVisible WRITE setCursorVisible NOTIFY cursorVisibleChanged)
-    Q_PROPERTY(int cursorPosition READ cursorPosition WRITE setCursorPosition NOTIFY cursorPositionChanged)
-    Q_PROPERTY(QRectF cursorRectangle READ cursorRectangle NOTIFY cursorRectangleChanged)
-    Q_PROPERTY(QQmlComponent* cursorDelegate READ cursorDelegate WRITE setCursorDelegate NOTIFY cursorDelegateChanged)
-    Q_PROPERTY(int selectionStart READ selectionStart NOTIFY selectionStartChanged)
-    Q_PROPERTY(int selectionEnd READ selectionEnd NOTIFY selectionEndChanged)
-    Q_PROPERTY(QString selectedText READ selectedText NOTIFY selectedTextChanged)
-    Q_PROPERTY(bool activeFocusOnPress READ focusOnPress WRITE setFocusOnPress NOTIFY activeFocusOnPressChanged)
-    Q_PROPERTY(bool persistentSelection READ persistentSelection WRITE setPersistentSelection NOTIFY persistentSelectionChanged)
-    Q_PROPERTY(qreal textMargin READ textMargin WRITE setTextMargin NOTIFY textMarginChanged)
-    Q_PROPERTY(Qt::InputMethodHints inputMethodHints READ inputMethodHints WRITE setInputMethodHints NOTIFY inputMethodHintsChanged)
-    Q_PROPERTY(bool selectByKeyboard READ selectByKeyboard WRITE setSelectByKeyboard NOTIFY selectByKeyboardChanged REVISION 1)
-    Q_PROPERTY(bool selectByMouse READ selectByMouse WRITE setSelectByMouse NOTIFY selectByMouseChanged)
-    Q_PROPERTY(SelectionMode mouseSelectionMode READ mouseSelectionMode WRITE setMouseSelectionMode NOTIFY mouseSelectionModeChanged)
-    Q_PROPERTY(bool canPaste READ canPaste NOTIFY canPasteChanged)
-    Q_PROPERTY(bool canUndo READ canUndo NOTIFY canUndoChanged)
-    Q_PROPERTY(bool canRedo READ canRedo NOTIFY canRedoChanged)
-    Q_PROPERTY(bool inputMethodComposing READ isInputMethodComposing NOTIFY inputMethodComposingChanged)
-    Q_PROPERTY(QUrl baseUrl READ baseUrl WRITE setBaseUrl RESET resetBaseUrl NOTIFY baseUrlChanged)
-    Q_PROPERTY(RenderType renderType READ renderType WRITE setRenderType NOTIFY renderTypeChanged)
-    Q_PROPERTY(QString hoveredLink READ hoveredLink NOTIFY linkHovered REVISION 2)
-    Q_PROPERTY(qreal padding READ padding WRITE setPadding RESET resetPadding NOTIFY paddingChanged REVISION 6)
-    Q_PROPERTY(qreal topPadding READ topPadding WRITE setTopPadding RESET resetTopPadding NOTIFY topPaddingChanged REVISION 6)
-    Q_PROPERTY(qreal leftPadding READ leftPadding WRITE setLeftPadding RESET resetLeftPadding NOTIFY leftPaddingChanged REVISION 6)
-    Q_PROPERTY(qreal rightPadding READ rightPadding WRITE setRightPadding RESET resetRightPadding NOTIFY rightPaddingChanged REVISION 6)
-    Q_PROPERTY(qreal bottomPadding READ bottomPadding WRITE setBottomPadding RESET resetBottomPadding NOTIFY bottomPaddingChanged REVISION 6)
-    Q_PROPERTY(QString preeditText READ preeditText NOTIFY preeditTextChanged REVISION 7)
-    Q_PROPERTY(lv::DocumentHandler* documentHandler READ documentHandler WRITE setDocumentHandler NOTIFY documentHandlerChanged)
-    Q_PROPERTY(int fragmentStart READ fragmentStart WRITE setFragmentStart RESET resetFragmentStart NOTIFY fragmentStartChanged)
-    Q_PROPERTY(int fragmentEnd READ fragmentEnd WRITE setFragmentEnd RESET resetFragmentEnd NOTIFY fragmentEndChanged)
-    Q_PROPERTY(int lineNumber READ lineNumber NOTIFY lineNumberChanged)
-    Q_PROPERTY(int columnNumber READ columnNumber NOTIFY columnNumberChanged)
-public:
-    TextEdit(QQuickImplicitSizeItem *parent=nullptr);
-
-    PaletteManager* getPaletteManager();
-    void setLineManager(LineManager* lm);
-    void setLineSurface(LineSurface* ls);
-
-    enum HAlignment {
-        AlignLeft = Qt::AlignLeft,
-        AlignRight = Qt::AlignRight,
-        AlignHCenter = Qt::AlignHCenter,
-        AlignJustify = Qt::AlignJustify
-    };
-    Q_ENUM(HAlignment)
-
-    enum VAlignment {
-        AlignTop = Qt::AlignTop,
-        AlignBottom = Qt::AlignBottom,
-        AlignVCenter = Qt::AlignVCenter
-    };
-    Q_ENUM(VAlignment)
-
-    enum TextFormat {
-        PlainText = Qt::PlainText,
-        RichText = Qt::RichText,
-        AutoText = Qt::AutoText
-    };
-    Q_ENUM(TextFormat)
-
-    enum WrapMode { NoWrap = QTextOption::NoWrap,
-                    WordWrap = QTextOption::WordWrap,
-                    WrapAnywhere = QTextOption::WrapAnywhere,
-                    WrapAtWordBoundaryOrAnywhere = QTextOption::WrapAtWordBoundaryOrAnywhere, // COMPAT
-                    Wrap = QTextOption::WrapAtWordBoundaryOrAnywhere
-                  };
-    Q_ENUM(WrapMode)
-
-    enum SelectionMode {
-        SelectCharacters,
-        SelectWords
-    };
-    Q_ENUM(SelectionMode)
-
-    enum RenderType { QtRendering,
-                      NativeRendering
-                    };
-    Q_ENUM(RenderType)
-
-    QString text() const;
-    void setText(const QString &);
-
-    Q_REVISION(7) QString preeditText() const;
-
-    TextFormat textFormat() const;
-    void setTextFormat(TextFormat format);
-
-    QFont font() const;
-    void setFont(const QFont &font);
-
-    QColor color() const;
-    void setColor(const QColor &c);
-
-    QColor selectionColor() const;
-    void setSelectionColor(const QColor &c);
-
-    QColor selectedTextColor() const;
-    void setSelectedTextColor(const QColor &c);
-
-    HAlignment hAlign() const;
-    void setHAlign(HAlignment align);
-    void resetHAlign();
-    HAlignment effectiveHAlign() const;
-
-    VAlignment vAlign() const;
-    void setVAlign(VAlignment align);
-
-    WrapMode wrapMode() const;
-    void setWrapMode(WrapMode w);
-
-    int lineCount() const;
-
-    int length() const;
-
-    bool isCursorVisible() const;
-    void setCursorVisible(bool on);
-
-    int cursorPosition() const;
-    void setCursorPosition(int pos);
-
-    QQmlComponent* cursorDelegate() const;
-    void setCursorDelegate(QQmlComponent*);
-
-    int selectionStart() const;
-    int selectionEnd() const;
-
-    QString selectedText() const;
-
-    bool focusOnPress() const;
-    void setFocusOnPress(bool on);
-
-    bool persistentSelection() const;
-    void setPersistentSelection(bool on);
-
-    qreal textMargin() const;
-    void setTextMargin(qreal margin);
-
-    Qt::InputMethodHints inputMethodHints() const;
-    void setInputMethodHints(Qt::InputMethodHints hints);
-
-    bool selectByKeyboard() const;
-    void setSelectByKeyboard(bool);
-
-    bool selectByMouse() const;
-    void setSelectByMouse(bool);
-
-    SelectionMode mouseSelectionMode() const;
-    void setMouseSelectionMode(SelectionMode mode);
-
-    bool canPaste() const;
-
-    bool canUndo() const;
-    bool canRedo() const;
-
-    void componentComplete() Q_DECL_OVERRIDE;
-
-    /* FROM EDIT */
-    void setReadOnly(bool);
-    bool isReadOnly() const;
-
-    TextEditPrivate* getPriv() { Q_D(TextEdit); return d; }
-    void stateChangeHandler(const QTextBlock& block);
-
-    QRectF cursorRectangle() const;
-
-    void setTextDocument(QTextDocument* td);
-
-    TextDocumentLayout* getDocumentLayout();
-    void manageExpandCollapse(int pos, bool collapsed);
-    void updateLineSurface(int oldLineNum, int newLineNum, int dirtyPos);
-#ifndef QT_NO_IM
-    QVariant inputMethodQuery(Qt::InputMethodQuery property) const Q_DECL_OVERRIDE;
-    Q_REVISION(4) Q_INVOKABLE QVariant inputMethodQuery(Qt::InputMethodQuery query, QVariant argument) const;
-#endif
-
-    qreal contentWidth() const;
-    qreal contentHeight() const;
-
-    QUrl baseUrl() const;
-    void setBaseUrl(const QUrl &url);
-    void resetBaseUrl();
-
-    Q_INVOKABLE QRectF positionToRectangle(int) const;
-    Q_INVOKABLE int positionAt(qreal x, qreal y) const;
-    Q_INVOKABLE void moveCursorSelection(int pos);
-    Q_INVOKABLE void moveCursorSelection(int pos, SelectionMode mode);
-
-    QRectF boundingRect() const Q_DECL_OVERRIDE;
-    QRectF clipRect() const Q_DECL_OVERRIDE;
-
-    bool isInputMethodComposing() const;
-
-    RenderType renderType() const;
-    void setRenderType(RenderType renderType);
-
-    Q_INVOKABLE QString getText(int start, int end) const;
-    Q_INVOKABLE QString getFormattedText(int start, int end) const;
-
-
-    QString hoveredLink() const;
-
-    Q_REVISION(3) Q_INVOKABLE QString linkAt(qreal x, qreal y) const;
-
-    qreal padding() const;
-    void setPadding(qreal padding);
-    void resetPadding();
-
-    qreal topPadding() const;
-    void setTopPadding(qreal padding);
-    void resetTopPadding();
-
-    qreal leftPadding() const;
-    void setLeftPadding(qreal padding);
-    void resetLeftPadding();
-
-    qreal rightPadding() const;
-    void setRightPadding(qreal padding);
-    void resetRightPadding();
-
-    qreal bottomPadding() const;
-    void setBottomPadding(qreal padding);
-    void resetBottomPadding();
-
-    int fragmentStart() const;
-    void setFragmentStart(int frStart);
-    void resetFragmentStart();
-
-    int fragmentEnd() const;
-    void setFragmentEnd(int frStart);
-    void resetFragmentEnd();
-
-    int lineNumber() const;
-    int columnNumber() const;
-
-    lv::DocumentHandler* documentHandler();
-    void setDocumentHandler(lv::DocumentHandler* dh);
-
-    void linePaletteAdded(int lineStart, int lineEnd, int height, QQuickItem* palette);
-    void linePaletteRemoved(QQuickItem* palette);
-    void linePaletteHeightChanged(QQuickItem* palette, int newHeight);
-Q_SIGNALS:
-
-    void textChanged();
-    Q_REVISION(7) void preeditTextChanged();
-    void contentSizeChanged();
-    void cursorPositionChanged();
-    void cursorRectangleChanged();
-    void selectionStartChanged();
-    void selectionEndChanged();
-    void selectedTextChanged();
-    void colorChanged(const QColor &color);
-    void selectionColorChanged(const QColor &color);
-    void selectedTextColorChanged(const QColor &color);
-    void fontChanged(const QFont &font);
-    void horizontalAlignmentChanged(TextEdit::HAlignment alignment);
-    void verticalAlignmentChanged(TextEdit::VAlignment alignment);
-    void wrapModeChanged();
-    void lineCountChanged();
-    void textFormatChanged(TextEdit::TextFormat textFormat);
-    void readOnlyChanged(bool isReadOnly);
-    void cursorVisibleChanged(bool isCursorVisible);
-    void cursorDelegateChanged();
-    void activeFocusOnPressChanged(bool activeFocusOnPressed);
-    void persistentSelectionChanged(bool isPersistentSelection);
-    void textMarginChanged(qreal textMargin);
-    Q_REVISION(1) void selectByKeyboardChanged(bool selectByKeyboard);
-    void selectByMouseChanged(bool selectByMouse);
-    void mouseSelectionModeChanged(TextEdit::SelectionMode mode);
-    void linkActivated(const QString &link);
-    Q_REVISION(2) void linkHovered(const QString &link);
-    void canPasteChanged();
-    void canUndoChanged();
-    void canRedoChanged();
-    void inputMethodComposingChanged();
-    void effectiveHorizontalAlignmentChanged();
-    void baseUrlChanged();
-    void inputMethodHintsChanged();
-    void renderTypeChanged();
-    void textDocumentChanged();
-    void documentHandlerChanged();
-    Q_REVISION(6) void editingFinished();
-    Q_REVISION(6) void paddingChanged();
-    Q_REVISION(6) void topPaddingChanged();
-    Q_REVISION(6) void leftPaddingChanged();
-    Q_REVISION(6) void rightPaddingChanged();
-    Q_REVISION(6) void bottomPaddingChanged();
-    void stateChangeSignal(int blockNum);
-    void lineNumberChanged();
-    void columnNumberChanged();
-    void fragmentStartChanged();
-    void fragmentEndChanged();
-
-    void paletteChange(int blockNumber);
-public Q_SLOTS:
-    void clearSelectionOnFocus(bool value);
-    void selectAll();
-    void selectWord();
-    void select(int start, int end);
-    void deselect();
-    bool isRightToLeft(int start, int end);
-#ifndef QT_NO_CLIPBOARD
-    void cut();
-    void copy();
-    void paste();
-#endif
-    void undo();
-    void redo();
-    void insert(int position, const QString &text);
-    void remove(int start, int end);
-    Q_REVISION(2) void append(const QString &text);
-    Q_REVISION(7) void clear();
-
-private Q_SLOTS:
-    void q_textChanged();
-    void q_contentsChange(int, int, int);
-    void updateSelection();
-    void moveCursorDelegate();
-    void createCursor();
-    void q_canPasteChanged();
-    void updateWholeDocument();
-    void invalidateBlock(const QTextBlock &block);
-    void updateCursor();
-    void q_updateAlignment();
-    void updateSize();
-    void triggerPreprocess();
-    void highlightingDone(const QRectF &);
-    void handleCursorDuringCollapse(int pos, int num);
-    void checkPalettesWhenCollapsed(int pos, int num);
-private:
-    void markDirtyNodesForRange(int start, int end, int charDelta);
-    void updateTotalLines();
-    void invalidateFontCaches();
-    void updateFragmentVisibility();
-    void updateFragmentBounds(int delta);
-
-protected:
-    TextEdit(TextEditPrivate &dd, QQuickImplicitSizeItem *parent = nullptr);
-
-    void geometryChanged(const QRectF &newGeometry,
-                         const QRectF &oldGeometry) Q_DECL_OVERRIDE;
-
-    bool event(QEvent *) Q_DECL_OVERRIDE;
-    void keyPressEvent(QKeyEvent *) Q_DECL_OVERRIDE;
-    void keyReleaseEvent(QKeyEvent *) Q_DECL_OVERRIDE;
-    void focusInEvent(QFocusEvent *event) Q_DECL_OVERRIDE;
-    void focusOutEvent(QFocusEvent *event) Q_DECL_OVERRIDE;
-
-    void hoverEnterEvent(QHoverEvent *event) Q_DECL_OVERRIDE;
-    void hoverMoveEvent(QHoverEvent *event) Q_DECL_OVERRIDE;
-    void hoverLeaveEvent(QHoverEvent *event) Q_DECL_OVERRIDE;
-
-    // mouse filter?
-    void mousePressEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
-    void mouseReleaseEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
-    void mouseDoubleClickEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
-    void mouseMoveEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
-#ifndef QT_NO_IM
-    void inputMethodEvent(QInputMethodEvent *e) Q_DECL_OVERRIDE;
-#endif
-    QSGNode *updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData *updatePaintNodeData) Q_DECL_OVERRIDE;
-    void updatePolish() Q_DECL_OVERRIDE;
-
-    friend class TextUtil;
-    friend class LineSurface;
-    friend class DocumentHandler;
-    friend class TextControl;
-private:
-    Q_DISABLE_COPY(TextEdit)
-    Q_DECLARE_PRIVATE(TextEdit)
-};
-
-}
-
-QML_DECLARE_TYPE(lv::TextEdit)
-
-
-#endif // LVTEXTEDIT_P_H
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtQuick module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef LVTEXTEDIT_P_H
+#define LVTEXTEDIT_P_H
+
+
+#include "private/qquickimplicitsizeitem_p.h"
+#include <QtGui/qtextoption.h>
+#include "documenthandler.h"
+#include "qquickpainteditem.h"
+#ifdef LV_EDITOR_DEBUG
+#include "texteditnodedebugmodel.h"
+#endif
+
+class QTextBlock;
+
+namespace lv {
+
+class TextDocumentLayout;
+class TextEditPrivate;
+class PaletteManager;
+class LineControl;
+class LineManager;
+class LineSurface;
+
+class TextEdit : public QQuickImplicitSizeItem
+{
+    Q_OBJECT
+
+    Q_PROPERTY(QString text READ text WRITE setText NOTIFY textChanged)
+    Q_PROPERTY(QColor color READ color WRITE setColor NOTIFY colorChanged)
+    Q_PROPERTY(QColor selectionColor READ selectionColor WRITE setSelectionColor NOTIFY selectionColorChanged)
+    Q_PROPERTY(QColor selectedTextColor READ selectedTextColor WRITE setSelectedTextColor NOTIFY selectedTextColorChanged)
+    Q_PROPERTY(QFont font READ font WRITE setFont NOTIFY fontChanged)
+    Q_PROPERTY(HAlignment horizontalAlignment READ hAlign WRITE setHAlign RESET resetHAlign NOTIFY horizontalAlignmentChanged)
+    Q_PROPERTY(HAlignment effectiveHorizontalAlignment READ effectiveHAlign NOTIFY effectiveHorizontalAlignmentChanged)
+    Q_PROPERTY(VAlignment verticalAlignment READ vAlign WRITE setVAlign NOTIFY verticalAlignmentChanged)
+    Q_PROPERTY(WrapMode wrapMode READ wrapMode WRITE setWrapMode NOTIFY wrapModeChanged)
+    Q_PROPERTY(int lineCount READ lineCount NOTIFY lineCountChanged)
+    Q_PROPERTY(int length READ length NOTIFY textChanged)
+    Q_PROPERTY(qreal contentWidth READ contentWidth NOTIFY contentSizeChanged)
+    Q_PROPERTY(qreal contentHeight READ contentHeight NOTIFY contentSizeChanged)
+    Q_PROPERTY(qreal paintedWidth READ contentWidth NOTIFY contentSizeChanged)  // Compatibility
+    Q_PROPERTY(qreal paintedHeight READ contentHeight NOTIFY contentSizeChanged)
+    Q_PROPERTY(TextFormat textFormat READ textFormat WRITE setTextFormat NOTIFY textFormatChanged)
+    Q_PROPERTY(bool readOnly READ isReadOnly WRITE setReadOnly NOTIFY readOnlyChanged)
+    Q_PROPERTY(bool cursorVisible READ isCursorVisible WRITE setCursorVisible NOTIFY cursorVisibleChanged)
+    Q_PROPERTY(int cursorPosition READ cursorPosition WRITE setCursorPosition NOTIFY cursorPositionChanged)
+    Q_PROPERTY(QRectF cursorRectangle READ cursorRectangle NOTIFY cursorRectangleChanged)
+    Q_PROPERTY(QQmlComponent* cursorDelegate READ cursorDelegate WRITE setCursorDelegate NOTIFY cursorDelegateChanged)
+    Q_PROPERTY(int selectionStart READ selectionStart NOTIFY selectionStartChanged)
+    Q_PROPERTY(int selectionEnd READ selectionEnd NOTIFY selectionEndChanged)
+    Q_PROPERTY(QString selectedText READ selectedText NOTIFY selectedTextChanged)
+    Q_PROPERTY(bool activeFocusOnPress READ focusOnPress WRITE setFocusOnPress NOTIFY activeFocusOnPressChanged)
+    Q_PROPERTY(bool persistentSelection READ persistentSelection WRITE setPersistentSelection NOTIFY persistentSelectionChanged)
+    Q_PROPERTY(qreal textMargin READ textMargin WRITE setTextMargin NOTIFY textMarginChanged)
+    Q_PROPERTY(Qt::InputMethodHints inputMethodHints READ inputMethodHints WRITE setInputMethodHints NOTIFY inputMethodHintsChanged)
+    Q_PROPERTY(bool selectByKeyboard READ selectByKeyboard WRITE setSelectByKeyboard NOTIFY selectByKeyboardChanged REVISION 1)
+    Q_PROPERTY(bool selectByMouse READ selectByMouse WRITE setSelectByMouse NOTIFY selectByMouseChanged)
+    Q_PROPERTY(SelectionMode mouseSelectionMode READ mouseSelectionMode WRITE setMouseSelectionMode NOTIFY mouseSelectionModeChanged)
+    Q_PROPERTY(bool canPaste READ canPaste NOTIFY canPasteChanged)
+    Q_PROPERTY(bool canUndo READ canUndo NOTIFY canUndoChanged)
+    Q_PROPERTY(bool canRedo READ canRedo NOTIFY canRedoChanged)
+    Q_PROPERTY(bool inputMethodComposing READ isInputMethodComposing NOTIFY inputMethodComposingChanged)
+    Q_PROPERTY(QUrl baseUrl READ baseUrl WRITE setBaseUrl RESET resetBaseUrl NOTIFY baseUrlChanged)
+    Q_PROPERTY(RenderType renderType READ renderType WRITE setRenderType NOTIFY renderTypeChanged)
+    Q_PROPERTY(QString hoveredLink READ hoveredLink NOTIFY linkHovered REVISION 2)
+    Q_PROPERTY(qreal padding READ padding WRITE setPadding RESET resetPadding NOTIFY paddingChanged REVISION 6)
+    Q_PROPERTY(qreal topPadding READ topPadding WRITE setTopPadding RESET resetTopPadding NOTIFY topPaddingChanged REVISION 6)
+    Q_PROPERTY(qreal leftPadding READ leftPadding WRITE setLeftPadding RESET resetLeftPadding NOTIFY leftPaddingChanged REVISION 6)
+    Q_PROPERTY(qreal rightPadding READ rightPadding WRITE setRightPadding RESET resetRightPadding NOTIFY rightPaddingChanged REVISION 6)
+    Q_PROPERTY(qreal bottomPadding READ bottomPadding WRITE setBottomPadding RESET resetBottomPadding NOTIFY bottomPaddingChanged REVISION 6)
+    Q_PROPERTY(QString preeditText READ preeditText NOTIFY preeditTextChanged REVISION 7)
+    Q_PROPERTY(lv::DocumentHandler* documentHandler READ documentHandler WRITE setDocumentHandler NOTIFY documentHandlerChanged)
+    Q_PROPERTY(int fragmentStart WRITE setFragmentStart RESET resetFragmentStart NOTIFY fragmentStartChanged)
+    Q_PROPERTY(int fragmentEnd WRITE setFragmentEnd RESET resetFragmentEnd NOTIFY fragmentEndChanged)
+    Q_PROPERTY(int lineNumber READ lineNumber NOTIFY lineNumberChanged)
+    Q_PROPERTY(int columnNumber READ columnNumber NOTIFY columnNumberChanged)
+public:
+    TextEdit(QQuickImplicitSizeItem *parent=nullptr, bool test = false);
+
+    PaletteManager* getPaletteManager();
+    LineControl* lineControl();
+    void setLineSurface(LineSurface* ls);
+
+    enum HAlignment {
+        AlignLeft = Qt::AlignLeft,
+        AlignRight = Qt::AlignRight,
+        AlignHCenter = Qt::AlignHCenter,
+        AlignJustify = Qt::AlignJustify
+    };
+    Q_ENUM(HAlignment)
+
+    enum VAlignment {
+        AlignTop = Qt::AlignTop,
+        AlignBottom = Qt::AlignBottom,
+        AlignVCenter = Qt::AlignVCenter
+    };
+    Q_ENUM(VAlignment)
+
+    enum TextFormat {
+        PlainText = Qt::PlainText,
+        RichText = Qt::RichText,
+        AutoText = Qt::AutoText
+    };
+    Q_ENUM(TextFormat)
+
+    enum WrapMode { NoWrap = QTextOption::NoWrap,
+                    WordWrap = QTextOption::WordWrap,
+                    WrapAnywhere = QTextOption::WrapAnywhere,
+                    WrapAtWordBoundaryOrAnywhere = QTextOption::WrapAtWordBoundaryOrAnywhere, // COMPAT
+                    Wrap = QTextOption::WrapAtWordBoundaryOrAnywhere
+                  };
+    Q_ENUM(WrapMode)
+
+    enum SelectionMode {
+        SelectCharacters,
+        SelectWords
+    };
+    Q_ENUM(SelectionMode)
+
+    enum RenderType { QtRendering,
+                      NativeRendering
+                    };
+    Q_ENUM(RenderType)
+
+    QString text() const;
+    void setText(const QString &);
+
+    Q_REVISION(7) QString preeditText() const;
+
+    TextFormat textFormat() const;
+    void setTextFormat(TextFormat format);
+
+    QFont font() const;
+    void setFont(const QFont &font);
+
+    QColor color() const;
+    void setColor(const QColor &c);
+
+    QColor selectionColor() const;
+    void setSelectionColor(const QColor &c);
+
+    QColor selectedTextColor() const;
+    void setSelectedTextColor(const QColor &c);
+
+    HAlignment hAlign() const;
+    void setHAlign(HAlignment align);
+    void resetHAlign();
+    HAlignment effectiveHAlign() const;
+
+    VAlignment vAlign() const;
+    void setVAlign(VAlignment align);
+
+    WrapMode wrapMode() const;
+    void setWrapMode(WrapMode w);
+
+    int lineCount() const;
+
+    int length() const;
+
+    bool isCursorVisible() const;
+    void setCursorVisible(bool on);
+
+    int cursorPosition() const;
+    void setCursorPosition(int pos);
+
+    QQmlComponent* cursorDelegate() const;
+    void setCursorDelegate(QQmlComponent*);
+
+    int selectionStart() const;
+    int selectionEnd() const;
+
+    QString selectedText() const;
+
+    bool focusOnPress() const;
+    void setFocusOnPress(bool on);
+
+    bool persistentSelection() const;
+    void setPersistentSelection(bool on);
+
+    qreal textMargin() const;
+    void setTextMargin(qreal margin);
+
+    Qt::InputMethodHints inputMethodHints() const;
+    void setInputMethodHints(Qt::InputMethodHints hints);
+
+    bool selectByKeyboard() const;
+    void setSelectByKeyboard(bool);
+
+    bool selectByMouse() const;
+    void setSelectByMouse(bool);
+
+    SelectionMode mouseSelectionMode() const;
+    void setMouseSelectionMode(SelectionMode mode);
+
+    bool canPaste() const;
+
+    bool canUndo() const;
+    bool canRedo() const;
+
+    void componentComplete() Q_DECL_OVERRIDE;
+
+    /* FROM EDIT */
+    void setReadOnly(bool);
+    bool isReadOnly() const;
+
+    TextEditPrivate* getPriv() { Q_D(TextEdit); return d; }
+    void stateChangeHandler(const QTextBlock& block);
+
+    QRectF cursorRectangle() const;
+
+    void setTextDocument(QTextDocument* td);
+
+    TextDocumentLayout* getDocumentLayout();
+    void manageExpandCollapse(int pos, bool collapsed);
+    void updateLineSurface(int oldLineNum, int newLineNum, int dirtyPos);
+#ifndef QT_NO_IM
+    QVariant inputMethodQuery(Qt::InputMethodQuery property) const Q_DECL_OVERRIDE;
+    Q_REVISION(4) Q_INVOKABLE QVariant inputMethodQuery(Qt::InputMethodQuery query, QVariant argument) const;
+#endif
+
+    qreal contentWidth() const;
+    qreal contentHeight() const;
+
+    QUrl baseUrl() const;
+    void setBaseUrl(const QUrl &url);
+    void resetBaseUrl();
+
+    Q_INVOKABLE QRectF positionToRectangle(int) const;
+    Q_INVOKABLE int positionAt(qreal x, qreal y) const;
+    Q_INVOKABLE void moveCursorSelection(int pos);
+    Q_INVOKABLE void moveCursorSelection(int pos, SelectionMode mode);
+
+    QRectF boundingRect() const Q_DECL_OVERRIDE;
+    QRectF clipRect() const Q_DECL_OVERRIDE;
+
+    bool isInputMethodComposing() const;
+
+    RenderType renderType() const;
+    void setRenderType(RenderType renderType);
+
+    Q_INVOKABLE QString getText(int start, int end) const;
+    Q_INVOKABLE QString getFormattedText(int start, int end) const;
+
+
+    QString hoveredLink() const;
+
+    Q_REVISION(3) Q_INVOKABLE QString linkAt(qreal x, qreal y) const;
+
+    qreal padding() const;
+    void setPadding(qreal padding);
+    void resetPadding();
+
+    qreal topPadding() const;
+    void setTopPadding(qreal padding);
+    void resetTopPadding();
+
+    qreal leftPadding() const;
+    void setLeftPadding(qreal padding);
+    void resetLeftPadding();
+
+    qreal rightPadding() const;
+    void setRightPadding(qreal padding);
+    void resetRightPadding();
+
+    qreal bottomPadding() const;
+    void setBottomPadding(qreal padding);
+    void resetBottomPadding();
+
+    int fragmentStart() const;
+    void setFragmentStart(int frStart);
+    void resetFragmentStart();
+
+    int fragmentEnd() const;
+    void setFragmentEnd(int frStart);
+    void resetFragmentEnd();
+
+    int lineNumber() const;
+    int columnNumber() const;
+
+    lv::DocumentHandler* documentHandler();
+    void setDocumentHandler(lv::DocumentHandler* dh);
+
+    void linePaletteAdded(int lineStart, int lineEnd, int height, QQuickItem* palette);
+    void linePaletteRemoved(QQuickItem* palette);
+    void linePaletteHeightChanged(QQuickItem* palette, int newHeight);
+
+    void resetLineControl();
+#ifdef LV_EDITOR_DEBUG
+    TextEditNodeDebugModel::Entry getDebugEntry(int pos);
+#endif
+Q_SIGNALS:
+
+    void textChanged();
+    Q_REVISION(7) void preeditTextChanged();
+    void contentSizeChanged();
+    void cursorPositionChanged();
+    void cursorRectangleChanged();
+    void selectionStartChanged();
+    void selectionEndChanged();
+    void selectedTextChanged();
+    void colorChanged(const QColor &color);
+    void selectionColorChanged(const QColor &color);
+    void selectedTextColorChanged(const QColor &color);
+    void fontChanged(const QFont &font);
+    void horizontalAlignmentChanged(TextEdit::HAlignment alignment);
+    void verticalAlignmentChanged(TextEdit::VAlignment alignment);
+    void wrapModeChanged();
+    void lineCountChanged();
+    void textFormatChanged(TextEdit::TextFormat textFormat);
+    void readOnlyChanged(bool isReadOnly);
+    void cursorVisibleChanged(bool isCursorVisible);
+    void cursorDelegateChanged();
+    void activeFocusOnPressChanged(bool activeFocusOnPressed);
+    void persistentSelectionChanged(bool isPersistentSelection);
+    void textMarginChanged(qreal textMargin);
+    Q_REVISION(1) void selectByKeyboardChanged(bool selectByKeyboard);
+    void selectByMouseChanged(bool selectByMouse);
+    void mouseSelectionModeChanged(TextEdit::SelectionMode mode);
+    void linkActivated(const QString &link);
+    Q_REVISION(2) void linkHovered(const QString &link);
+    void canPasteChanged();
+    void canUndoChanged();
+    void canRedoChanged();
+    void inputMethodComposingChanged();
+    void effectiveHorizontalAlignmentChanged();
+    void baseUrlChanged();
+    void inputMethodHintsChanged();
+    void renderTypeChanged();
+    void textDocumentChanged();
+    void documentHandlerChanged();
+    Q_REVISION(6) void editingFinished();
+    Q_REVISION(6) void paddingChanged();
+    Q_REVISION(6) void topPaddingChanged();
+    Q_REVISION(6) void leftPaddingChanged();
+    Q_REVISION(6) void rightPaddingChanged();
+    Q_REVISION(6) void bottomPaddingChanged();
+    void stateChangeSignal(int blockNum);
+    void lineNumberChanged();
+    void columnNumberChanged();
+    void fragmentStartChanged();
+    void fragmentEndChanged();
+
+    void paletteChange(int blockNumber);
+public Q_SLOTS:
+    void clearSelectionOnFocus(bool value);
+    void selectAll();
+    void selectWord();
+    void select(int start, int end);
+    void deselect();
+    bool isRightToLeft(int start, int end);
+#ifndef QT_NO_CLIPBOARD
+    void cut();
+    void copy();
+    void paste();
+#endif
+    void undo();
+    void redo();
+    void insert(int position, const QString &text);
+    void remove(int start, int end);
+    Q_REVISION(2) void append(const QString &text);
+    Q_REVISION(7) void clear();
+
+private Q_SLOTS:
+    void q_textChanged();
+    void q_contentsChange(int, int, int);
+    void updateSelection();
+    void moveCursorDelegate();
+    void createCursor();
+    void q_canPasteChanged();
+    void updateWholeDocument();
+    void invalidateBlock(const QTextBlock &block);
+    void updateCursor();
+    void q_updateAlignment();
+    void updateSize();
+    void triggerPreprocess();
+    void highlightingDone(const QRectF &);
+    void handleCursorDuringAddingSection();
+    void checkPalettesWhenCollapsed(int pos, int num);
+private:
+    void markDirtyNodesForRange(int start, int end, int charDelta);
+    void updateTotalLines();
+    void invalidateFontCaches();
+    void addStartPalette(int frStart);
+    void addEndPalette(int frEnd);
+protected:
+    TextEdit(TextEditPrivate &dd, QQuickImplicitSizeItem *parent = nullptr, bool test = true);
+
+    void geometryChanged(const QRectF &newGeometry,
+                         const QRectF &oldGeometry) Q_DECL_OVERRIDE;
+
+    bool event(QEvent *) Q_DECL_OVERRIDE;
+    void keyPressEvent(QKeyEvent *) Q_DECL_OVERRIDE;
+    void keyReleaseEvent(QKeyEvent *) Q_DECL_OVERRIDE;
+    void focusInEvent(QFocusEvent *event) Q_DECL_OVERRIDE;
+    void focusOutEvent(QFocusEvent *event) Q_DECL_OVERRIDE;
+
+    void hoverEnterEvent(QHoverEvent *event) Q_DECL_OVERRIDE;
+    void hoverMoveEvent(QHoverEvent *event) Q_DECL_OVERRIDE;
+    void hoverLeaveEvent(QHoverEvent *event) Q_DECL_OVERRIDE;
+
+    // mouse filter?
+    void mousePressEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
+    void mouseReleaseEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
+    void mouseDoubleClickEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
+    void mouseMoveEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
+#ifndef QT_NO_IM
+    void inputMethodEvent(QInputMethodEvent *e) Q_DECL_OVERRIDE;
+#endif
+    QSGNode *updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData *updatePaintNodeData) Q_DECL_OVERRIDE;
+    void updatePolish() Q_DECL_OVERRIDE;
+
+    friend class TextUtil;
+    friend class LineSurface;
+    friend class DocumentHandler;
+    friend class TextControl;
+#ifdef LV_EDITOR_DEBUG
+    friend class TextEditNodeDebugModel;
+#endif
+private:
+    Q_DISABLE_COPY(TextEdit)
+    Q_DECLARE_PRIVATE(TextEdit)
+};
+
+}
+
+QML_DECLARE_TYPE(lv::TextEdit)
+
+
+#endif // LVTEXTEDIT_P_H
diff --git a/lib/lveditor/3rdparty/textedit_p_p.h b/lib/lveditor/3rdparty/textedit_p_p.h
index cf9a2ff..9d9f2b3 100644
--- a/lib/lveditor/3rdparty/textedit_p_p.h
+++ b/lib/lveditor/3rdparty/textedit_p_p.h
@@ -1,266 +1,275 @@
-/****************************************************************************
-**
-** Copyright (C) 2016 The Qt Company Ltd.
-** Contact: https://www.qt.io/licensing/
-**
-** This file is part of the QtQuick module of the Qt Toolkit.
-**
-** $QT_BEGIN_LICENSE:LGPL$
-** Commercial License Usage
-** Licensees holding valid commercial Qt licenses may use this file in
-** accordance with the commercial license agreement provided with the
-** Software or, alternatively, in accordance with the terms contained in
-** a written agreement between you and The Qt Company. For licensing terms
-** and conditions see https://www.qt.io/terms-conditions. For further
-** information use the contact form at https://www.qt.io/contact-us.
-**
-** GNU Lesser General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPL3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
-**
-** GNU General Public License Usage
-** Alternatively, this file may be used under the terms of the GNU
-** General Public License version 2.0 or (at your option) the GNU General
-** Public license version 3 or any later version approved by the KDE Free
-** Qt Foundation. The licenses are as published by the Free Software
-** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
-** included in the packaging of this file. Please review the following
-** information to ensure the GNU General Public License requirements will
-** be met: https://www.gnu.org/licenses/gpl-2.0.html and
-** https://www.gnu.org/licenses/gpl-3.0.html.
-**
-** $QT_END_LICENSE$
-**
-****************************************************************************/
-
-#ifndef LVTEXTEDIT_P_P_H
-#define LVTEXTEDIT_P_P_H
-
-#include "textedit_p.h"
-#include "private/qquickimplicitsizeitem_p_p.h"
-#include "private/qquickitem_p.h"
-#include "documenthandler.h"
-#include <QtQml/qqml.h>
-#include <QtCore/qlist.h>
-#include <climits>
-#include "palettemanager.h"
-
-class QTextLayout;
-
-namespace lv {
-
-class PaletteManager;
-class TextControl;
-class TextNode;
-class TextNodeEngine;
-class TextDocumentLayout;
-
-class TextEditPrivate : public QQuickImplicitSizeItemPrivate
-{
-public:
-    Q_DECLARE_PUBLIC(TextEdit)
-
-    typedef TextEdit Public;
-
-    class Node
-    {
-    public:
-        explicit Node(int startPos, TextNode* node)
-            : m_startPos(startPos), m_node(node), m_dirty(false) { }
-        TextNode* textNode() const { return m_node; }
-        void moveStartPos(int delta) { Q_ASSERT(m_startPos + delta > 0); m_startPos += delta; }
-        int startPos() const { return m_startPos; }
-        void setDirty() {
-            m_dirty = true; }
-        bool dirty() const { return m_dirty; }
-
-    private:
-        int m_startPos;
-        TextNode* m_node;
-        bool m_dirty;
-    };
-    typedef QList<Node*>::iterator TextNodeIterator;
-
-    class ExtraData
-    {
-    public:
-        ExtraData();
-
-        qreal padding;
-        qreal topPadding;
-        qreal leftPadding;
-        qreal rightPadding;
-        qreal bottomPadding;
-        bool explicitTopPadding : 1;
-        bool explicitLeftPadding : 1;
-        bool explicitRightPadding : 1;
-        bool explicitBottomPadding : 1;
-        bool implicitResize : 1;
-    };
-    QLazilyAllocated<ExtraData> extra;
-    void implicitWidthChanged() Q_DECL_OVERRIDE;
-    void implicitHeightChanged() Q_DECL_OVERRIDE;
-
-    TextEditPrivate()
-        : readOnly(false), color(QRgb(0xFF000000)), selectionColor(QRgb(0xFF000080)), selectedTextColor(QRgb(0xFFFFFFFF))
-        , textMargin(0.0), xoff(0), yoff(0)
-        , font(sourceFont), documentHandler(nullptr), cursorComponent(nullptr), cursorItem(nullptr), document(nullptr), control(nullptr)
-        , paletteManager(new PaletteManager), lineSurface(nullptr)
-        , lastSelectionStart(0), lastSelectionEnd(0), lineCount(0)
-        , clearSelectionOnFocus(false)
-        , lastHighlightChangeStart(INT_MAX)
-        , lastHighlightChangeEnd(0)
-        , fragmentStart(0)
-        , fragmentEnd(INT_MAX)
-        , dirtyPosition(0), paintedWidth(0), paintedHeight(0)
-        , hAlign(TextEdit::AlignLeft), vAlign(TextEdit::AlignTop)
-        , format(TextEdit::PlainText), wrapMode(TextEdit::NoWrap)
-#if defined(QT_QUICK_DEFAULT_TEXT_RENDER_TYPE)
-        , renderType(LVTextEdit::QT_QUICK_DEFAULT_TEXT_RENDER_TYPE)
-#else
-        , renderType(TextEdit::QtRendering)
-#endif
-        , contentDirection(Qt::LayoutDirectionAuto)
-        , mouseSelectionMode(TextEdit::SelectCharacters)
-#ifndef QT_NO_IM
-        , inputMethodHints(Qt::ImhNone)
-#endif
-        , updateType(UpdatePaintNode)
-        , highlightingInProgress(false)
-        , dirty(false), richText(false), cursorVisible(false), cursorPending(false)
-        , focusOnPress(true), persistentSelection(false), requireImplicitWidth(false)
-        , selectByMouse(false), canPaste(false), canPasteValid(false), hAlignImplicit(true)
-        , textCached(true), inLayout(false), selectByKeyboard(false), selectByKeyboardSet(false)
-        , hadSelection(false), invalidUntilTheEnd(false)
-    {}
-
-    ~TextEditPrivate()
-    {
-        qDeleteAll(textNodeMap);
-    }
-
-
-    static TextEditPrivate *get(TextEdit *item) {
-        return static_cast<TextEditPrivate *>(QObjectPrivate::get(item)); }
-
-    void init();
-    void setTextDocument(QTextDocument* d);
-    void unsetTextDocument();
-    void resetInputMethod();
-    void updateDefaultTextOption();
-    void relayoutDocument();
-    bool determineHorizontalAlignment();
-    bool setHAlign(TextEdit::HAlignment, bool forceAlign = false);
-    void mirrorChange() Q_DECL_OVERRIDE;
-    qreal getImplicitWidth() const Q_DECL_OVERRIDE;
-    Qt::LayoutDirection textDirection(const QString &text) const;
-    bool isLinkHoveredConnected();
-
-    void setNativeCursorEnabled(bool) {}
-    void handleFocusEvent(QFocusEvent *event);
-    void addCurrentTextNodeToRoot(TextNodeEngine *, QSGTransformNode *, TextNode*, TextNodeIterator&, int startPos);
-    TextNode* createTextNode();
-
-#ifndef QT_NO_IM
-    Qt::InputMethodHints effectiveInputMethodHints() const;
-#endif
-
-    inline qreal padding() const { return extra.isAllocated() ? extra->padding : 0.0; }
-    void setTopPadding(qreal value, bool reset = false);
-    void setLeftPadding(qreal value, bool reset = false);
-    void setRightPadding(qreal value, bool reset = false);
-    void setBottomPadding(qreal value, bool reset = false);
-
-    bool isImplicitResizeEnabled() const;
-    void setImplicitResizeEnabled(bool enabled);
-
-    bool readOnly;
-    QColor color;
-    QColor selectionColor;
-    QColor selectedTextColor;
-
-    QSizeF contentSize;
-
-    qreal textMargin;
-    qreal xoff;
-    qreal yoff;
-
-    QString text;
-    QUrl baseUrl;
-    QFont sourceFont;
-    QFont font;
-
-    lv::DocumentHandler* documentHandler;
-
-    QQmlComponent* cursorComponent;
-    QQuickItem* cursorItem;
-    QTextDocument *document;
-    TextControl *control;
-    QList<Node*> textNodeMap;
-
-    PaletteManager *paletteManager;
-    LineSurface* lineSurface;
-
-    int lastSelectionStart;
-    int lastSelectionEnd;
-    int lineCount;
-    bool clearSelectionOnFocus;
-
-    enum UpdateType {
-        UpdateNone,
-        UpdateOnlyPreprocess,
-        UpdatePaintNode
-    };
-
-    int lastHighlightChangeStart;
-    int lastHighlightChangeEnd;
-
-    int fragmentStart;
-    QQuickItem* fragmentStartPalette;
-    int fragmentEnd;
-    QQuickItem* fragmentEndPalette;
-    int dirtyPosition;
-
-    qreal paintedWidth;
-    qreal paintedHeight;
-
-    TextEdit::HAlignment hAlign;
-    TextEdit::VAlignment vAlign;
-    TextEdit::TextFormat format;
-    TextEdit::WrapMode wrapMode;
-    TextEdit::RenderType renderType;
-    Qt::LayoutDirection contentDirection;
-    TextEdit::SelectionMode mouseSelectionMode;
-#ifndef QT_NO_IM
-    Qt::InputMethodHints inputMethodHints;
-#endif
-    UpdateType updateType;
-
-    bool highlightingInProgress;
-
-    bool dirty : 1;
-    bool richText : 1;
-    bool cursorVisible : 1;
-    bool cursorPending : 1;
-    bool focusOnPress : 1;
-    bool persistentSelection : 1;
-    bool requireImplicitWidth:1;
-    bool selectByMouse:1;
-    bool canPaste:1;
-    bool canPasteValid:1;
-    bool hAlignImplicit:1;
-    bool textCached:1;
-    bool inLayout:1;
-    bool selectByKeyboard:1;
-    bool selectByKeyboardSet:1;
-    bool hadSelection : 1;
-    bool invalidUntilTheEnd: 1;
-};
-
-}
-
-#endif // LVTEXTEDIT_P_P_H
+/****************************************************************************
+**
+** Copyright (C) 2016 The Qt Company Ltd.
+** Contact: https://www.qt.io/licensing/
+**
+** This file is part of the QtQuick module of the Qt Toolkit.
+**
+** $QT_BEGIN_LICENSE:LGPL$
+** Commercial License Usage
+** Licensees holding valid commercial Qt licenses may use this file in
+** accordance with the commercial license agreement provided with the
+** Software or, alternatively, in accordance with the terms contained in
+** a written agreement between you and The Qt Company. For licensing terms
+** and conditions see https://www.qt.io/terms-conditions. For further
+** information use the contact form at https://www.qt.io/contact-us.
+**
+** GNU Lesser General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPL3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
+**
+** GNU General Public License Usage
+** Alternatively, this file may be used under the terms of the GNU
+** General Public License version 2.0 or (at your option) the GNU General
+** Public license version 3 or any later version approved by the KDE Free
+** Qt Foundation. The licenses are as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
+** included in the packaging of this file. Please review the following
+** information to ensure the GNU General Public License requirements will
+** be met: https://www.gnu.org/licenses/gpl-2.0.html and
+** https://www.gnu.org/licenses/gpl-3.0.html.
+**
+** $QT_END_LICENSE$
+**
+****************************************************************************/
+
+#ifndef LVTEXTEDIT_P_P_H
+#define LVTEXTEDIT_P_P_H
+
+#include "textedit_p.h"
+#include "private/qquickimplicitsizeitem_p_p.h"
+#include "private/qquickitem_p.h"
+#include "documenthandler.h"
+#include <QtQml/qqml.h>
+#include <QtCore/qlist.h>
+#include <climits>
+#include "palettemanager.h"
+#include "linecontrol.h"
+
+class QTextLayout;
+
+namespace lv {
+
+class PaletteManager;
+class TextControl;
+class TextNode;
+class TextNodeEngine;
+class TextDocumentLayout;
+
+class TextEditPrivate : public QQuickImplicitSizeItemPrivate
+{
+public:
+    Q_DECLARE_PUBLIC(TextEdit)
+
+    typedef TextEdit Public;
+
+    class Node
+    {
+    public:
+        explicit Node(int startPos, TextNode* node)
+            : m_startPos(startPos), m_node(node), m_dirty(false) { }
+        TextNode* textNode() const { return m_node; }
+        void moveStartPos(int delta) { Q_ASSERT(m_startPos + delta > 0); m_startPos += delta; }
+        int startPos() const { return m_startPos; }
+        void setDirty() {
+            m_dirty = true; }
+        bool dirty() const { return m_dirty; }
+
+    private:
+        int m_startPos;
+        TextNode* m_node;
+        bool m_dirty;
+    };
+    typedef QList<Node*>::iterator TextNodeIterator;
+
+    class ExtraData
+    {
+    public:
+        ExtraData();
+
+        qreal padding;
+        qreal topPadding;
+        qreal leftPadding;
+        qreal rightPadding;
+        qreal bottomPadding;
+        bool explicitTopPadding : 1;
+        bool explicitLeftPadding : 1;
+        bool explicitRightPadding : 1;
+        bool explicitBottomPadding : 1;
+        bool implicitResize : 1;
+    };
+    QLazilyAllocated<ExtraData> extra;
+    void implicitWidthChanged() Q_DECL_OVERRIDE;
+    void implicitHeightChanged() Q_DECL_OVERRIDE;
+
+    TextEditPrivate()
+        : readOnly(false), color(QRgb(0xFF000000)), selectionColor(QRgb(0xFF000080)), selectedTextColor(QRgb(0xFFFFFFFF))
+        , textMargin(0.0), xoff(0), yoff(0)
+        , font(sourceFont), documentHandler(nullptr), cursorComponent(nullptr), cursorItem(nullptr), document(nullptr), control(nullptr)
+        /*, paletteManager(new PaletteManager)*/, lineControl(nullptr), lineSurface(nullptr)
+        , lastSelectionStart(0), lastSelectionEnd(0), lineCount(0)
+        , clearSelectionOnFocus(false)
+        , lastHighlightChangeStart(INT_MAX)
+        , lastHighlightChangeEnd(0)
+        , fragmentStartPalette(nullptr)
+        , fragmentEndPalette(nullptr)
+        , fragmentStart(-1), fragmentEnd(-1)
+        , dirtyPosition(0), paintedWidth(0), paintedHeight(0)
+        , hAlign(TextEdit::AlignLeft), vAlign(TextEdit::AlignTop)
+        , format(TextEdit::PlainText), wrapMode(TextEdit::NoWrap)
+#if defined(QT_QUICK_DEFAULT_TEXT_RENDER_TYPE)
+        , renderType(LVTextEdit::QT_QUICK_DEFAULT_TEXT_RENDER_TYPE)
+#else
+        , renderType(TextEdit::QtRendering)
+#endif
+        , contentDirection(Qt::LayoutDirectionAuto)
+        , mouseSelectionMode(TextEdit::SelectCharacters)
+#ifndef QT_NO_IM
+        , inputMethodHints(Qt::ImhNone)
+#endif
+        , updateType(UpdatePaintNode)
+        , highlightingInProgress(false)
+#ifdef LV_EDITOR_DEBUG
+        , debugModel(nullptr)
+        , debugView(nullptr)
+#endif
+        , dirty(false), richText(false), cursorVisible(false), cursorPending(false)
+        , focusOnPress(true), persistentSelection(false), requireImplicitWidth(false)
+        , selectByMouse(false), canPaste(false), canPasteValid(false), hAlignImplicit(true)
+        , textCached(true), inLayout(false), selectByKeyboard(false), selectByKeyboardSet(false)
+        , hadSelection(false), invalidUntilTheEnd(false)
+    {}
+
+    ~TextEditPrivate()
+    {
+        qDeleteAll(textNodeMap);
+    }
+
+
+    static TextEditPrivate *get(TextEdit *item) {
+        return static_cast<TextEditPrivate *>(QObjectPrivate::get(item)); }
+
+    void init();
+    void setTextDocument(QTextDocument* d);
+    void unsetTextDocument();
+    void resetInputMethod();
+    void updateDefaultTextOption();
+    void relayoutDocument();
+    bool determineHorizontalAlignment();
+    bool setHAlign(TextEdit::HAlignment, bool forceAlign = false);
+    void mirrorChange() Q_DECL_OVERRIDE;
+    qreal getImplicitWidth() const Q_DECL_OVERRIDE;
+    Qt::LayoutDirection textDirection(const QString &text) const;
+    bool isLinkHoveredConnected();
+
+    void setNativeCursorEnabled(bool) {}
+    void handleFocusEvent(QFocusEvent *event);
+    void addCurrentTextNodeToRoot(TextNodeEngine *, QSGTransformNode *, TextNode*, TextNodeIterator&, int startPos);
+    TextNode* createTextNode();
+
+#ifndef QT_NO_IM
+    Qt::InputMethodHints effectiveInputMethodHints() const;
+#endif
+
+    inline qreal padding() const { return extra.isAllocated() ? extra->padding : 0.0; }
+    void setTopPadding(qreal value, bool reset = false);
+    void setLeftPadding(qreal value, bool reset = false);
+    void setRightPadding(qreal value, bool reset = false);
+    void setBottomPadding(qreal value, bool reset = false);
+
+    bool isImplicitResizeEnabled() const;
+    void setImplicitResizeEnabled(bool enabled);
+
+    bool readOnly;
+    QColor color;
+    QColor selectionColor;
+    QColor selectedTextColor;
+
+    QSizeF contentSize;
+
+    qreal textMargin;
+    qreal xoff;
+    qreal yoff;
+
+    QString text;
+    QUrl baseUrl;
+    QFont sourceFont;
+    QFont font;
+
+    lv::DocumentHandler* documentHandler;
+
+    QQmlComponent* cursorComponent;
+    QQuickItem* cursorItem;
+    QTextDocument *document;
+    TextControl *control;
+    QList<Node*> textNodeMap;
+
+    PaletteManager *paletteManager;
+    LineControl* lineControl;
+    LineSurface* lineSurface;
+
+    int lastSelectionStart;
+    int lastSelectionEnd;
+    int lineCount;
+    bool clearSelectionOnFocus;
+
+    enum UpdateType {
+        UpdateNone,
+        UpdateOnlyPreprocess,
+        UpdatePaintNode
+    };
+
+    int lastHighlightChangeStart;
+    int lastHighlightChangeEnd;
+
+    QQuickItem* fragmentStartPalette;
+    QQuickItem* fragmentEndPalette;
+    int fragmentStart, fragmentEnd;
+    int dirtyPosition;
+
+    qreal paintedWidth;
+    qreal paintedHeight;
+
+    TextEdit::HAlignment hAlign;
+    TextEdit::VAlignment vAlign;
+    TextEdit::TextFormat format;
+    TextEdit::WrapMode wrapMode;
+    TextEdit::RenderType renderType;
+    Qt::LayoutDirection contentDirection;
+    TextEdit::SelectionMode mouseSelectionMode;
+#ifndef QT_NO_IM
+    Qt::InputMethodHints inputMethodHints;
+#endif
+    UpdateType updateType;
+
+    bool highlightingInProgress;
+#ifdef LV_EDITOR_DEBUG
+    TextEditNodeDebugModel* debugModel;
+    QQuickItem* debugView;
+#endif
+    bool dirty : 1;
+    bool richText : 1;
+    bool cursorVisible : 1;
+    bool cursorPending : 1;
+    bool focusOnPress : 1;
+    bool persistentSelection : 1;
+    bool requireImplicitWidth:1;
+    bool selectByMouse:1;
+    bool canPaste:1;
+    bool canPasteValid:1;
+    bool hAlignImplicit:1;
+    bool textCached:1;
+    bool inLayout:1;
+    bool selectByKeyboard:1;
+    bool selectByKeyboardSet:1;
+    bool hadSelection : 1;
+    bool invalidUntilTheEnd: 1;
+};
+
+}
+
+#endif // LVTEXTEDIT_P_P_H
diff --git a/lib/lveditor/include/live/linecontrol.h b/lib/lveditor/include/live/linecontrol.h
new file mode 100644
index 0000000..5505cd9
--- /dev/null
+++ b/lib/lveditor/include/live/linecontrol.h
@@ -0,0 +1 @@
+#include "../../src/linecontrol.h"
diff --git a/lib/lveditor/include/lveditorheaders.pri b/lib/lveditor/include/lveditorheaders.pri
index aaef66e..1183bcb 100644
--- a/lib/lveditor/include/lveditorheaders.pri
+++ b/lib/lveditor/include/lveditorheaders.pri
@@ -1,20 +1,21 @@
-INCLUDEPATH += $$PWD
-
-HEADERS += \
-    $$PWD/live/project.h \
-    $$PWD/live/projectentry.h \
-    $$PWD/live/projectfile.h \
-    $$PWD/live/projectdocument.h \
-    $$PWD/live/codecompletionmodel.h \
-    $$PWD/live/codecompletionsuggestion.h \
-    $$PWD/live/abstractcodehandler.h \
-    $$PWD/live/projectnavigationmodel.h \
-    $$PWD/live/editorsettings.h \
-    $$PWD/live/documenthandler.h \
-    $$PWD/live/editorsettingscategory.h \
-    $$PWD/live/lveditorglobal.h \
-    $$PWD/live/editorglobalobject.h \
-    $$PWD/live/editorprivate_plugin.h \
-    $$PWD/live/palettecontainer.h \
-    $$PWD/live/palettelist.h \
-    $$PWD/live/codepalette.h
+INCLUDEPATH += $$PWD
+
+HEADERS += \
+    $$PWD/live/project.h \
+    $$PWD/live/projectentry.h \
+    $$PWD/live/projectfile.h \
+    $$PWD/live/projectdocument.h \
+    $$PWD/live/codecompletionmodel.h \
+    $$PWD/live/codecompletionsuggestion.h \
+    $$PWD/live/abstractcodehandler.h \
+    $$PWD/live/projectnavigationmodel.h \
+    $$PWD/live/editorsettings.h \
+    $$PWD/live/documenthandler.h \
+    $$PWD/live/editorsettingscategory.h \
+    $$PWD/live/lveditorglobal.h \
+    $$PWD/live/editorglobalobject.h \
+    $$PWD/live/editorprivate_plugin.h \
+    $$PWD/live/palettecontainer.h \
+    $$PWD/live/palettelist.h \
+    $$PWD/live/codepalette.h \
+    $$PWD/live/linecontrol.h
diff --git a/lib/lveditor/src/abstractcodehandler.h b/lib/lveditor/src/abstractcodehandler.h
index cf08f65..93c8257 100644
--- a/lib/lveditor/src/abstractcodehandler.h
+++ b/lib/lveditor/src/abstractcodehandler.h
@@ -1,69 +1,70 @@
-/****************************************************************************
-**
-** Copyright (C) 2014-2018 Dinu SV.
-** (contact: mail@dinusv.com)
-** This file is part of Live CV Application.
-**
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPLv3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl.html.
-**
-****************************************************************************/
-
-#ifndef LVABSTRACTCODEHANDLER_H
-#define LVABSTRACTCODEHANDLER_H
-
-#include <QObject>
-
-#include "live/lveditorglobal.h"
-#include "live/codecompletionmodel.h"
-#include "live/editorsettingscategory.h"
-
-class QTextDocument;
-class QTextCursor;
-class QTextBlock;
-
-namespace lv{
-
-class ProjectDocument;
-
-class LV_EDITOR_EXPORT AbstractCodeHandler : public QObject{
-
-    Q_OBJECT
-
-public:
-    /**
-     * \brief Indicates what triggers the content change
-     */
-    enum ContentsTrigger{
-        Engine,
-        Silent
-    };
-
-public:
-    explicit AbstractCodeHandler(QObject* parent = 0);
-    virtual ~AbstractCodeHandler();
-
-    virtual void assistCompletion(
-        const QTextCursor& cursor,
-        const QChar& insertion,
-        bool manuallyTriggered,
-        CodeCompletionModel* model,
-        QTextCursor& cursorChange
-    ) = 0;
-
-    virtual void setDocument(ProjectDocument* document) = 0;
-    virtual ContentsTrigger documentContentsChanged(int position, int charsRemoved, int charsAdded) = 0;
-
-    virtual void rehighlightBlock(const QTextBlock &block) = 0;
-
-    virtual QPair<int, int> contextBlock(int position) = 0;
-};
-
-}// namespace
-
-#endif // LVABSTRACTCODEHANDLER_H
+/****************************************************************************
+**
+** Copyright (C) 2014-2018 Dinu SV.
+** (contact: mail@dinusv.com)
+** This file is part of Live CV Application.
+**
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPLv3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl.html.
+**
+****************************************************************************/
+
+#ifndef LVABSTRACTCODEHANDLER_H
+#define LVABSTRACTCODEHANDLER_H
+
+#include <QObject>
+
+#include "live/lveditorglobal.h"
+#include "live/codecompletionmodel.h"
+#include "live/editorsettingscategory.h"
+
+class QTextDocument;
+class QTextCursor;
+class QTextBlock;
+
+namespace lv{
+
+class ProjectDocument;
+
+class LV_EDITOR_EXPORT AbstractCodeHandler : public QObject{
+
+    Q_OBJECT
+
+public:
+    /**
+     * \brief Indicates what triggers the content change
+     */
+    enum ContentsTrigger{
+        Engine,
+        Silent
+    };
+
+public:
+    explicit AbstractCodeHandler(QObject* parent = 0);
+    virtual ~AbstractCodeHandler();
+
+    virtual void assistCompletion(
+        const QTextCursor& cursor,
+        const QChar& insertion,
+        bool manuallyTriggered,
+        CodeCompletionModel* model,
+        QTextCursor& cursorChange
+    ) = 0;
+
+    virtual void setDocument(ProjectDocument* document) = 0;
+    virtual ContentsTrigger documentContentsChanged(int position, int charsRemoved, int charsAdded) = 0;
+
+    virtual void rehighlightBlock(const QTextBlock &block) = 0;
+
+    virtual QPair<int, int> contextBlock(int position) = 0;
+    virtual void aboutToDelete() = 0;
+};
+
+}// namespace
+
+#endif // LVABSTRACTCODEHANDLER_H
diff --git a/lib/lveditor/src/documenthandler.cpp b/lib/lveditor/src/documenthandler.cpp
index d4d8d7f..5389353 100644
--- a/lib/lveditor/src/documenthandler.cpp
+++ b/lib/lveditor/src/documenthandler.cpp
@@ -1,427 +1,428 @@
-/****************************************************************************
-**
-** Copyright (C) 2014-2018 Dinu SV.
-** (contact: mail@dinusv.com)
-** This file is part of Live CV Application.
-**
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPLv3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl.html.
-**
-****************************************************************************/
-
-#include "live/documenthandler.h"
-#include "live/projectdocument.h"
-#include "live/projectfile.h"
-#include "live/codepalette.h"
-#include "live/palettecontainer.h"
-#include "live/editorglobalobject.h"
-#include "live/project.h"
-#include "live/viewengine.h"
-#include "live/visuallog.h"
-#include "live/visuallogqt.h"
-#include "live/palettelist.h"
-#include "live/palettecontainer.h"
-#include "live/extensions.h"
-
-#include <QQmlContext>
-#include <QQmlEngine>
-#include <QTextDocument>
-#include <QTextDocumentFragment>
-#include <QTextCursor>
-#include <QTextBlock>
-#include <QTextList>
-#include <QTimer>
-#include <QFileInfo>
-#include <QJSValue>
-#include <QJSValueList>
-
-#include "textedit_p.h"
-#include "textedit_p_p.h"
-
-/**
- * \class lv::DocumentHandler
- * \brief The go-to class when it comes to handling documents
- * Forwards everything to the highlighter, has a completion model in case there's a specific code handler attached to it,
- * it can auto-complete code, which is all behavior inherited from the AbstractCodeHandler.
- *
- * \ingroup lveditor
- */
-namespace lv{
-
-const QChar DocumentHandler::ParagraphSeparator = QChar(8233);
-const QChar DocumentHandler::NewLine            = QChar('\n');
-
-/**
- * \brief Default constructor of the DocumentHandler
- *
- * Initialized from Editor.qml
- */
-DocumentHandler::DocumentHandler(QObject *parent)
-    : QObject(parent)
-    , m_targetDoc(nullptr)
-    , m_completionModel(new CodeCompletionModel)
-    , m_codeHandler(nullptr)
-    , m_projectDocument(nullptr)
-    , m_indentSize(0)
-    , m_project(nullptr)
-    , m_engine(nullptr)
-    , m_textEdit(nullptr)
-{
-    setIndentSize(4);
-}
-
-/**
- * \brief Default destructor of DocumentHandler
- */
-DocumentHandler::~DocumentHandler(){
-    delete m_codeHandler;
-}
-
-/** Set the target doc */
-void DocumentHandler::setTarget(QTextDocument *target)
-{
-    m_targetDoc = target;
-}
-
-/**
- * \brief TextEdit setter
- *
- * Usually from Editor.qml
- */
-void DocumentHandler::setTextEdit(TextEdit *te){
-    m_textEdit = te;
-    if (m_targetDoc) {
-        te->setTextDocument(m_targetDoc);
-    }
-}
-
-
-/**
- * \fn lv::DocumentHandler::classBegin
- * \brief Implementation of the respective function from QQmlParserStatus
- */
-
-/**
- * \brief Cursor position request signal emitter
- *
- */
-void DocumentHandler::requestCursorPosition(int position){
-    emit cursorPositionRequest(position);
-}
-
-/**
- * \brief Used to add and position the palette inside the editor
- */
-void DocumentHandler::lineBoxAdded(int lineStart, int lineEnd, int height, QQuickItem *box){
-    m_textEdit->linePaletteAdded(lineStart, lineEnd, height, box);
-}
-
-/**
- * \brief Used to remove a specific palette in the editor
- */
-void DocumentHandler::lineBoxRemoved(QQuickItem *palette)
-{
-    m_textEdit->linePaletteRemoved(palette);
-}
-
-/**
- * \brief Used to resize a given palette
- */
-void DocumentHandler::lineBoxResized(QQuickItem *palette, int newHeight)
-{
-    m_textEdit->linePaletteHeightChanged(palette, newHeight);
-}
-
-
-/**
- * \brief Triggers the code handler to call the highlighter on the given block
- */
-void DocumentHandler::rehighlightBlock(const QTextBlock &block){
-    if ( m_codeHandler )
-        m_codeHandler->rehighlightBlock(block);
-}
-
-/**
- * \brief Implementation of the respective function from QQmlParserStatus
- */
-void DocumentHandler::componentComplete(){
-    QQmlContext* ctx = qmlEngine(this)->rootContext();
-    EditorGlobalObject* editor = static_cast<EditorGlobalObject*>(ctx->contextProperty("editor").value<QObject*>());
-    if ( !editor ){
-        qWarning("Failed to find editor global object.");
-        return;
-    }
-
-    m_project = editor->project();
-
-    QObject* lg = ctx->contextProperty("livecv").value<QObject*>();
-    if ( !lg ){
-        qWarning("Failed to find live global object.");
-        return;
-    }
-
-    m_engine     = static_cast<ViewEngine*>(lg->property("engine").value<lv::ViewEngine*>());
-    m_extensions = static_cast<Extensions*>(lg->property("extensions").value<QQmlPropertyMap*>()->parent());
-
-    findCodeHandler();
-}
-
-
-void DocumentHandler::readContent(){
-    m_targetDoc->setPlainText(m_projectDocument->content());
-}
-
-void DocumentHandler::findCodeHandler(){
-
-    if ( m_project && m_engine && m_projectDocument ){
-        vlog("editor-documenthandler").v() << "Looking up language handler for: " << m_projectDocument->file()->path();
-
-        QString fileExtension = QFileInfo(m_projectDocument->file()->path()).suffix();
-
-        QJSValueList interceptorArgs;
-        interceptorArgs << m_engine->engine()->newQObject(m_projectDocument);
-        interceptorArgs << m_engine->engine()->newQObject(this);
-        interceptorArgs << fileExtension;
-        QQmlEngine::setObjectOwnership(m_projectDocument, QQmlEngine::CppOwnership);
-        QQmlEngine::setObjectOwnership(this, QQmlEngine::CppOwnership);
-
-        for ( auto it = m_extensions->begin(); it != m_extensions->end(); ++it ){
-            LiveExtension* le = it.value();
-            if ( le->hasLanguageInterceptor() ){
-                QObject* o = le->callLanguageInterceptor(interceptorArgs);
-
-                AbstractCodeHandler* ach = qobject_cast<AbstractCodeHandler*>(o);
-                if ( ach ){
-                    vlog("editor-documenthandler").v() << "Found in extension: " << le->name();
-
-                    QQmlEngine::setObjectOwnership(ach, QQmlEngine::CppOwnership);
-                    m_codeHandler = ach;
-                    m_codeHandler->setDocument(m_projectDocument);
-
-                    emit codeHandlerChanged();
-
-                    return;
-                }
-            }
-        }
-    }
-}
-
-/**
- * \brief Triggers the rehighlighting of blocks in the section given by the position and length
- */
-void DocumentHandler::rehighlightSection(int position, int length){
-    if ( !m_codeHandler )
-        return;
-
-    QTextBlock bl = m_targetDoc->findBlock(position);
-    int end = position + length;
-    while ( bl.isValid() ){
-        m_codeHandler->rehighlightBlock(bl);
-        if (bl.position() > end )
-            break;
-        bl = bl.next();
-    }
-}
-
-/**
- * \brief Adds specific completion that the user picked between given positions
- */
-void DocumentHandler::insertCompletion(int from, int to, const QString &completion){
-    if ( m_targetDoc ){
-        m_projectDocument->addEditingState(ProjectDocument::Assisted);
-        QTextCursor cursor(m_targetDoc);
-        cursor.beginEditBlock();
-        cursor.setPosition(from);
-        cursor.setPosition(to, QTextCursor::KeepAnchor);
-        cursor.removeSelectedText();
-        cursor.insertText(completion);
-        cursor.endEditBlock();
-        m_completionModel->disable();
-        m_projectDocument->removeEditingState(ProjectDocument::Assisted);
-    }
-}
-
-/**
- * \brief Slot that is connected to document changes
- */
-void DocumentHandler::documentContentsChanged(int position, int charsRemoved, int charsAdded){
-    AbstractCodeHandler::ContentsTrigger cst = AbstractCodeHandler::Engine;
-    if ( m_codeHandler )
-         cst = m_codeHandler->documentContentsChanged(position, charsRemoved, charsAdded);
-
-    if ( !m_projectDocument || m_projectDocument->editingStateIs(ProjectDocument::Read) )
-        return;
-
-    m_lastChar = QChar();
-    if ( !m_projectDocument->editingStateIs(ProjectDocument::Silent) && m_editorFocus ){
-        if ( charsAdded == 1 )
-            m_lastChar = m_targetDoc->characterAt(position);
-
-        if ( cst == AbstractCodeHandler::Engine )
-            emit contentsChangedManually();
-    }
-}
-
-/**
- * \brief Slot reacting to cursor position change
- *
- * Potentially triggers the assisted completion
- */
-void DocumentHandler::cursorWritePositionChanged(QTextCursor cursor){
-    if ( m_codeHandler && m_editorFocus && cursor.position() == m_textEdit->cursorPosition() &&
-         !m_projectDocument->editingStateIs(ProjectDocument::Assisted) &&
-         !m_projectDocument->editingStateIs(ProjectDocument::Silent)
-        )
-    {
-        m_projectDocument->addEditingState(ProjectDocument::Assisted);
-        QTextCursor newCursor;
-        m_codeHandler->assistCompletion(
-            cursor,
-            m_lastChar,
-            false,
-            m_completionModel,
-            newCursor
-        );
-        m_projectDocument->removeEditingState(ProjectDocument::Assisted);
-        if ( !newCursor.isNull() ){
-            emit cursorPositionRequest(newCursor.position());
-        }
-    }
-}
-
-/**
- * \brief Document that the document handler is operating on
- *
- * It's a pre-requisite to set the document in order to have any functionality
- */
-void DocumentHandler::setDocument(ProjectDocument *document, QJSValue){
-    if ( m_projectDocument ){
-        disconnect(m_projectDocument, SIGNAL(formatChanged(int,int)), this, SLOT(documentFormatUpdate(int, int)));
-    }
-
-    m_projectDocument = document;
-    if ( document ){
-        connect(m_projectDocument, SIGNAL(formatChanged(int,int)), this, SLOT(documentFormatUpdate(int, int)));
-    }
-
-    if ( m_codeHandler ){
-        delete m_codeHandler;
-        m_codeHandler = nullptr;
-    }
-
-    if (m_projectDocument) {
-        m_targetDoc = m_projectDocument->textDocument();
-
-        connect(
-            m_targetDoc, SIGNAL(cursorPositionChanged(QTextCursor)),
-            this, SLOT(cursorWritePositionChanged(QTextCursor))
-        );
-
-        if (m_textEdit) {
-            m_textEdit->setTextDocument(m_targetDoc);
-        }
-
-        connect(
-            m_targetDoc, SIGNAL(contentsChange(int,int,int)),
-            this, SLOT(documentContentsChanged(int,int,int))
-        );
-    }
-    else
-    {
-        if (m_textEdit)
-        {
-            m_textEdit->setTextDocument(nullptr);
-        }
-    }
-
-    emit targetChanged();
-
-    findCodeHandler();
-}
-
-/**
- * \brief Slot for changes in document format - triggers a rehighlight
- */
-void DocumentHandler::documentFormatUpdate(int position, int length){
-    rehighlightSection(position, length);
-}
-
-/**
- * \brief Generates code completion at a given cursor position
- */
-void DocumentHandler::generateCompletion(int cursorPosition){
-    if ( m_targetDoc && m_codeHandler ){
-        m_lastChar = QChar();
-        QTextCursor cursor(m_targetDoc);
-        cursor.setPosition(cursorPosition);
-        QTextCursor newCursor;
-        m_codeHandler->assistCompletion(
-            cursor,
-            m_lastChar,
-            true,
-            m_completionModel,
-            newCursor
-        );
-    }
-}
-
-/**
- * \brief Used to manage indentation of selected text
- *
- * When a user presses the Tab button, the whole selected text should move
- */
-void DocumentHandler::manageIndent(int from, int length, bool undo){
-    QTextBlock bl = m_targetDoc->findBlock(from);
-    while ( bl.isValid() ){
-        QTextCursor cs(bl);
-        cs.beginEditBlock();
-        if ( undo ){
-            if ( bl.text().startsWith(m_indentContent) ){
-                cs.setPosition(cs.position() + m_indentSize, QTextCursor::KeepAnchor);
-                cs.removeSelectedText();
-                if ( from >= m_indentSize )
-                    from -= m_indentSize;
-                else {
-                    from = 0;
-                    length = length >= m_indentSize ? length - m_indentSize : 0;
-                }
-            }
-        } else {
-            cs.insertText(m_indentContent);
-            if ( cs.position() > from )
-                length += m_indentSize;
-            else
-                from += m_indentSize;
-        }
-        cs.endEditBlock();
-
-        if ( bl.position() + bl.length() >= from + length)
-            return;
-
-        bl = bl.next();
-    }
-}
-
-/**
- * \brief Finds the boundaries of the code block containing the cursor position
- *
- * Mostly used for fragments
- */
-QJSValue DocumentHandler::contextBlockRange(int cursorPosition){
-    if ( !m_codeHandler || !m_engine )
-        return QJSValue();
-
-    QPair<int, int> v = m_codeHandler->contextBlock(cursorPosition);
-    QJSValue ob = m_engine->engine()->newObject();
-    ob.setProperty("start", m_targetDoc->findBlock(v.first).blockNumber());
-    ob.setProperty("end", m_targetDoc->findBlock(v.second).blockNumber());
-    return ob;
-}
-
-}// namespace
+/****************************************************************************
+**
+** Copyright (C) 2014-2018 Dinu SV.
+** (contact: mail@dinusv.com)
+** This file is part of Live CV Application.
+**
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPLv3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl.html.
+**
+****************************************************************************/
+
+#include "live/documenthandler.h"
+#include "live/projectdocument.h"
+#include "live/projectfile.h"
+#include "live/codepalette.h"
+#include "live/palettecontainer.h"
+#include "live/editorglobalobject.h"
+#include "live/project.h"
+#include "live/viewengine.h"
+#include "live/visuallog.h"
+#include "live/visuallogqt.h"
+#include "live/palettelist.h"
+#include "live/palettecontainer.h"
+#include "live/extensions.h"
+
+#include <QQmlContext>
+#include <QQmlEngine>
+#include <QTextDocument>
+#include <QTextDocumentFragment>
+#include <QTextCursor>
+#include <QTextBlock>
+#include <QTextList>
+#include <QTimer>
+#include <QFileInfo>
+#include <QJSValue>
+#include <QJSValueList>
+
+#include "textedit_p.h"
+#include "textedit_p_p.h"
+
+/**
+ * \class lv::DocumentHandler
+ * \brief The go-to class when it comes to handling documents
+ * Forwards everything to the highlighter, has a completion model in case there's a specific code handler attached to it,
+ * it can auto-complete code, which is all behavior inherited from the AbstractCodeHandler.
+ *
+ * \ingroup lveditor
+ */
+namespace lv{
+
+const QChar DocumentHandler::ParagraphSeparator = QChar(8233);
+const QChar DocumentHandler::NewLine            = QChar('\n');
+
+/**
+ * \brief Default constructor of the DocumentHandler
+ *
+ * Initialized from Editor.qml
+ */
+DocumentHandler::DocumentHandler(QObject *parent)
+    : QObject(parent)
+    , m_targetDoc(nullptr)
+    , m_completionModel(new CodeCompletionModel)
+    , m_codeHandler(nullptr)
+    , m_projectDocument(nullptr)
+    , m_indentSize(0)
+    , m_project(nullptr)
+    , m_engine(nullptr)
+    , m_textEdit(nullptr)
+{
+    setIndentSize(4);
+}
+
+/**
+ * \brief Default destructor of DocumentHandler
+ */
+DocumentHandler::~DocumentHandler(){
+    delete m_codeHandler;
+}
+
+/** Set the target doc */
+void DocumentHandler::setTarget(QTextDocument *target)
+{
+    m_targetDoc = target;
+}
+
+/**
+ * \brief TextEdit setter
+ *
+ * Usually from Editor.qml
+ */
+void DocumentHandler::setTextEdit(TextEdit *te){
+    m_textEdit = te;
+    if (m_targetDoc) {
+        te->setTextDocument(m_targetDoc);
+    }
+}
+
+
+/**
+ * \fn lv::DocumentHandler::classBegin
+ * \brief Implementation of the respective function from QQmlParserStatus
+ */
+
+/**
+ * \brief Cursor position request signal emitter
+ *
+ */
+void DocumentHandler::requestCursorPosition(int position){
+    emit cursorPositionRequest(position);
+}
+
+/**
+ * \brief Used to add and position the palette inside the editor
+ */
+void DocumentHandler::lineBoxAdded(int lineStart, int lineEnd, int height, QQuickItem *box){
+    m_textEdit->linePaletteAdded(lineStart, lineEnd, height, box);
+}
+
+/**
+ * \brief Used to remove a specific palette in the editor
+ */
+void DocumentHandler::lineBoxRemoved(QQuickItem *palette)
+{
+    if (m_textEdit) m_textEdit->linePaletteRemoved(palette);
+}
+
+/**
+ * \brief Used to resize a given palette
+ */
+void DocumentHandler::lineBoxResized(QQuickItem *palette, int newHeight)
+{
+    m_textEdit->linePaletteHeightChanged(palette, newHeight);
+}
+
+
+/**
+ * \brief Triggers the code handler to call the highlighter on the given block
+ */
+void DocumentHandler::rehighlightBlock(const QTextBlock &block){
+    if ( m_codeHandler )
+        m_codeHandler->rehighlightBlock(block);
+}
+
+/**
+ * \brief Implementation of the respective function from QQmlParserStatus
+ */
+void DocumentHandler::componentComplete(){
+    QQmlContext* ctx = qmlEngine(this)->rootContext();
+    EditorGlobalObject* editor = static_cast<EditorGlobalObject*>(ctx->contextProperty("editor").value<QObject*>());
+    if ( !editor ){
+        qWarning("Failed to find editor global object.");
+        return;
+    }
+
+    m_project = editor->project();
+
+    QObject* lg = ctx->contextProperty("livecv").value<QObject*>();
+    if ( !lg ){
+        qWarning("Failed to find live global object.");
+        return;
+    }
+
+    m_engine     = static_cast<ViewEngine*>(lg->property("engine").value<lv::ViewEngine*>());
+    m_extensions = static_cast<Extensions*>(lg->property("extensions").value<QQmlPropertyMap*>()->parent());
+
+    findCodeHandler();
+}
+
+
+void DocumentHandler::readContent(){
+    m_targetDoc->setPlainText(m_projectDocument->content());
+}
+
+void DocumentHandler::findCodeHandler(){
+
+    if ( m_project && m_engine && m_projectDocument ){
+        vlog("editor-documenthandler").v() << "Looking up language handler for: " << m_projectDocument->file()->path();
+
+        QString fileExtension = QFileInfo(m_projectDocument->file()->path()).suffix();
+
+        QJSValueList interceptorArgs;
+        interceptorArgs << m_engine->engine()->newQObject(m_projectDocument);
+        interceptorArgs << m_engine->engine()->newQObject(this);
+        interceptorArgs << fileExtension;
+        QQmlEngine::setObjectOwnership(m_projectDocument, QQmlEngine::CppOwnership);
+        QQmlEngine::setObjectOwnership(this, QQmlEngine::CppOwnership);
+
+        for ( auto it = m_extensions->begin(); it != m_extensions->end(); ++it ){
+            LiveExtension* le = it.value();
+            if ( le->hasLanguageInterceptor() ){
+                QObject* o = le->callLanguageInterceptor(interceptorArgs);
+
+                AbstractCodeHandler* ach = qobject_cast<AbstractCodeHandler*>(o);
+                if ( ach ){
+                    vlog("editor-documenthandler").v() << "Found in extension: " << le->name();
+
+                    QQmlEngine::setObjectOwnership(ach, QQmlEngine::CppOwnership);
+                    m_codeHandler = ach;
+                    m_codeHandler->setDocument(m_projectDocument);
+
+                    emit codeHandlerChanged();
+
+                    return;
+                }
+            }
+        }
+    }
+}
+
+/**
+ * \brief Triggers the rehighlighting of blocks in the section given by the position and length
+ */
+void DocumentHandler::rehighlightSection(int position, int length){
+    if ( !m_codeHandler )
+        return;
+
+    QTextBlock bl = m_targetDoc->findBlock(position);
+    int end = position + length;
+    while ( bl.isValid() ){
+        m_codeHandler->rehighlightBlock(bl);
+        if (bl.position() > end )
+            break;
+        bl = bl.next();
+    }
+}
+
+/**
+ * \brief Adds specific completion that the user picked between given positions
+ */
+void DocumentHandler::insertCompletion(int from, int to, const QString &completion){
+    if ( m_targetDoc ){
+        m_projectDocument->addEditingState(ProjectDocument::Assisted);
+        QTextCursor cursor(m_targetDoc);
+        cursor.beginEditBlock();
+        cursor.setPosition(from);
+        cursor.setPosition(to, QTextCursor::KeepAnchor);
+        cursor.removeSelectedText();
+        cursor.insertText(completion);
+        cursor.endEditBlock();
+        m_completionModel->disable();
+        m_projectDocument->removeEditingState(ProjectDocument::Assisted);
+    }
+}
+
+/**
+ * \brief Slot that is connected to document changes
+ */
+void DocumentHandler::documentContentsChanged(int position, int charsRemoved, int charsAdded){
+    AbstractCodeHandler::ContentsTrigger cst = AbstractCodeHandler::Engine;
+    if ( m_codeHandler )
+         cst = m_codeHandler->documentContentsChanged(position, charsRemoved, charsAdded);
+
+    if ( !m_projectDocument || m_projectDocument->editingStateIs(ProjectDocument::Read) )
+        return;
+
+    m_lastChar = QChar();
+    if ( !m_projectDocument->editingStateIs(ProjectDocument::Silent) && m_editorFocus ){
+        if ( charsAdded == 1 )
+            m_lastChar = m_targetDoc->characterAt(position);
+
+        if ( cst == AbstractCodeHandler::Engine )
+            emit contentsChangedManually();
+    }
+}
+
+/**
+ * \brief Slot reacting to cursor position change
+ *
+ * Potentially triggers the assisted completion
+ */
+void DocumentHandler::cursorWritePositionChanged(QTextCursor cursor){
+    if ( m_codeHandler && m_editorFocus && cursor.position() == m_textEdit->cursorPosition() &&
+         !m_projectDocument->editingStateIs(ProjectDocument::Assisted) &&
+         !m_projectDocument->editingStateIs(ProjectDocument::Silent)
+        )
+    {
+        m_projectDocument->addEditingState(ProjectDocument::Assisted);
+        QTextCursor newCursor;
+        m_codeHandler->assistCompletion(
+            cursor,
+            m_lastChar,
+            false,
+            m_completionModel,
+            newCursor
+        );
+        m_projectDocument->removeEditingState(ProjectDocument::Assisted);
+        if ( !newCursor.isNull() ){
+            emit cursorPositionRequest(newCursor.position());
+        }
+    }
+}
+
+/**
+ * \brief Document that the document handler is operating on
+ *
+ * It's a pre-requisite to set the document in order to have any functionality
+ */
+void DocumentHandler::setDocument(ProjectDocument *document, QJSValue){
+    if ( m_projectDocument ){
+        disconnect(m_projectDocument, SIGNAL(formatChanged(int,int)), this, SLOT(documentFormatUpdate(int, int)));
+    }
+
+    m_projectDocument = document;
+    if ( document ){
+        connect(m_projectDocument, SIGNAL(formatChanged(int,int)), this, SLOT(documentFormatUpdate(int, int)));
+    }
+
+    if ( m_codeHandler ){
+        m_codeHandler->aboutToDelete();
+        delete m_codeHandler;
+        m_codeHandler = nullptr;
+    }
+
+    if (m_projectDocument) {
+        m_targetDoc = m_projectDocument->textDocument();
+
+        connect(
+            m_targetDoc, SIGNAL(cursorPositionChanged(QTextCursor)),
+            this, SLOT(cursorWritePositionChanged(QTextCursor))
+        );
+
+        if (m_textEdit) {
+            m_textEdit->setTextDocument(m_targetDoc);
+        }
+
+        connect(
+            m_targetDoc, SIGNAL(contentsChange(int,int,int)),
+            this, SLOT(documentContentsChanged(int,int,int))
+        );
+    }
+    else
+    {
+        if (m_textEdit)
+        {
+            m_textEdit->setTextDocument(nullptr);
+        }
+    }
+
+    emit targetChanged();
+
+    findCodeHandler();
+}
+
+/**
+ * \brief Slot for changes in document format - triggers a rehighlight
+ */
+void DocumentHandler::documentFormatUpdate(int position, int length){
+    rehighlightSection(position, length);
+}
+
+/**
+ * \brief Generates code completion at a given cursor position
+ */
+void DocumentHandler::generateCompletion(int cursorPosition){
+    if ( m_targetDoc && m_codeHandler ){
+        m_lastChar = QChar();
+        QTextCursor cursor(m_targetDoc);
+        cursor.setPosition(cursorPosition);
+        QTextCursor newCursor;
+        m_codeHandler->assistCompletion(
+            cursor,
+            m_lastChar,
+            true,
+            m_completionModel,
+            newCursor
+        );
+    }
+}
+
+/**
+ * \brief Used to manage indentation of selected text
+ *
+ * When a user presses the Tab button, the whole selected text should move
+ */
+void DocumentHandler::manageIndent(int from, int length, bool undo){
+    QTextBlock bl = m_targetDoc->findBlock(from);
+    while ( bl.isValid() ){
+        QTextCursor cs(bl);
+        cs.beginEditBlock();
+        if ( undo ){
+            if ( bl.text().startsWith(m_indentContent) ){
+                cs.setPosition(cs.position() + m_indentSize, QTextCursor::KeepAnchor);
+                cs.removeSelectedText();
+                if ( from >= m_indentSize )
+                    from -= m_indentSize;
+                else {
+                    from = 0;
+                    length = length >= m_indentSize ? length - m_indentSize : 0;
+                }
+            }
+        } else {
+            cs.insertText(m_indentContent);
+            if ( cs.position() > from )
+                length += m_indentSize;
+            else
+                from += m_indentSize;
+        }
+        cs.endEditBlock();
+
+        if ( bl.position() + bl.length() >= from + length)
+            return;
+
+        bl = bl.next();
+    }
+}
+
+/**
+ * \brief Finds the boundaries of the code block containing the cursor position
+ *
+ * Mostly used for fragments
+ */
+QJSValue DocumentHandler::contextBlockRange(int cursorPosition){
+    if ( !m_codeHandler || !m_engine )
+        return QJSValue();
+
+    QPair<int, int> v = m_codeHandler->contextBlock(cursorPosition);
+    QJSValue ob = m_engine->engine()->newObject();
+    ob.setProperty("start", m_targetDoc->findBlock(v.first).blockNumber());
+    ob.setProperty("end", m_targetDoc->findBlock(v.second).blockNumber());
+    return ob;
+}
+
+}// namespace
diff --git a/lib/lveditor/src/editorprivate_plugin.cpp b/lib/lveditor/src/editorprivate_plugin.cpp
index c2feb06..10bdaf8 100644
--- a/lib/lveditor/src/editorprivate_plugin.cpp
+++ b/lib/lveditor/src/editorprivate_plugin.cpp
@@ -1,108 +1,106 @@
-/****************************************************************************
-**
-** Copyright (C) 2014-2018 Dinu SV.
-** (contact: mail@dinusv.com)
-** This file is part of Live CV Application.
-**
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPLv3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl.html.
-**
-****************************************************************************/
-
-#include "editorprivate_plugin.h"
-#include "live/applicationcontext.h"
-#include "live/settings.h"
-#include "live/documenthandler.h"
-#include "projectfilemodel.h"
-#include "live/projectdocumentmodel.h"
-#include "projectnavigationmodel.h"
-#include "live/project.h"
-#include "live/projectentry.h"
-#include "live/projectfile.h"
-#include "live/projectdocument.h"
-#include "live/editorsettings.h"
-#include "live/palettecontainer.h"
-#include "live/editorglobalobject.h"
-#include "live/applicationcontext.h"
-#include "live/keymap.h"
-#include "live/viewcontext.h"
-#include "linesurface.h"
-#include "linemanager.h"
-
-#include <QCoreApplication>
-#include <QQmlEngine>
-#include <QQmlContext>
-
-void EditorPrivatePlugin::registerTypes(const char *uri){
-    qmlRegisterType<lv::TextEdit>(          uri, 1, 0, "NewTextEdit");
-    qmlRegisterType<lv::LineSurface>(       uri, 1, 0, "LineSurface");
-    qmlRegisterType<lv::LineManager>(       uri, 1, 0, "LineManager");
-
-    qmlRegisterUncreatableType<lv::ProjectFileModel>(
-        uri, 1, 0, "ProjectFileModel", "Cannot create a ProjectFileModel instance.");
-    qmlRegisterUncreatableType<lv::ProjectDocumentModel>(
-        uri, 1, 0, "ProjectDocumentModel", "Cannot create a ProjectDocumentModel instance.");
-    qmlRegisterUncreatableType<lv::ProjectNavigationModel>(
-        uri, 1, 0, "ProjectNavigationModel", "Cannot create a ProjectNavigationModel instance.");
-
-    qmlRegisterUncreatableType<lv::ProjectEntry>(
-        uri, 1, 0, "ProjectEntry", "ProjectEntry objects are managed by the ProjectFileModel.");
-    qmlRegisterUncreatableType<lv::ProjectFile>(
-        uri, 1, 0, "ProjectFile", "ProjectFile objects are managed by the ProjectFileModel.");
-    qmlRegisterUncreatableType<lv::ProjectDocument>(
-        uri, 1, 0, "ProjectDocument", "ProjectDocument objects are managed by the Project class.");
-    qmlRegisterUncreatableType<lv::EditorSettings>(
-        uri, 1, 0, "EditorSettings", "EditorSettings is available through the \'livecv.settings.editor\' property."
-    );
-}
-
-void EditorPrivatePlugin::initializeEngine(QQmlEngine *engine, const char *){
-    lv::ViewContext::initFromEngine(engine);
-
-    lv::EditorSettings* editorSettings = new lv::EditorSettings(
-        lv::ViewContext::instance().settings()->path() + "/editor.json"
-    );
-    lv::ViewContext::instance().settings()->addConfigFile("editor", editorSettings);
-
-    QObject* prob = engine->rootContext()->contextProperty("project").value<QObject*>();
-    lv::Project* pr = qobject_cast<lv::Project*>(prob);
-
-    lv::PaletteContainer* lpc = lv::PaletteContainer::create(
-        engine, QString::fromStdString(lv::ApplicationContext::instance().pluginPath())
-    );
-
-    lv::EditorGlobalObject* editor = new lv::EditorGlobalObject(pr, lpc);
-
-    engine->rootContext()->setContextProperty("editor", editor);
-
-    QObject* livecv    = engine->rootContext()->contextProperty("livecv").value<QObject*>();
-    if ( livecv ){
-        lv::KeyMap* keymap = static_cast<lv::KeyMap*>(livecv->property("keymap").value<QObject*>());
-        keymap->store(0, Qt::Key_O,           lv::KeyMap::CONTROL_OR_COMMAND, "window.project.openFile");
-        keymap->store(0, Qt::Key_S,           lv::KeyMap::CONTROL_OR_COMMAND, "window.editor.saveFile");
-        keymap->store(0, Qt::Key_S,           lv::KeyMap::CONTROL_OR_COMMAND | lv::KeyMap::Alt, "window.editor.saveFileAs");
-        keymap->store(0, Qt::Key_W,           lv::KeyMap::CONTROL_OR_COMMAND, "window.editor.closeFile");
-
-        keymap->store(0, Qt::Key_Backslash,   lv::KeyMap::CONTROL_OR_COMMAND, "window.project.toggleVisibility");
-        keymap->store(0, Qt::Key_T,           lv::KeyMap::CONTROL_OR_COMMAND, "window.toggleMaximizedRuntime");
-        keymap->store(0, Qt::Key_E,           lv::KeyMap::CONTROL_OR_COMMAND, "window.editor.toggleSize");
-        keymap->store(0, Qt::Key_K,           lv::KeyMap::CONTROL_OR_COMMAND, "window.toggleNavigation");
-        keymap->store(0, Qt::Key_L,           lv::KeyMap::CONTROL_OR_COMMAND, "window.toggleLog");
-        keymap->store(0, Qt::Key_BraceLeft,   lv::KeyMap::CONTROL_OR_COMMAND | lv::KeyMap::Shift, "window.addHorizontalEditorView");
-        keymap->store(0, Qt::Key_BracketLeft, lv::KeyMap::CONTROL_OR_COMMAND | lv::KeyMap::Shift, "window.addHorizontalEditorView");
-        keymap->store(0, Qt::Key_BraceLeft,   lv::KeyMap::CONTROL_OR_COMMAND | lv::KeyMap::Alt,   "window.addHorizontalFragmentEditorView");
-        keymap->store(0, Qt::Key_BracketLeft, lv::KeyMap::CONTROL_OR_COMMAND | lv::KeyMap::Alt,   "window.addHorizontalFragmentEditorView");
-        keymap->store(0, Qt::Key_BraceRight,  lv::KeyMap::CONTROL_OR_COMMAND | lv::KeyMap::Shift, "window.removeHorizontalEditorView");
-        keymap->store(0, Qt::Key_BracketRight,lv::KeyMap::CONTROL_OR_COMMAND | lv::KeyMap::Shift, "window.removeHorizontalEditorView");
-
-        keymap->store(lv::KeyMap::Linux,    Qt::Key_Space, lv::KeyMap::Control, "window.editor.assistCompletion");
-        keymap->store(lv::KeyMap::Windows,  Qt::Key_Space, lv::KeyMap::Control, "window.editor.assistCompletion");
-        keymap->store(lv::KeyMap::Mac,      Qt::Key_Space, lv::KeyMap::Alt,     "window.editor.assistCompletion");
-    }
-
-}
+/****************************************************************************
+**
+** Copyright (C) 2014-2018 Dinu SV.
+** (contact: mail@dinusv.com)
+** This file is part of Live CV Application.
+**
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPLv3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl.html.
+**
+****************************************************************************/
+
+#include "editorprivate_plugin.h"
+#include "live/applicationcontext.h"
+#include "live/settings.h"
+#include "live/documenthandler.h"
+#include "projectfilemodel.h"
+#include "live/projectdocumentmodel.h"
+#include "projectnavigationmodel.h"
+#include "live/project.h"
+#include "live/projectentry.h"
+#include "live/projectfile.h"
+#include "live/projectdocument.h"
+#include "live/editorsettings.h"
+#include "live/palettecontainer.h"
+#include "live/editorglobalobject.h"
+#include "live/applicationcontext.h"
+#include "live/keymap.h"
+#include "live/viewcontext.h"
+#include "linesurface.h"
+
+#include <QCoreApplication>
+#include <QQmlEngine>
+#include <QQmlContext>
+
+void EditorPrivatePlugin::registerTypes(const char *uri){
+    qmlRegisterType<lv::TextEdit>(          uri, 1, 0, "NewTextEdit");
+    qmlRegisterType<lv::LineSurface>(       uri, 1, 0, "LineSurface");
+
+    qmlRegisterUncreatableType<lv::ProjectFileModel>(
+        uri, 1, 0, "ProjectFileModel", "Cannot create a ProjectFileModel instance.");
+    qmlRegisterUncreatableType<lv::ProjectDocumentModel>(
+        uri, 1, 0, "ProjectDocumentModel", "Cannot create a ProjectDocumentModel instance.");
+    qmlRegisterUncreatableType<lv::ProjectNavigationModel>(
+        uri, 1, 0, "ProjectNavigationModel", "Cannot create a ProjectNavigationModel instance.");
+
+    qmlRegisterUncreatableType<lv::ProjectEntry>(
+        uri, 1, 0, "ProjectEntry", "ProjectEntry objects are managed by the ProjectFileModel.");
+    qmlRegisterUncreatableType<lv::ProjectFile>(
+        uri, 1, 0, "ProjectFile", "ProjectFile objects are managed by the ProjectFileModel.");
+    qmlRegisterUncreatableType<lv::ProjectDocument>(
+        uri, 1, 0, "ProjectDocument", "ProjectDocument objects are managed by the Project class.");
+    qmlRegisterUncreatableType<lv::EditorSettings>(
+        uri, 1, 0, "EditorSettings", "EditorSettings is available through the \'livecv.settings.editor\' property."
+    );
+}
+
+void EditorPrivatePlugin::initializeEngine(QQmlEngine *engine, const char *){
+    lv::ViewContext::initFromEngine(engine);
+
+    lv::EditorSettings* editorSettings = new lv::EditorSettings(
+        lv::ViewContext::instance().settings()->path() + "/editor.json"
+    );
+    lv::ViewContext::instance().settings()->addConfigFile("editor", editorSettings);
+
+    QObject* prob = engine->rootContext()->contextProperty("project").value<QObject*>();
+    lv::Project* pr = qobject_cast<lv::Project*>(prob);
+
+    lv::PaletteContainer* lpc = lv::PaletteContainer::create(
+        engine, QString::fromStdString(lv::ApplicationContext::instance().pluginPath())
+    );
+
+    lv::EditorGlobalObject* editor = new lv::EditorGlobalObject(pr, lpc);
+
+    engine->rootContext()->setContextProperty("editor", editor);
+
+    QObject* livecv    = engine->rootContext()->contextProperty("livecv").value<QObject*>();
+    if ( livecv ){
+        lv::KeyMap* keymap = static_cast<lv::KeyMap*>(livecv->property("keymap").value<QObject*>());
+        keymap->store(0, Qt::Key_O,           lv::KeyMap::CONTROL_OR_COMMAND, "window.project.openFile");
+        keymap->store(0, Qt::Key_S,           lv::KeyMap::CONTROL_OR_COMMAND, "window.editor.saveFile");
+        keymap->store(0, Qt::Key_S,           lv::KeyMap::CONTROL_OR_COMMAND | lv::KeyMap::Alt, "window.editor.saveFileAs");
+        keymap->store(0, Qt::Key_W,           lv::KeyMap::CONTROL_OR_COMMAND, "window.editor.closeFile");
+
+        keymap->store(0, Qt::Key_Backslash,   lv::KeyMap::CONTROL_OR_COMMAND, "window.project.toggleVisibility");
+        keymap->store(0, Qt::Key_T,           lv::KeyMap::CONTROL_OR_COMMAND, "window.toggleMaximizedRuntime");
+        keymap->store(0, Qt::Key_E,           lv::KeyMap::CONTROL_OR_COMMAND, "window.editor.toggleSize");
+        keymap->store(0, Qt::Key_K,           lv::KeyMap::CONTROL_OR_COMMAND, "window.toggleNavigation");
+        keymap->store(0, Qt::Key_L,           lv::KeyMap::CONTROL_OR_COMMAND, "window.toggleLog");
+        keymap->store(0, Qt::Key_BraceLeft,   lv::KeyMap::CONTROL_OR_COMMAND | lv::KeyMap::Shift, "window.addHorizontalEditorView");
+        keymap->store(0, Qt::Key_BracketLeft, lv::KeyMap::CONTROL_OR_COMMAND | lv::KeyMap::Shift, "window.addHorizontalEditorView");
+        keymap->store(0, Qt::Key_BraceLeft,   lv::KeyMap::CONTROL_OR_COMMAND | lv::KeyMap::Alt,   "window.addHorizontalFragmentEditorView");
+        keymap->store(0, Qt::Key_BracketLeft, lv::KeyMap::CONTROL_OR_COMMAND | lv::KeyMap::Alt,   "window.addHorizontalFragmentEditorView");
+        keymap->store(0, Qt::Key_BraceRight,  lv::KeyMap::CONTROL_OR_COMMAND | lv::KeyMap::Shift, "window.removeHorizontalEditorView");
+        keymap->store(0, Qt::Key_BracketRight,lv::KeyMap::CONTROL_OR_COMMAND | lv::KeyMap::Shift, "window.removeHorizontalEditorView");
+
+        keymap->store(lv::KeyMap::Linux,    Qt::Key_Space, lv::KeyMap::Control, "window.editor.assistCompletion");
+        keymap->store(lv::KeyMap::Windows,  Qt::Key_Space, lv::KeyMap::Control, "window.editor.assistCompletion");
+        keymap->store(lv::KeyMap::Mac,      Qt::Key_Space, lv::KeyMap::Alt,     "window.editor.assistCompletion");
+    }
+
+}
diff --git a/lib/lveditor/src/linecontrol.cpp b/lib/lveditor/src/linecontrol.cpp
new file mode 100644
index 0000000..4d13229
--- /dev/null
+++ b/lib/lveditor/src/linecontrol.cpp
@@ -0,0 +1,747 @@
+#include "linecontrol.h"
+#include "qmath.h"
+#include "textedit_p.h"
+#include <QQmlProperty>
+#include <queue>
+
+namespace lv {
+
+std::function<bool(LineControl::LineSection, LineControl::LineSection)>
+    LineControl::LineSection::compare = [](LineSection a, LineSection b)->bool {
+        return a.position < b.position;
+    };
+
+std::function<bool(LineControl::LineSection, LineControl::LineSection)>
+    LineControl::LineSection::compareVisible = [](LineSection a, LineSection b)->bool {
+        return a.visiblePosition < b.visiblePosition;
+    };
+
+std::function<bool(LineControl::LineSection, LineControl::LineSection)>
+    LineControl::LineSection::compareBounds = [](LineSection a, LineSection b)->bool {
+        return a.startPos < b.startPos;
+    };
+
+LineControl::LineControl(QObject *parent) :
+          QObject(parent)
+        , m_dirtyPos(0)
+        , m_prevLineNumber(0)
+        , m_lineNumber(0)
+        , m_totalOffset(0)
+        , m_lineDocument(new QTextDocument(this))
+{
+    if (!parent) m_textEdit = new TextEdit(nullptr, true);
+    else m_textEdit = static_cast<TextEdit*>(parent);
+
+    QObject::connect(m_textEdit, &TextEdit::lineCountChanged, this, &LineControl::lineNumberChange);
+}
+
+void LineControl::addCollapse(int pos, int num)
+{
+    LineSection ls(pos, num + 1, 1, LineSection::Collapsed);
+
+    if (m_textEdit &&
+        m_textEdit->documentHandler() &&
+        m_textEdit->documentHandler()->target()){
+
+        auto doc = m_textEdit->documentHandler()->target();
+
+        ls.startPos = doc->findBlockByNumber(pos).position();
+        ls.endPos = doc->findBlockByNumber(pos + num).position() + doc->findBlockByNumber(pos + num).length();
+
+    }
+
+    addLineSection(ls);
+}
+
+void LineControl::removeCollapse(int pos)
+{
+    removeLineSection(LineSection(pos, 0, 0, LineSection::Collapsed), false);
+}
+
+
+void LineControl::addPalette(int pos, int span, QQuickItem *p, int startPos, int endPos)
+{   
+    LineSection ls;
+    ls.position = pos;
+    ls.range = span;
+    ls.type = static_cast<int>(p->height()) == 0 ? LineSection::Fragment : LineSection::Palette;
+    ls.palette = p;
+    ls.visibleRange = qCeil((p->height() > 0 ? p->height() + 10 : 0)*1.0/ m_blockHeight);
+
+    ls.startPos = startPos;
+    ls.endPos = endPos;
+
+    addLineSection(ls);
+}
+
+int LineControl::resizePalette(QQuickItem *p)
+{
+    auto it = m_sections.begin();
+    for (; it != m_sections.end(); ++it)
+        if (it->type == LineSection::Palette && it->palette == p) break;
+
+    if (it == m_sections.end()) return -1;
+
+    int newVisibleRange = qCeil((p->height() > 0 ? p->height() + 10 : 0)*1.0/ m_blockHeight);
+    if (newVisibleRange != it->visibleRange)
+    {
+        unsigned index = static_cast<unsigned>(it - m_sections.begin());
+        offsetAfterIndex(index, newVisibleRange - it->visibleRange, false);
+        it->visibleRange = newVisibleRange;
+        m_totalOffset += newVisibleRange - it->visibleRange;
+    }
+
+    return it->position;
+}
+
+int LineControl::removePalette(QQuickItem *p, bool destroy)
+{
+    unsigned i = 0;
+    for (; i < m_sections.size(); ++i)
+        if (m_sections[i].type == LineSection::Palette
+         && m_sections[i].palette == p)
+            break;
+
+    if (i == m_sections.size()) return -1;
+    int result = m_sections[i].position;
+
+    removeLineSection(m_sections[i], destroy);
+    return result;
+}
+
+void LineControl::setBlockHeight(int bh)
+{
+    m_blockHeight = bh;
+
+    for (unsigned i = 0; i < m_sections.size(); ++i)
+    {
+        if (m_sections[i].type == LineSection::Collapsed) continue;
+
+        int newVisibleRange = qCeil((m_sections[i].palette->height() > 0 ? m_sections[i].palette->height() + 10 : 0)*1.0/ m_blockHeight);
+        if (newVisibleRange != m_sections[i].visibleRange)
+        {
+            offsetAfterIndex(i, newVisibleRange - m_sections[i].visibleRange, false);
+            m_sections[i].visibleRange = newVisibleRange;
+            m_totalOffset += newVisibleRange - m_sections[i].visibleRange;
+        }
+    }
+
+    m_dirtyPos = 0;
+    updateLinesInDocuments();
+}
+
+void LineControl::reset()
+{
+    m_prevLineNumber = m_lineNumber;
+    m_lineNumber = 0;
+    m_dirtyPos = -1;
+    linesRemoved();
+    m_sections.clear();
+}
+
+std::vector<LineControl::LineSection> LineControl::sections()
+{
+    return m_sections;
+}
+
+void LineControl::updateSectionBounds(int pos, int removed, int added)
+{
+    std::list<LineSection> deleted;
+    if (m_sections.empty()) return;
+    LineSection search;
+    search.startPos = pos;
+    auto lower = std::lower_bound(m_sections.begin(), m_sections.end(), search, LineControl::LineSection::compareBounds);
+
+    for (unsigned i = lower-m_sections.begin(); i != m_sections.size(); ++i) {
+
+        bool toBeRemoved = pos <= m_sections[i].startPos && m_sections[i].startPos <= pos + removed;
+        toBeRemoved = toBeRemoved || (pos <= m_sections[i].endPos && m_sections[i].endPos <= pos + removed);
+        toBeRemoved = toBeRemoved && (removed > 0);
+
+        if (toBeRemoved) deleted.push_back(m_sections[i]);
+        else {
+            m_sections[i].startPos += added - removed;
+            m_sections[i].endPos += added - removed;
+        }
+    }
+
+    for (LineSection ls: deleted)
+        removeLineSection(ls, true);
+}
+
+int LineControl::drawingOffset(int blockNumber, bool forCursor)
+{
+    int offset = 0;
+    auto upper = std::upper_bound(m_sections.begin(), m_sections.end(),
+        LineSection(blockNumber, 0, 0, LineSection::Collapsed), LineSection::compare);
+    if (upper != m_sections.begin() && !m_sections.empty())
+    {
+        auto prev = std::prev(upper);
+
+        if (prev->type == LineSection::Collapsed && blockNumber == prev->position)
+        {
+            offset = prev->positionOffset();
+        }
+        else
+        if (blockNumber < prev->position + prev->range && !forCursor)
+        {
+            offset = -blockNumber - 2;
+        } else
+        if (blockNumber >= prev->position + prev->range)
+        {
+            offset = prev->positionOffset() + prev->rangeOffset();
+        }
+    }
+    return offset * m_blockHeight;
+}
+
+int LineControl::positionOffset(int y)
+{
+    int visibleBlockClicked = y / m_blockHeight;
+    int resultBlock = visibleBlockClicked;
+
+    LineSection search;
+    search.visiblePosition = visibleBlockClicked;
+
+    auto upper = std::upper_bound(m_sections.begin(), m_sections.end(),
+        search, LineSection::compareVisible);
+
+    if (upper != m_sections.begin() && !m_sections.empty()) {
+        auto prev = std::prev(upper);
+        if (visibleBlockClicked >= prev->visiblePosition + prev->visibleRange)
+        {
+            resultBlock = visibleBlockClicked - prev->positionOffset() - prev->rangeOffset();
+        }
+        else if (prev->type == LineSection::Collapsed && visibleBlockClicked == prev->visiblePosition)
+        {
+            resultBlock = prev->position;
+        } else
+        {
+            resultBlock = prev->position - 1;
+        }
+    }
+
+    return resultBlock * m_blockHeight + m_blockHeight / 2;
+}
+
+int LineControl::totalOffset()
+{
+    if (m_sections.empty()) return 0;
+    auto lastSection = m_sections[m_sections.size()-1];
+    return lastSection.positionOffset() + lastSection.rangeOffset();
+}
+
+int LineControl::visibleToAbsolute(int visible)
+{
+    LineSection ls;
+    ls.visiblePosition = visible;
+    auto upper = std::upper_bound(m_sections.begin(), m_sections.end(), ls, LineSection::compareVisible);
+
+    int abs = visible;
+    if (upper != m_sections.begin())
+    {
+        auto prev = std::prev(upper);
+        if (visible >= prev->visiblePosition + prev->visibleRange)
+            abs = visible - prev->positionOffset() - prev->rangeOffset();
+        else if (prev->type == LineSection::Collapsed && visible == prev->visiblePosition)
+            abs = prev->position;
+        else abs = -1; // not mapping to an absolute line
+    }
+
+    if (abs >= m_textEdit->documentHandler()->target()->blockCount()) return -1;
+    return abs;
+}
+
+bool LineControl::hiddenByPalette(int blockNumber)
+{
+    auto upper = std::upper_bound(m_sections.begin(), m_sections.end(), LineSection(blockNumber, 0, 0, LineSection::Palette), LineSection::compare);
+    if (upper != m_sections.begin() && !m_sections.empty())
+    {
+        auto prev = std::prev(upper);
+        if (prev->type == LineSection::Palette
+                && blockNumber < prev->position + prev->range)
+            return true;
+    }
+    return false;
+}
+
+bool LineControl::hiddenByCollapse(int blockNumber)
+{
+    auto upper = std::upper_bound(m_sections.begin(), m_sections.end(), LineSection(blockNumber, 0, 0, LineSection::Palette), LineSection::compare);
+    if (upper != m_sections.begin() && !m_sections.empty())
+    {
+        auto prev = std::prev(upper);
+        if (prev->type == LineSection::Collapsed
+                && blockNumber < prev->position + prev->range
+                && blockNumber != prev->position)
+            return true;
+    }
+    return false;
+}
+
+int LineControl::isJumpForwardLine(int blockNumber, bool forCollapse)
+{
+    auto lower = std::lower_bound(
+        m_sections.begin(), m_sections.end(),
+        LineSection(blockNumber, 0,0,LineSection::Collapsed),
+        LineSection::compare);
+    if (lower != m_sections.end())
+    {
+        switch (lower->type)
+        {
+        case LineSection::Palette:
+            if (blockNumber + 1 == lower->position && !forCollapse)
+                return lower->range;
+            break;
+        case LineSection::Collapsed:
+            if (blockNumber == lower->position)
+                return lower->range - 1;
+            break;
+        case LineSection::Fragment:
+            if (blockNumber + 1 == lower->position && !forCollapse)
+                return -1;
+            break;
+        }
+    }
+
+    return 0;
+}
+
+int LineControl::isJumpBackwardsLine(int blockNumber)
+{
+    auto upper = std::upper_bound(
+        m_sections.begin(), m_sections.end(),
+        LineSection(blockNumber, 0,0,LineSection::Collapsed),
+        LineSection::compare);
+    if (upper != m_sections.begin() && !m_sections.empty())
+    {
+        auto prev = std::prev(upper);
+        if (blockNumber == prev->position + prev->range)
+        switch (prev->type)
+        {
+        case LineSection::Palette:      return prev->range;
+        case LineSection::Collapsed:    return prev->range - 1;
+        case LineSection::Fragment:     return -1;
+        }
+    }
+
+    return 0;
+}
+
+void LineControl::setDirtyPos(int dirtyPos)
+{
+    m_dirtyPos = dirtyPos;
+}
+
+void LineControl::lineNumberChange()
+{
+    m_prevLineNumber = m_lineNumber;
+    m_lineNumber = m_textEdit->documentHandler()->target()->blockCount();
+    if (m_prevLineNumber == m_lineNumber) return;
+
+    if (m_prevLineNumber < m_lineNumber) linesAdded();
+    else linesRemoved();
+}
+
+unsigned LineControl::insertIntoSorted(LineControl::LineSection ls)
+{
+    auto upper = std::upper_bound(m_sections.begin(), m_sections.end(), ls, LineSection::compare);
+    unsigned position = static_cast<unsigned>(upper - m_sections.begin());
+    m_sections.insert(upper, ls);
+    return position;
+}
+
+void LineControl::calculateVisiblePosition(unsigned pos)
+{
+    int off = 0;
+    for (unsigned i = 0; i < pos; ++i)
+        off += m_sections[i].rangeOffset();
+    m_sections[pos].visiblePosition = m_sections[pos].position + off;
+}
+
+void LineControl::offsetAfterIndex(unsigned index, int offset, bool offsetPositions)
+{
+    std::queue<LineSection*> q;
+    for (unsigned i = index + 1; i < m_sections.size(); ++i)
+    {
+        q.push(&m_sections[i]);
+        while (!q.empty())
+        {
+            LineSection* lsp = q.front(); q.pop();
+            for (int x = 0; x < lsp->nested.size(); ++x)
+                q.push(&lsp->nested[x]);
+
+            lsp->visiblePosition += offset;
+            if (offsetPositions) lsp->position += offset;
+            if (lsp->type == LineSection::Palette)
+            {
+                lsp->palette->setY(lsp->visiblePosition * m_blockHeight + (lsp->visibleRange * m_blockHeight - lsp->palette->height()) / 2 + 6);
+            }
+            else if (lsp->type == LineSection::Fragment) // handles end fragment bounds
+            {
+                lsp->range = m_lineNumber - lsp->position;
+            }
+        }
+    }
+}
+
+void LineControl::linesAdded()
+{
+    int delta = m_lineNumber - m_prevLineNumber;
+    auto upper = std::upper_bound(m_sections.begin(), m_sections.end(), LineSection(m_dirtyPos, 0,0,LineSection::Collapsed), LineSection::compare);
+
+    bool offsetVisible = true;
+    std::queue<LineSection*> q;
+
+    // handles case of adding lines via palette
+    if (upper != m_sections.begin() && !m_sections.empty())
+    {
+        auto prev = std::prev(upper);
+        if (m_dirtyPos < prev->position + prev->range)
+        {
+            offsetVisible = false;
+            prev->range += delta;
+        }
+    }
+
+    offsetAfterIndex(static_cast<unsigned>(upper-m_sections.begin()-1), delta, true);
+
+    QTextCursor cursor(m_lineDocument);
+    cursor.movePosition(QTextCursor::MoveOperation::End);
+    for (int i = m_prevLineNumber + 1; i <= m_lineNumber; i++)
+    {
+        if (i!=1) cursor.insertBlock();
+        std::string s = std::to_string(i) + "  ";
+        if (i < 10) s = " " + s;
+        const QString a(s.c_str());
+
+        cursor.insertText(a);
+    }
+
+    updateLinesInDocuments();
+    m_textEdit->updateLineSurface(m_prevLineNumber, m_lineNumber, m_dirtyPos);
+}
+
+void LineControl::updateLinesInDocuments()
+{
+    if (m_dirtyPos < 0) return;
+    int curr = m_dirtyPos;
+    auto it = m_lineDocument->rootFrame()->begin();
+    for (int i = 0; i < curr; i++)
+    {
+        ++it;
+    }
+    while (it != m_lineDocument->rootFrame()->end())
+    {
+        auto currBlock = m_textEdit->documentHandler()->target()->findBlockByNumber(curr);
+        lv::ProjectDocumentBlockData* userData =
+                static_cast<lv::ProjectDocumentBlockData*>(currBlock.userData());
+
+        if (userData) {
+            if (userData->isCollapsible())
+            {
+                if (isJumpForwardLine(curr, true) > 0) // is first line of collapse?
+                    changeLastCharInLineDocumentBlock(curr, '>');
+                else
+                    changeLastCharInLineDocumentBlock(curr, 'v');
+            } else
+                changeLastCharInLineDocumentBlock(curr, ' ');
+
+            userData->setStateChangeFlag(false);
+        } else changeLastCharInLineDocumentBlock(curr, ' ');
+
+        ++curr; ++it;
+    }
+
+    auto firstDirtyBlockLine = m_lineDocument->findBlockByNumber(m_dirtyPos);
+    m_lineDocument->markContentsDirty(firstDirtyBlockLine.position(), m_lineDocument->characterCount() - firstDirtyBlockLine.position());
+}
+
+void LineControl::linesRemoved()
+{
+    int delta = m_lineNumber - m_prevLineNumber;
+    auto upper = std::upper_bound(m_sections.begin(), m_sections.end(), LineSection(m_dirtyPos, 0,0,LineSection::Collapsed), LineSection::compare);
+
+    // handles case of adding lines via palette
+    if (upper != m_sections.begin() && !m_sections.empty())
+    {
+        auto prev = std::prev(upper);
+        if (m_dirtyPos < prev->position + prev->range)
+        {
+            prev->range += delta;
+        }
+    }
+
+    offsetAfterIndex(static_cast<unsigned>(upper-m_sections.begin()-1), delta, true);
+
+    for (int i = m_prevLineNumber-1; i >= m_lineNumber; i--)
+    {
+        QTextCursor cursor(m_lineDocument->findBlockByNumber(i));
+        cursor.select(QTextCursor::BlockUnderCursor);
+        cursor.removeSelectedText();
+    }
+
+    updateLinesInDocuments();
+    m_textEdit->updateLineSurface(m_prevLineNumber, m_lineNumber, m_dirtyPos);
+}
+
+QTextDocument *LineControl::lineDocument()
+{
+    return m_lineDocument;
+}
+
+void LineControl::setLineDocumentFont(const QFont &font)
+{
+    m_lineDocument->setDefaultFont(font);
+}
+
+int LineControl::firstContentLine()
+{
+    if (m_sections.empty()) return 0;
+    auto first = m_sections[0];
+    if (first.type == LineSection::Fragment && first.position == 0)
+        return first.range;
+    return 0;
+}
+
+int LineControl::lastContentLine()
+{
+    int blockCount = m_textEdit->documentHandler()->target()->blockCount();
+    if (m_sections.empty()) return blockCount;
+    auto last = m_sections[m_sections.size()-1];
+    if (last.type == LineSection::Fragment && last.position + last.range == blockCount)
+        return last.position;
+    return blockCount;
+}
+
+int LineControl::firstBlockOfTextBefore(int lineNumber)
+{
+    auto upper = std::upper_bound(m_sections.begin(), m_sections.end(),
+        LineSection(lineNumber, 0, 0, LineSection::Collapsed), LineSection::compare);
+
+    if (upper != m_sections.begin())
+    {
+        auto prev = std::prev(upper);
+        int currResult = lineNumber;
+        while (true)
+        {
+            switch (prev->type)
+            {
+            case LineSection::Collapsed:
+                if (currResult > prev->position && currResult < prev->position + prev->range)
+                {
+                    return prev->position;
+                }
+                return currResult;
+            case LineSection::Palette:
+            case LineSection::Fragment:
+                if (currResult >= prev->position && currResult < prev->position + prev->range)
+                {
+                    currResult = prev->position - 1;
+
+                    if (prev == m_sections.begin())
+                    {
+                        return currResult;
+                    }
+                    prev = std::prev(prev);
+                } else
+                {
+                    return currResult;
+                }
+                break;
+            }
+        }
+
+    }
+
+    return lineNumber;
+}
+
+std::vector<VisibleSection> LineControl::visibleSections(int firstBlock, int lastBlock)
+{
+    std::vector<VisibleSection> result;
+    LineSection ls;
+    ls.visiblePosition = firstBlock;
+    auto upper = std::upper_bound(m_sections.begin(), m_sections.end(), ls, LineSection::compareVisible);
+    if (upper != m_sections.begin() && !m_sections.empty())
+    {
+        int startPos = firstBlock;
+        int total = lastBlock - firstBlock + 1;
+
+        auto curr = std::prev(upper);
+
+        bool over = false;
+        while (total > 0 && !over)
+        {
+            auto next = std::next(curr);
+
+            switch (curr->type)
+            {
+            case LineSection::Palette:
+                if (startPos < curr->visiblePosition + curr->visibleRange)
+                {
+                    int size = curr->visibleRange - (startPos - curr->visiblePosition);
+                    result.push_back(VisibleSection(size, 0, curr->palette));
+                    total -= size;
+                    startPos = curr->visiblePosition + curr->visibleRange;
+                }
+                break;
+
+            case LineSection::Collapsed:
+                if (startPos == curr->visiblePosition)
+                {
+                    result.push_back(VisibleSection(1, curr->position));
+                    total -= 1;
+                    startPos = curr->visiblePosition + 1;
+                }
+                break;
+            case LineSection::Fragment:
+                break;
+            }
+
+            if (next == m_sections.end()) {
+                result.push_back(VisibleSection(std::min(total, m_lineNumber - startPos), startPos - curr->positionOffset()));
+                over = true;
+            } else {
+                if (next->visiblePosition != startPos) // these are lines between line sections
+                {
+                    result.push_back(VisibleSection(std::min(total, next->visiblePosition - startPos), startPos - curr->positionOffset()));
+                    startPos = next->visiblePosition;
+                    total -= std::min(total, next->visiblePosition - startPos);
+                }
+
+                curr = next;
+            }
+
+        }
+
+
+    } else
+        result.push_back(VisibleSection(lastBlock - firstBlock + 1, firstBlock));
+
+    return result;
+}
+
+void LineControl::replaceTextInLineDocumentBlock(int blockNumber, std::string s)
+{
+    QTextBlock b = m_lineDocument->findBlockByNumber(blockNumber);
+    QTextCursor cursor(b);
+    cursor.beginEditBlock();
+    cursor.movePosition(QTextCursor::EndOfBlock);
+    cursor.movePosition(QTextCursor::StartOfBlock, QTextCursor::MoveMode::KeepAnchor);
+    cursor.removeSelectedText();
+    cursor.insertText(QString(s.c_str()));
+    cursor.endEditBlock();
+}
+
+void LineControl::changeLastCharInLineDocumentBlock(int blockNumber, char c)
+{
+    QTextBlock b = m_lineDocument->findBlockByNumber(blockNumber);
+    QTextCursor cursor(b);
+    cursor.beginEditBlock();
+    cursor.movePosition(QTextCursor::EndOfBlock);
+    cursor.movePosition(QTextCursor::PreviousCharacter, QTextCursor::MoveMode::KeepAnchor);
+    cursor.removeSelectedText();
+    cursor.insertText(QString(c));
+    cursor.endEditBlock();
+}
+
+
+void LineControl::deltaLines(int delta)
+{
+    if (delta == 0) return;
+    m_prevLineNumber = m_lineNumber;
+    m_lineNumber += delta;
+
+    if (m_prevLineNumber < m_lineNumber) linesAdded();
+    else linesRemoved();
+}
+
+void LineControl::addLineSection(LineControl::LineSection ls)
+{
+    auto srch = std::upper_bound(m_sections.begin(), m_sections.end(), ls, LineSection::compare);
+    std::vector<LineSection> nested;
+    while (srch != m_sections.end()
+           && srch->position + srch->range < ls.position+ls.range)
+    {
+        nested.push_back(*srch);
+        srch++;
+    }
+
+    for (LineSection l: nested)
+    {
+        if (l.type == LineSection::Collapsed)
+        {
+            removeLineSection(l, false, true);
+        }
+        else {
+            l.palette->setVisible(false);
+            removeLineSection(l, false, true);
+        }
+    }
+
+
+    for (LineSection l: ls.nested)
+    {
+        nested.push_back(l);
+    }
+
+    ls.nested = nested;
+
+    unsigned elementPos = insertIntoSorted(ls);
+    calculateVisiblePosition(elementPos);
+
+    if (ls.type == LineSection::Palette)
+    {
+        ls.palette->setProperty("x", 20);
+        ls.palette->setProperty("y", m_sections[elementPos].visiblePosition * m_blockHeight + (m_sections[elementPos].visibleRange * m_blockHeight - static_cast<int>(ls.palette->height())) / 2);
+    }
+
+    if (m_sections[elementPos].visibleRange != m_sections[elementPos].range)
+        offsetAfterIndex(elementPos, m_sections[elementPos].rangeOffset(), false);
+    m_totalOffset += m_sections[elementPos].rangeOffset();
+}
+
+void LineControl::removeLineSection(LineControl::LineSection ls, bool destroy, bool nesting)
+{
+    auto lower = std::lower_bound(m_sections.begin(), m_sections.end(), ls, LineSection::compare);
+    unsigned index = static_cast<unsigned>(lower-m_sections.begin());
+    std::vector<LineSection> nested = lower->nested;
+
+
+    if (lower->type == LineSection::Palette && destroy){
+        lower->palette->setVisible(false);
+        QMetaObject::invokeMethod(lower->palette, "close", Qt::DirectConnection);
+    }
+
+    offsetAfterIndex(index, -m_sections[index].rangeOffset(), false);
+    m_totalOffset -= lower->rangeOffset();
+
+    m_sections.erase(lower);
+
+    if (!nesting)
+    {
+        for (LineSection lsx: nested){
+            if (lsx.type == LineSection::Palette){
+                lsx.palette->setVisible(true);
+            }
+            addLineSection(lsx);
+        }
+    }
+}
+
+int LineControl::LineSection::rangeOffset()
+{
+    return visibleRange - range;
+}
+
+int LineControl::LineSection::positionOffset()
+{
+    return visiblePosition - position;
+}
+
+VisibleSection::VisibleSection(int sz, int st, QQuickItem* p):
+    size(sz), start(st), palette(p) {}
+
+
+} // namespace
diff --git a/lib/lveditor/src/linecontrol.h b/lib/lveditor/src/linecontrol.h
new file mode 100644
index 0000000..fb60522
--- /dev/null
+++ b/lib/lveditor/src/linecontrol.h
@@ -0,0 +1,119 @@
+#ifndef LINECONTROL_H
+#define LINECONTROL_H
+
+#include <QQuickItem>
+#include "lveditorglobal.h"
+
+class QTextDocument;
+
+namespace lv {
+
+class TextEdit;
+
+class LV_EDITOR_EXPORT VisibleSection {
+public:
+    VisibleSection(int sz, int st, QQuickItem* p = nullptr);
+
+    int size;
+    int start;
+    QQuickItem* palette;
+};
+
+class LV_EDITOR_EXPORT LineControl : public QObject
+{
+    Q_OBJECT
+public:
+    // TODO: make this private
+    class LV_EDITOR_EXPORT LineSection {
+    public:
+        enum SectionType { Palette, Collapsed, Fragment };
+        LineSection(int p, int l, int v, SectionType t):
+            position(p), range(l), visibleRange(v), type(t), palette(nullptr) {}
+        LineSection(): LineSection(0,0,0, Palette) {}
+
+        static std::function<bool(LineSection, LineSection)> compare;
+        static std::function<bool(LineSection, LineSection)> compareVisible;
+        static std::function<bool(LineSection, LineSection)> compareBounds;
+        int rangeOffset();
+        int positionOffset();
+
+        int position;
+        int range;
+
+        int visiblePosition;
+        int visibleRange;
+
+        int startPos;
+        int endPos;
+
+        SectionType type;
+        QQuickItem* palette;
+
+        std::vector<LineSection> nested;
+    };
+
+    explicit LineControl(QObject *parent = nullptr);
+    ~LineControl() {}
+    void addCollapse(int pos, int num);
+    void removeCollapse(int pos);
+
+    void addPalette(int pos, int span, QQuickItem* p, int startPos, int endPos);
+    int resizePalette(QQuickItem* p);
+    int removePalette(QQuickItem* p, bool destroy = true);
+    void setBlockHeight(int bh);
+    int blockHeight() { return m_blockHeight; }
+    void reset();
+    std::vector<LineSection> sections();
+    void updateSectionBounds(int pos, int removed, int added);
+
+    int drawingOffset(int blockNumber, bool forCursor);
+    int positionOffset(int y);
+    int totalOffset();
+    int visibleToAbsolute(int visible);
+    int absoluteToVisible(int abs);
+
+    bool hiddenByPalette(int blockNumber);
+    bool hiddenByCollapse(int blockNumber);
+    int isJumpForwardLine(int blockNumber, bool forCollapse = false);
+    int isJumpBackwardsLine(int blockNumber);
+    void updateLinesInDocuments();
+    QTextDocument* lineDocument();
+    void setLineDocumentFont(const QFont& font);
+
+    int firstContentLine();
+    int lastContentLine();
+    int firstBlockOfTextBefore(int lineNumber);
+
+    std::vector<VisibleSection> visibleSections(int firstLine, int lastLine);
+signals:
+
+public slots:
+    void setDirtyPos(int dirtyPos);
+    void lineNumberChange();
+    void deltaLines(int delta);
+private:
+    void addLineSection(LineSection ls);
+    void removeLineSection(LineSection ls, bool destroy, bool nesting = false);
+    unsigned insertIntoSorted(LineSection ls);
+    void calculateVisiblePosition(unsigned pos);
+    void offsetAfterIndex(unsigned index, int offset, bool offsetPositions);
+    void linesAdded();
+    void linesRemoved();
+
+    void replaceTextInLineDocumentBlock(int blockNumber, std::string s);
+    void changeLastCharInLineDocumentBlock(int blockNumber, char c);
+
+    std::vector<LineSection> m_sections;
+    int m_blockHeight;
+
+    int m_dirtyPos;
+    int m_prevLineNumber;
+    int m_lineNumber;
+    TextEdit* m_textEdit;
+    int m_totalOffset;
+    QTextDocument* m_lineDocument;
+};
+
+}
+
+#endif // LINECONTROL_H
diff --git a/lib/lveditor/src/linemanager.cpp b/lib/lveditor/src/linemanager.cpp
deleted file mode 100644
index 5bfcfc1..0000000
--- a/lib/lveditor/src/linemanager.cpp
+++ /dev/null
@@ -1,366 +0,0 @@
-#include <queue>
-#include <list>
-#include "linemanager.h"
-#include "textdocumentlayout.h"
-
-namespace lv {
-
-LineManager::CollapsedSection::CollapsedSection(int pos, int num)
-    : position(pos), numberOfLines(num), nestedSections() {}
-
-
-bool LineManager::before(int pos1, int num1, int pos2, int num2)
-{
-    Q_UNUSED(num2)
-    return pos1 < pos2 && pos1 + num1 < pos2;
-}
-
-bool LineManager::inside(int pos1, int num1, int pos2, int num2)
-{
-    return pos1 >= pos2 && (pos1 + num1) <= (pos2 + num2);
-}
-
-bool LineManager::after(int pos1, int num1, int pos2, int num2)
-{
-    Q_UNUSED(num1)
-    return pos2 < pos1 && pos2+num2<=pos1;
-}
-
-void LineManager::writeOutContentOfSections()
-{
-    qDebug() << "---------------sections-------------";
-    auto it = m_sections.begin();
-    int cnt = 0;
-    while (it != m_sections.end())
-    {
-        CollapsedSection* cs = *it;
-        qDebug() << cnt << ": (" << cs->position << cs->numberOfLines << ")";
-        ++it; ++cnt;
-    }
-    qDebug() << "--------------------------------";
-}
-
-void LineManager::replaceTextInLineDocumentBlock(int blockNumber, std::string s)
-{
-    QTextBlock b = m_lineDocument->findBlockByNumber(blockNumber);
-    QTextCursor cursor(b);
-    cursor.beginEditBlock();
-    cursor.movePosition(QTextCursor::EndOfBlock);
-    cursor.movePosition(QTextCursor::StartOfBlock, QTextCursor::MoveMode::KeepAnchor);
-    cursor.removeSelectedText();
-    cursor.insertText(QString(s.c_str()));
-    cursor.endEditBlock();
-}
-
-void LineManager::changeLastCharInLineDocumentBlock(int blockNumber, char c)
-{
-    QTextBlock b = m_lineDocument->findBlockByNumber(blockNumber);
-    QTextCursor cursor(b);
-    cursor.beginEditBlock();
-    cursor.movePosition(QTextCursor::EndOfBlock);
-    cursor.movePosition(QTextCursor::PreviousCharacter, QTextCursor::MoveMode::KeepAnchor);
-    cursor.removeSelectedText();
-    cursor.insertText(QString(c));
-    cursor.endEditBlock();
-}
-
-void LineManager::updateLinesInDocuments()
-{
-    int curr = m_dirtyPos;
-    auto it = m_lineDocument->rootFrame()->begin();
-    for (int i = 0; i < curr; i++)
-    {
-        ++it;
-    }
-    while (it != m_lineDocument->rootFrame()->end())
-    {
-        auto currBlock = m_parentDocument->findBlockByNumber(curr);
-        lv::ProjectDocumentBlockData* userData =
-                static_cast<lv::ProjectDocumentBlockData*>(currBlock.userData());
-
-        if (userData) {
-            switch (userData->collapseState())
-            {
-            case lv::ProjectDocumentBlockData::Collapse:
-                changeLastCharInLineDocumentBlock(curr, 'v');
-                break;
-            case lv::ProjectDocumentBlockData::Expand:
-                changeLastCharInLineDocumentBlock(curr, '>');
-                break;
-            case lv::ProjectDocumentBlockData::NoCollapse:
-                changeLastCharInLineDocumentBlock(curr, ' ');
-                break;
-            }
-            userData->setStateChangeFlag(false);
-        }
-        ++curr; ++it;
-    }
-    auto firstDirtyBlockLine = m_lineDocument->findBlockByNumber(m_dirtyPos);
-    m_lineDocument->markContentsDirty(firstDirtyBlockLine.position(), m_lineDocument->characterCount() - firstDirtyBlockLine.position());
-}
-
-
-bool cmp(LineManager::CollapsedSection* a, LineManager::CollapsedSection* b)
-{
-    return a->position < b->position;
-}
-
-void LineManager::collapseLines(int pos, int num) {
-
-    std::list<CollapsedSection*> nested;
-    auto it = m_sections.begin();
-    updateLineVisibility(false, pos, num);
-
-    while (it != m_sections.end()) {
-        CollapsedSection* sec = *it;
-        if (before(sec->position, sec->numberOfLines, pos, num)) {
-            ++it; continue; }
-        if (inside(sec->position, sec->numberOfLines, pos, num))
-        {
-            nested.emplace_back(sec);
-            it = m_sections.erase(it);
-            continue;
-        }
-        if (after(sec->position, sec->numberOfLines, pos, num)) {
-            ++it; continue; }
-
-        qDebug() << "Overlap error 1!";
-        return;
-    }
-
-    CollapsedSection* nuSection = new CollapsedSection(pos, num);
-    nuSection->nestedSections = std::move(nested);
-
-    m_sections.emplace_back(nuSection);
-    m_sections.sort(cmp);
-
-}
-
-void LineManager::expandLines(int pos, int num)
-{
-    auto it = m_sections.begin();
-    while (it != m_sections.end() && (*it)->position != pos) ++it;
-
-    updateLineVisibility(true, pos, num);
-    if (it != m_sections.end())
-    {
-        CollapsedSection* sec = *it;
-        m_sections.erase(it);
-
-        std::list<CollapsedSection*> nested;
-        nested = std::move(sec->nestedSections);
-
-        for (CollapsedSection* nestedSec: nested)
-        {
-            m_sections.push_back(nestedSec);
-            m_sections.sort(cmp);
-            updateLineVisibility(false, nestedSec->position, nestedSec->numberOfLines);
-        }
-
-        delete sec;
-    }
-    else
-    {
-        qDebug() << "No matching collapse section!";
-    }
-
-}
-
-void LineManager::linesAdded()
-{
-    int pos = m_dirtyPos;
-    int num = m_lineNumber - m_previousLineNumber;
-    QTextCursor cursor(m_lineDocument);
-    cursor.movePosition(QTextCursor::MoveOperation::End);
-    for (int i = m_previousLineNumber + 1; i <= m_lineNumber; i++)
-    {
-        if (i!=1) cursor.insertBlock();
-        std::string s = std::to_string(i) + "  ";
-        if (i < 10) s = " " + s;
-        const QString a(s.c_str());
-
-        cursor.insertText(a);
-    }
-
-    auto it = m_sections.begin();
-    while (it != m_sections.end())
-    {
-        CollapsedSection* sec = *it;
-        if (sec->position >= pos)
-        {
-            std::queue<CollapsedSection*> q;
-            q.push(sec);
-            while (!q.empty())
-            {
-                CollapsedSection* curr = q.front(); q.pop();
-                curr->position += num;
-                for (CollapsedSection* sec: curr->nestedSections)
-                {
-                    q.push(sec);
-                }
-            }
-        }
-        ++it;
-    }
-}
-
-void LineManager::linesRemoved()
-{
-    int pos = m_dirtyPos;
-    int num = m_previousLineNumber - m_lineNumber;
-    for (int i = m_previousLineNumber-1; i >= m_lineNumber; i--)
-    {
-        QTextCursor cursor(m_lineDocument->findBlockByNumber(i));
-        cursor.select(QTextCursor::BlockUnderCursor);
-        cursor.removeSelectedText();
-    }
-
-    auto it = m_sections.begin();
-    std::queue<CollapsedSection*> qs;
-
-    while (it != m_sections.end())
-    {
-        CollapsedSection* sec = *it;
-        if (before(sec->position, sec->numberOfLines, pos, num)) {
-            ++it; continue; }
-        if (inside(sec->position, sec->numberOfLines, pos, num))
-        {
-            qs.emplace(sec);
-            it = m_sections.erase(it);
-            while (!qs.empty())
-            {
-                CollapsedSection* pop = qs.back(); qs.pop();
-                for (auto it = pop->nestedSections.begin(); it != pop->nestedSections.end(); ++it)
-                    qs.push(*it);
-                delete pop;
-            }
-        }
-        if (after(sec->position, sec->numberOfLines, pos, num))
-        {
-            std::queue<CollapsedSection*> q;
-            q.push(sec);
-            while (!q.empty())
-            {
-                CollapsedSection* curr = q.front(); q.pop();
-                curr->position -= num;
-                for (CollapsedSection* sec: curr->nestedSections)
-                {
-                    q.push(sec);
-                }
-            }
-            it++;
-            continue;
-        }
-
-        qDebug() << "Overlap error 2!";
-        return;
-    }
-}
-
-std::list<LineManager::CollapsedSection*> & LineManager::getSections()
-{
-    return m_sections;
-}
-
-std::pair<int, int> LineManager::isLineAfterCollapsedSection(int lineNumber)
-{
-    auto it = m_sections.begin();
-    while (it != m_sections.end())
-    {
-        auto cs = *it;
-        if  (lineNumber == cs->position + cs->numberOfLines + 1) return std::make_pair(cs->position, cs->numberOfLines);
-        ++it;
-    }
-
-    return std::make_pair(-1, -1);
-}
-
-std::pair<int, int> LineManager::isFirstLineOfCollapsedSection(int lineNumber)
-{
-    auto it = m_sections.begin();
-    while (it != m_sections.end())
-    {
-        auto cs = *it;
-        if  (lineNumber == cs->position) return std::make_pair(cs->position, cs->numberOfLines);
-        ++it;
-    }
-
-    return std::make_pair(-1, -1);
-}
-
-void LineManager::setDirtyPos(int p)
-{
-    if (!m_updatePending || p < m_dirtyPos){
-        m_updatePending = true;
-        m_dirtyPos = p;
-    }
-}
-
-void LineManager::textDocumentFinishedUpdating(int newLineNumber)
-{
-    m_previousLineNumber = m_lineNumber;
-    m_lineNumber = newLineNumber;
-
-    int deltaLineNumber = abs(m_previousLineNumber - m_lineNumber);
-    if (deltaLineNumber)
-    {
-        if (m_previousLineNumber < m_lineNumber)
-            linesAdded();
-        else
-            linesRemoved();
-    }
-
-    updateLinesInDocuments();
-    auto parentLayout = reinterpret_cast<TextDocumentLayout*>(parent());
-    parentLayout->updateLineSurface(m_previousLineNumber, m_lineNumber, m_dirtyPos);
-    m_updatePending = false;
-}
-
-void LineManager::setLineDocumentFont(const QFont &font)
-{
-    m_lineDocument->setDefaultFont(font);
-}
-
-void LineManager::setParentDocument(QTextDocument *td)
-{
-    m_parentDocument = td;
-}
-
-void LineManager::updateLineVisibility(bool visible, int pos, int num)
-{
-    auto itLine = m_lineDocument->rootFrame()->begin();
-    auto itDoc = m_parentDocument->rootFrame()->begin();
-    Q_ASSERT(m_parentDocument->blockCount() > pos);
-    Q_ASSERT(m_parentDocument->blockCount() >= pos + num);
-    for (int i = 0; i < pos+1; i++, ++itLine, ++itDoc);
-    int startLine = itLine.currentBlock().position();
-    int startDoc = itDoc.currentBlock().position();
-    int lengthLine = 0;
-    int lengthDoc = 0;
-    for (int i = 0; i < num; i++)
-    {
-        itLine.currentBlock().setVisible(visible);
-        lengthLine += itLine.currentBlock().length();
-        itDoc.currentBlock().setVisible(visible);
-        lengthDoc += itDoc.currentBlock().length();
-        ++itLine; ++itDoc;
-    }
-
-    m_lineDocument->markContentsDirty(startLine, lengthLine);
-    m_parentDocument->markContentsDirty(startDoc, lengthDoc);
-}
-
-LineManager::LineManager(QObject *parent)
-    : QObject(parent), m_sections(), m_lineDocument(new QTextDocument(this)),
-      m_previousLineNumber(0), m_lineNumber(0), m_dirtyPos(0), m_updatePending(false)
-{
-    m_updatePending = false;
-    QTextOption opt;
-    opt.setAlignment(Qt::AlignRight | Qt::AlignTop);
-    opt.setTextDirection(Qt::LeftToRight);
-    m_lineDocument->setDefaultTextOption(opt);
-}
-
-LineManager::~LineManager() {}
-
-}
diff --git a/lib/lveditor/src/linemanager.h b/lib/lveditor/src/linemanager.h
deleted file mode 100644
index 6d3cd07..0000000
--- a/lib/lveditor/src/linemanager.h
+++ /dev/null
@@ -1,69 +0,0 @@
-#ifndef LINEMANAGER_H
-#define LINEMANAGER_H
-
-#include "qtextobject.h"
-#include "textedit_p.h"
-
-namespace lv {
-
-class CollapsedSection;
-class LineSurface;
-
-/// \private
-class LineManager: public QObject{
-
-    Q_OBJECT
-
-public:
-    /// \private
-    class CollapsedSection {
-        public:
-            int position;
-            int numberOfLines;
-            std::list<CollapsedSection*> nestedSections;
-
-            CollapsedSection(int pos = 1, int num = 1);
-    };
-
-    LineManager(QObject *parent=nullptr);
-    ~LineManager();
-
-    void expandLines(int pos, int num);
-    void collapseLines(int pos, int num);
-    void linesAdded();
-    void linesRemoved();
-
-    std::list<CollapsedSection*> & getSections();
-    std::pair<int, int> isLineAfterCollapsedSection(int m_lineNumber);
-    std::pair<int, int> isFirstLineOfCollapsedSection(int m_lineNumber);
-    void setDirtyPos(int p);
-    void textDocumentFinishedUpdating(int newLineNumber);
-    void setLineDocumentFont(const QFont& font);
-    QTextDocument* parentDocument() { return m_parentDocument; }
-    void setParentDocument(QTextDocument* td);
-    void updateLineVisibility(bool visible, int pos, int num);
-
-private:
-    static bool before(int pos1, int num1, int pos2, int num2);
-    static bool inside(int pos1, int num1, int pos2, int num2);
-    static bool after(int pos1, int num1, int pos2, int num2);
-    void writeOutContentOfSections();
-    void replaceTextInLineDocumentBlock(int blockNumber, std::string s);
-    void changeLastCharInLineDocumentBlock(int blockNumber, char c);
-    void updateLinesInDocuments();
-
-    std::list<LineManager::CollapsedSection*> m_sections;
-    QTextDocument* m_lineDocument;
-    int m_previousLineNumber;
-    int m_lineNumber;
-    int m_dirtyPos;
-    QTextDocument* m_parentDocument;
-    bool m_updatePending;
-
-    friend TextDocumentLayout;
-};
-
-}
-
-#endif
-
diff --git a/lib/lveditor/src/linesurface.cpp b/lib/lveditor/src/linesurface.cpp
index 5552f77..429a039 100644
--- a/lib/lveditor/src/linesurface.cpp
+++ b/lib/lveditor/src/linesurface.cpp
@@ -1,449 +1,414 @@
-#include "linesurface.h"
-#include "textcontrol_p.h"
-#include "qquickwindow.h"
-#include "textnodeengine_p.h"
-#include "textutil_p.h"
-
-#include <QtCore/qmath.h>
-#include <QtGui/qguiapplication.h>
-#include <QtGui/qevent.h>
-#include <QtGui/qpainter.h>
-#include <QtGui/qtextobject.h>
-#include <QtGui/qtexttable.h>
-#include <QtQml/qqmlinfo.h>
-#include <QtQuick/qsgsimplerectnode.h>
-#include "private/qtextengine_p.h"
-#include <algorithm>
-#include "textedit_p.h"
-#include "linemanager.h"
-#include "palettemanager.h"
-#include "textdocumentlayout.h"
-
-namespace lv {
-
-namespace {
-    class ProtectedLayoutAccessor: public QAbstractTextDocumentLayout
-    {
-    public:
-        inline QTextCharFormat formatAccessor(int pos)
-        {
-            return format(pos);
-        }
-    };
-
-    class RootNode : public QSGTransformNode
-    {
-    public:
-        RootNode() : frameDecorationsNode(nullptr)
-        { }
-
-        void resetFrameDecorations(TextNode* newNode)
-        {
-            if (frameDecorationsNode) {
-                removeChildNode(frameDecorationsNode);
-                delete frameDecorationsNode;
-            }
-            frameDecorationsNode = newNode;
-            newNode->setFlag(QSGNode::OwnedByParent);
-        }
-        TextNode* frameDecorationsNode;
-
-    };
-}
-
-LineSurface::LineSurface(QQuickItem *parent)
-: QQuickItem(parent)
-, m_color(QRgb(0xFF000000))
-, m_font(QFont()), m_document(nullptr)
-, m_updateType(UpdatePaintNode)
-, m_textEdit(nullptr), m_previousLineNumber(0)
-, m_lineNumber(0), m_dirtyPos(0)
-, m_updatePending(false)
-{
-    setFlag(QQuickItem::ItemHasContents);
-    setAcceptHoverEvents(true);
-}
-
-LineSurface::~LineSurface()
-{
-    qDeleteAll(m_textNodeMap);
-}
-
-QFont LineSurface::font() const
-{
-    return m_font;
-}
-
-void LineSurface::setFont(const QFont &f)
-{
-    if (m_font == f)
-        return;
-
-    m_font = f;
-    if (static_cast<int>(m_font.pointSizeF()) != -1) {
-        // 0.5pt resolution
-        qreal size = qRound(m_font.pointSizeF()*2.0);
-        m_font.setPointSizeF(size/2.0);
-    }
-
-    if (m_document) m_document->setDefaultFont(m_font);
-    updateSize();
-
-    emit fontChanged(m_font);
-}
-
-void LineSurface::paletteSlot(int blockNum)
-{
-    if (!m_document) return;
-    auto firstDirtyBlock = m_document->findBlockByNumber(blockNum);
-    m_dirtyPos = blockNum;
-    m_document->markContentsDirty(firstDirtyBlock.position() - 1, m_document->characterCount() - firstDirtyBlock.position() + 1);
-
-    polish();
-    if (isComponentComplete())
-    {
-        updateSize();
-        m_updateType = LineSurface::UpdatePaintNode;
-
-        update();
-    }
-}
-
-void LineSurface::setDirtyBlockPosition(int pos)
-{
-    if (!m_updatePending || pos < m_dirtyPos)
-    {
-        m_updatePending = true;
-        m_dirtyPos = pos;
-    }
-}
-
-QColor LineSurface::color() const
-{
-    return m_color;
-}
-
-void LineSurface::setColor(const QColor &color)
-{
-
-    if (m_color == color)
-        return;
-
-    m_color = color;
-    emit colorChanged(m_color);
-}
-
-void LineSurface::setComponents(lv::TextEdit* te)
-{
-    m_textEdit = te;
-    te->setLineSurface(this);
-    setFlag(QQuickItem::ItemHasContents);
-    setAcceptedMouseButtons(Qt::AllButtons);
-
-    m_dirtyPos = 0;
-    m_previousLineNumber = 0;
-    m_lineNumber = 0;
-
-    QObject::connect(m_textEdit, &TextEdit::paletteChange, this, &LineSurface::paletteSlot);
-}
-
-void LineSurface::showHideLines(bool show, int pos, int num)
-{
-    if (!m_document) return;
-    auto it = m_document->rootFrame()->begin();
-    Q_ASSERT(m_document->blockCount() > pos);
-    Q_ASSERT(m_document->blockCount() >= pos + num);
-    for (int i = 0; i < pos+1; i++, ++it);
-    int start = it.currentBlock().position();
-
-    int length = 0;
-    for (int i = 0; i < num; i++)
-    {
-        it.currentBlock().setVisible(show);
-        length += it.currentBlock().length();
-        ++it;
-    }
-
-    m_document->markContentsDirty(start, length);
-}
-
-void LineSurface::writeOutBlockStates()
-{
-
-    qDebug() << "----------blockStates---------------";
-    auto it = m_textEdit->documentHandler()->target()->rootFrame()->begin();
-    while (it != m_textEdit->documentHandler()->target()->rootFrame()->end())
-    {
-        QTextBlock block = it.currentBlock();
-        lv::ProjectDocumentBlockData* userData = static_cast<lv::ProjectDocumentBlockData*>(block.userData());
-
-        QString print(std::to_string(block.blockNumber()).c_str());
-        print += " : ";
-        if (userData)
-        {
-            switch (userData->collapseState())
-            {
-            case lv::ProjectDocumentBlockData::NoCollapse:
-                    print += "NoCollapse"; break;
-            case lv::ProjectDocumentBlockData::Collapse:
-                print += "Collapse"; break;
-            case lv::ProjectDocumentBlockData::Expand:
-                print += "Expand"; break;
-            }
-        } else print += "none";
-
-        qDebug() << print;
-        ++it;
-    }
-}
-
-void LineSurface::writeOutBlockVisibility()
-{
-    if (!m_document) return;
-    qDebug() << "----------visibility---------------";
-    auto it = m_document->rootFrame()->begin();
-    while (it != m_document->rootFrame()->end())
-    {
-        QTextBlock block = it.currentBlock();
-
-        qDebug() << block.blockNumber() << block.isVisible();
-        ++it;
-    }
-}
-
-void LineSurface::mousePressEvent(QMouseEvent* event)
-{
-    if (!m_document) return;
-    // find block that was clicked
-    int position = m_document->documentLayout()->hitTest(event->localPos(), Qt::FuzzyHit);
-    QTextBlock block = m_document->findBlock(position);
-    int blockNum = block.blockNumber();
-
-    const QTextBlock& matchingBlock = m_textEdit->documentHandler()->target()->findBlockByNumber(blockNum);
-    lv::ProjectDocumentBlockData* userData = static_cast<lv::ProjectDocumentBlockData*>(matchingBlock.userData());
-    if (userData)
-    {
-        if (userData->collapseState() == lv::ProjectDocumentBlockData::Collapse)
-        {
-            m_textEdit->manageExpandCollapse(matchingBlock.blockNumber(), true);
-        }
-        else if (userData->collapseState() == lv::ProjectDocumentBlockData::Expand)
-        {
-            m_textEdit->manageExpandCollapse(matchingBlock.blockNumber(), false);
-        }
-    }
-}
-
-void LineSurface::triggerPreprocess()
-{
-    if (m_updateType == LineSurface::UpdateNone)
-        m_updateType = LineSurface::UpdateOnlyPreprocess;
-    polish();
-    update();
-}
-
-void LineSurface::setDocument(QTextDocument *doc)
-{
-    if (!doc) return;
-    m_document = doc;
-    m_updatePending = false;
-    m_document->rootFrame(); // bug fix
-    LineManager* lm = dynamic_cast<LineManager*>(m_document->parent());
-    triggerUpdate(m_document->lineCount(), m_document->lineCount(), 0);
-}
-
-void LineSurface::unsetTextDocument()
-{
-    m_document = nullptr;
-    triggerUpdate(m_lineNumber, 0, 0);
-}
-
-void LineSurface::triggerUpdate(int prev, int curr, int dirty)
-{
-    m_previousLineNumber = prev;
-    m_lineNumber = curr;
-    m_dirtyPos = dirty;
-    polish();
-    if (isComponentComplete())
-    {
-        updateSize();
-        m_updateType = LineSurface::UpdatePaintNode;
-        update();
-    }
-}
-
-static bool comesBefore(LineSurface::Node* n1, LineSurface::Node* n2)
-{
-    return n1->startPos() < n2->startPos();
-}
-static inline void updateNodeTransform(TextNode* node, const QPointF &topLeft)
-{
-    QMatrix4x4 transformMatrix;
-    transformMatrix.translate(static_cast<float>(topLeft.x()), static_cast<float>(topLeft.y()));
-    node->setMatrix(transformMatrix);
-}
-inline void resetEngine(TextNodeEngine *engine, const QColor& textColor, const QColor& selectedTextColor, const QColor& selectionColor)
-{
-    *engine = TextNodeEngine();
-    engine->setTextColor(textColor);
-    engine->setSelectedTextColor(selectedTextColor);
-    engine->setSelectionColor(selectionColor);
-}
-QSGNode *LineSurface::updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData *updatePaintNodeData)
-{
-    Q_UNUSED(updatePaintNodeData);
-
-    if (!m_document) {
-        if (oldNode) delete oldNode;
-        return nullptr;
-    }
-
-    if (m_updateType != LineSurface::UpdatePaintNode && oldNode != nullptr) {
-        // Update done in preprocess() in the nodes
-        m_updateType = LineSurface::UpdateNone;
-        return oldNode;
-    }
-
-    m_updateType = LineSurface::UpdateNone;
-
-    if (!oldNode) {
-        // If we had any QQuickTextNode node references, they were deleted along with the root node
-        // But here we must delete the Node structures in textNodeMap
-        qDeleteAll(m_textNodeMap);
-        m_textNodeMap.clear();
-    }
-
-    RootNode *rootNode = static_cast<RootNode *>(oldNode);
-
-    TextNodeEngine engine;
-    TextNodeEngine frameDecorationsEngine;
-
-    if (numberOfDigits(m_previousLineNumber) != numberOfDigits(m_lineNumber) || m_dirtyPos >= m_textNodeMap.size()){
-        m_dirtyPos = 0;
-    }
-    if (!oldNode  || m_dirtyPos != -1) {
-
-        if (!oldNode)
-            rootNode = new RootNode;
-
-        // delete all dirty nodes
-        auto lineNumIt = m_textNodeMap.begin();
-        int hiddenNum = 0; auto itPrime = m_document->rootFrame()->begin();
-        for (int k=0; k<m_dirtyPos; k++)
-        {
-            if (!itPrime.currentBlock().isVisible()) hiddenNum++;
-            ++itPrime;
-        }
-        for (int k=0; k<m_dirtyPos-hiddenNum; k++, lineNumIt++);
-        while (lineNumIt != m_textNodeMap.end())
-        {
-            rootNode->removeChildNode((*lineNumIt)->textNode());
-            delete (*lineNumIt)->textNode();
-            delete *lineNumIt;
-            lineNumIt = m_textNodeMap.erase(lineNumIt);
-        }
-
-        // FIXME: the text decorations could probably be handled separately (only updated for affected textFrames)
-        rootNode->resetFrameDecorations(new TextNode(this));
-        resetEngine(&frameDecorationsEngine, m_color, QColor(), QColor());
-
-        TextNode *node = nullptr;
-
-        int currentNodeSize = 0;
-        QMatrix4x4 basePositionMatrix;
-        rootNode->setMatrix(basePositionMatrix);
-
-        QPointF nodeOffset;
-        if (m_document) {
-            QList<QTextFrame *> frames;
-            frames.append(m_document->rootFrame());
-
-            while (!frames.isEmpty()) { //INFO: Root frame
-                QTextFrame *textFrame = frames.takeFirst();
-                frames.append(textFrame->childFrames());
-                frameDecorationsEngine.addFrameDecorations(m_document, textFrame);
-
-                //INFO: creating the text node
-                node = new TextNode(this);
-                resetEngine(&engine, m_color, QColor(), QColor());
-
-                if (textFrame->firstPosition() > textFrame->lastPosition()
-                        && textFrame->frameFormat().position() != QTextFrameFormat::InFlow) {
-
-                    updateNodeTransform(node, m_document->documentLayout()->frameBoundingRect(textFrame).topLeft());
-                    const int pos = textFrame->firstPosition() - 1;
-                    ProtectedLayoutAccessor *a = static_cast<ProtectedLayoutAccessor *>(m_document->documentLayout());
-                    QTextCharFormat format = a->formatAccessor(pos);
-                    QTextBlock block = textFrame->firstCursorPosition().block();
-                    engine.setCurrentLine(block.layout()->lineForTextPosition(pos - block.position()));
-                    engine.addTextObject(QPointF(0, 0), format, TextNodeEngine::Unselected, m_document,
-                                                  pos, textFrame->frameFormat().position());
-                } else {
-                    // Having nodes spanning across frame boundaries will break the current bookkeeping mechanism. We need to prevent that.
-                    QList<int> frameBoundaries;
-                    frameBoundaries.reserve(frames.size());
-                    Q_FOREACH (QTextFrame *frame, frames)
-                        frameBoundaries.append(frame->firstPosition());
-                    std::sort(frameBoundaries.begin(), frameBoundaries.end());
-
-                    QTextFrame::iterator it = textFrame->begin();
-                    for (int k=0; k<m_dirtyPos; k++, it++);
-
-                    while (!it.atEnd()) {
-
-                        QTextBlock block = it.currentBlock();
-                        ++it;
-                        if (!block.isVisible()) continue;
-
-                        if (!engine.hasContents()) {
-                            nodeOffset = m_document->documentLayout()->blockBoundingRect(block).topLeft();
-                            updateNodeTransform(node, nodeOffset);
-                            int offset = m_textEdit->getPaletteManager()->drawingOffset(block.blockNumber(), false);
-                            nodeOffset.setY(nodeOffset.y() - offset);
-                        }
-
-                        engine.addTextBlock(m_document, block, -nodeOffset, m_color, QColor(), -1, -1);
-                        currentNodeSize += block.length();
-
-                        currentNodeSize = 0;
-                        engine.addToSceneGraph(node, QQuickText::Normal, QColor());
-                        m_textNodeMap.append(new LineSurface::Node(-1, node));
-                        rootNode->appendChildNode(node);
-                        node = new TextNode(this);
-                        resetEngine(&engine, m_color, QColor(), QColor());
-                    }
-                }
-                engine.addToSceneGraph(node, QQuickText::Normal, QColor());
-                m_textNodeMap.append(new LineSurface::Node(-1, node));
-                rootNode->appendChildNode(node);            }
-        }
-
-
-        frameDecorationsEngine.addToSceneGraph(rootNode->frameDecorationsNode, QQuickText::Normal, QColor());
-        // Now prepend the frame decorations since we want them rendered first, with the text nodes and cursor in front.
-        rootNode->prependChildNode(rootNode->frameDecorationsNode);
-
-        // Since we iterate over blocks from different text frames that are potentially not sorted
-        // we need to ensure that our list of nodes is sorted again:
-        std::sort(m_textNodeMap.begin(), m_textNodeMap.end(), &comesBefore);
-    }
-
-    QTextBlock block;
-    for (block = m_document->firstBlock(); block.isValid(); block = block.next()) {
-        if (block.layout() != nullptr && block.layout()->engine() != nullptr)
-            block.layout()->engine()->resetFontEngineCache();
-    }
-
-    return rootNode;
-}
-
-//### we should perhaps be a bit smarter here -- depending on what has changed, we shouldn't
-//    need to do all the calculations each time
-void LineSurface::updateSize()
-{
-    if (!m_document) return;
-    QSizeF layoutSize = m_document->documentLayout()->documentSize();
-    setImplicitSize(layoutSize.width(), layoutSize.height());
-}
-
-}
+#include "linesurface.h"
+#include "textcontrol_p.h"
+#include "qquickwindow.h"
+#include "textnodeengine_p.h"
+#include "textutil_p.h"
+
+#include <QtCore/qmath.h>
+#include <QtGui/qguiapplication.h>
+#include <QtGui/qevent.h>
+#include <QtGui/qpainter.h>
+#include <QtGui/qtextobject.h>
+#include <QtGui/qtexttable.h>
+#include <QtQml/qqmlinfo.h>
+#include <QtQuick/qsgsimplerectnode.h>
+#include "private/qtextengine_p.h"
+#include <algorithm>
+#include "textedit_p.h"
+#include "palettemanager.h"
+#include "linecontrol.h"
+#include "textdocumentlayout.h"
+
+namespace lv {
+
+namespace {
+    class ProtectedLayoutAccessor: public QAbstractTextDocumentLayout
+    {
+    public:
+        inline QTextCharFormat formatAccessor(int pos)
+        {
+            return format(pos);
+        }
+    };
+
+    class RootNode : public QSGTransformNode
+    {
+    public:
+        RootNode() : frameDecorationsNode(nullptr)
+        { }
+
+        void resetFrameDecorations(TextNode* newNode)
+        {
+            if (frameDecorationsNode) {
+                removeChildNode(frameDecorationsNode);
+                delete frameDecorationsNode;
+            }
+            frameDecorationsNode = newNode;
+            newNode->setFlag(QSGNode::OwnedByParent);
+        }
+        TextNode* frameDecorationsNode;
+
+    };
+}
+
+LineSurface::LineSurface(QQuickItem *parent)
+: QQuickItem(parent)
+, m_color(QRgb(0xFF000000))
+, m_font(QFont()), m_document(nullptr)
+, m_updateType(UpdatePaintNode)
+, m_textEdit(nullptr), m_previousLineNumber(0)
+, m_lineNumber(0), m_dirtyPos(0)
+, m_updatePending(false)
+{
+    setFlag(QQuickItem::ItemHasContents);
+    setAcceptHoverEvents(true);
+}
+
+LineSurface::~LineSurface()
+{
+    qDeleteAll(m_textNodeMap);
+}
+
+QFont LineSurface::font() const
+{
+    return m_font;
+}
+
+void LineSurface::setFont(const QFont &f)
+{
+    if (m_font == f)
+        return;
+
+    m_font = f;
+    if (static_cast<int>(m_font.pointSizeF()) != -1) {
+        // 0.5pt resolution
+        qreal size = qRound(m_font.pointSizeF()*2.0);
+        m_font.setPointSizeF(size/2.0);
+    }
+
+    if (m_document) m_document->setDefaultFont(m_font);
+    updateSize();
+
+    emit fontChanged(m_font);
+}
+
+void LineSurface::paletteSlot(int blockNum)
+{
+    if (!m_document) return;
+    auto firstDirtyBlock = m_document->findBlockByNumber(blockNum);
+    m_dirtyPos = blockNum;
+    m_document->markContentsDirty(firstDirtyBlock.position() - 1, m_document->characterCount() - firstDirtyBlock.position() + 1);
+
+    polish();
+    if (isComponentComplete())
+    {
+        updateSize();
+        m_updateType = LineSurface::UpdatePaintNode;
+
+        update();
+    }
+}
+
+void LineSurface::setDirtyBlockPosition(int pos)
+{
+    if (!m_updatePending || pos < m_dirtyPos)
+    {
+        m_updatePending = true;
+        m_dirtyPos = pos;
+    }
+}
+
+QColor LineSurface::color() const
+{
+    return m_color;
+}
+
+void LineSurface::setColor(const QColor &color)
+{
+
+    if (m_color == color)
+        return;
+
+    m_color = color;
+    emit colorChanged(m_color);
+}
+
+void LineSurface::setComponents(lv::TextEdit* te)
+{
+    m_textEdit = te;
+    te->setLineSurface(this);
+    setFlag(QQuickItem::ItemHasContents);
+    setAcceptedMouseButtons(Qt::AllButtons);
+
+    m_dirtyPos = 0;
+    m_previousLineNumber = 0;
+    m_lineNumber = 0;
+
+    QObject::connect(m_textEdit, &TextEdit::paletteChange, this, &LineSurface::paletteSlot);
+}
+
+void LineSurface::showHideLines(bool show, int pos, int num)
+{
+    if (!m_document) return;
+    auto it = m_document->rootFrame()->begin();
+    Q_ASSERT(m_document->blockCount() > pos);
+    Q_ASSERT(m_document->blockCount() >= pos + num);
+    for (int i = 0; i < pos+1; i++, ++it);
+    int start = it.currentBlock().position();
+
+    int length = 0;
+    for (int i = 0; i < num; i++)
+    {
+        it.currentBlock().setVisible(show);
+        length += it.currentBlock().length();
+        ++it;
+    }
+
+    m_document->markContentsDirty(start, length);
+}
+
+void LineSurface::mousePressEvent(QMouseEvent* event)
+{
+    if (!m_document) return;
+    int position = m_document->documentLayout()->hitTest(event->localPos(), Qt::FuzzyHit);
+    QTextBlock block = m_document->findBlock(position);
+    int blockNum = block.blockNumber();
+
+    int absBlockNum = m_textEdit->lineControl()->visibleToAbsolute(blockNum);
+    const QTextBlock& matchingBlock = m_textEdit->documentHandler()->target()->findBlockByNumber(absBlockNum);
+    const QTextBlock& lineDocBlock = m_document->findBlockByNumber(absBlockNum);
+    lv::ProjectDocumentBlockData* userData = static_cast<lv::ProjectDocumentBlockData*>(matchingBlock.userData());
+    if (userData && userData->isCollapsible())
+    {
+        QString s = lineDocBlock.text();
+        if (s[s.length()-1] == 'v')
+        {
+            m_textEdit->manageExpandCollapse(matchingBlock.blockNumber(), true);
+        }
+        else if (s[s.length()-1] == '>')
+        {
+            m_textEdit->manageExpandCollapse(matchingBlock.blockNumber(), false);
+        }
+    }
+}
+
+void LineSurface::triggerPreprocess()
+{
+    if (m_updateType == LineSurface::UpdateNone)
+        m_updateType = LineSurface::UpdateOnlyPreprocess;
+    polish();
+    update();
+}
+
+void LineSurface::setDocument(QTextDocument *doc)
+{
+    if (!doc) return;
+    m_document = doc;
+    m_updatePending = false;
+    m_document->rootFrame(); // bug fix
+    triggerUpdate(m_document->lineCount(), 0);
+}
+
+void LineSurface::unsetTextDocument()
+{
+    m_document = nullptr;
+    triggerUpdate(0, 0);
+}
+
+void LineSurface::triggerUpdate(int lineNumber, int dirty)
+{
+    m_previousLineNumber = m_lineNumber;
+    m_lineNumber = lineNumber;
+
+    m_dirtyPos = dirty;
+    polish();
+    if (isComponentComplete())
+    {
+        updateSize();
+        m_updateType = LineSurface::UpdatePaintNode;
+        update();
+    }
+}
+
+static bool comesBefore(LineSurface::Node* n1, LineSurface::Node* n2)
+{
+    return n1->startPos() < n2->startPos();
+}
+static inline void updateNodeTransform(TextNode* node, const QPointF &topLeft)
+{
+    QMatrix4x4 transformMatrix;
+    transformMatrix.translate(static_cast<float>(topLeft.x()), static_cast<float>(topLeft.y()));
+    node->setMatrix(transformMatrix);
+}
+inline void resetEngine(TextNodeEngine *engine, const QColor& textColor, const QColor& selectedTextColor, const QColor& selectionColor)
+{
+    *engine = TextNodeEngine();
+    engine->setTextColor(textColor);
+    engine->setSelectedTextColor(selectedTextColor);
+    engine->setSelectionColor(selectionColor);
+}
+QSGNode *LineSurface::updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData *updatePaintNodeData)
+{
+    Q_UNUSED(updatePaintNodeData);
+
+    if (!m_document) {
+        if (oldNode) delete oldNode;
+        return nullptr;
+    }
+
+    if (m_updateType != LineSurface::UpdatePaintNode && oldNode != nullptr) {
+        // Update done in preprocess() in the nodes
+        m_updateType = LineSurface::UpdateNone;
+        return oldNode;
+    }
+
+    m_updateType = LineSurface::UpdateNone;
+
+    if (!oldNode) {
+        // If we had any QQuickTextNode node references, they were deleted along with the root node
+        // But here we must delete the Node structures in textNodeMap
+        qDeleteAll(m_textNodeMap);
+        m_textNodeMap.clear();
+    }
+
+    RootNode *rootNode = static_cast<RootNode *>(oldNode);
+
+    TextNodeEngine engine;
+    TextNodeEngine frameDecorationsEngine;
+
+    if (numberOfDigits(m_previousLineNumber) != numberOfDigits(m_lineNumber) || m_dirtyPos >= m_textNodeMap.size()){
+        m_dirtyPos = 0;
+    }
+
+    m_dirtyPos = 0; // TODO: better solution needed
+
+    if (!oldNode  || m_dirtyPos != -1) {
+
+        if (!oldNode)
+            rootNode = new RootNode;
+
+        // delete all dirty nodes
+        auto lineNumIt = m_textNodeMap.begin();
+        int hiddenNum = 0; auto itPrime = m_document->rootFrame()->begin();
+        for (int k=0; k<m_dirtyPos; k++)
+        {
+            if (!itPrime.currentBlock().isVisible()) hiddenNum++;
+            ++itPrime;
+        }
+        for (int k=0; k<m_dirtyPos-hiddenNum; k++, lineNumIt++);
+        while (lineNumIt != m_textNodeMap.end())
+        {
+            rootNode->removeChildNode((*lineNumIt)->textNode());
+            delete (*lineNumIt)->textNode();
+            delete *lineNumIt;
+            lineNumIt = m_textNodeMap.erase(lineNumIt);
+        }
+
+        // FIXME: the text decorations could probably be handled separately (only updated for affected textFrames)
+        rootNode->resetFrameDecorations(new TextNode(this));
+        resetEngine(&frameDecorationsEngine, m_color, QColor(), QColor());
+
+        TextNode *node = nullptr;
+
+        int currentNodeSize = 0;
+        QMatrix4x4 basePositionMatrix;
+        rootNode->setMatrix(basePositionMatrix);
+
+        QPointF nodeOffset;
+        if (m_document) {
+            QList<QTextFrame *> frames;
+            frames.append(m_document->rootFrame());
+
+            while (!frames.isEmpty()) { //INFO: Root frame
+                QTextFrame *textFrame = frames.takeFirst();
+                frames.append(textFrame->childFrames());
+                frameDecorationsEngine.addFrameDecorations(m_document, textFrame);
+
+                //INFO: creating the text node
+                node = new TextNode(this);
+                resetEngine(&engine, m_color, QColor(), QColor());
+
+                if (textFrame->firstPosition() > textFrame->lastPosition()
+                        && textFrame->frameFormat().position() != QTextFrameFormat::InFlow) {
+
+                    updateNodeTransform(node, m_document->documentLayout()->frameBoundingRect(textFrame).topLeft());
+                    const int pos = textFrame->firstPosition() - 1;
+                    ProtectedLayoutAccessor *a = static_cast<ProtectedLayoutAccessor *>(m_document->documentLayout());
+                    QTextCharFormat format = a->formatAccessor(pos);
+                    QTextBlock block = textFrame->firstCursorPosition().block();
+                    engine.setCurrentLine(block.layout()->lineForTextPosition(pos - block.position()));
+                    engine.addTextObject(QPointF(0, 0), format, TextNodeEngine::Unselected, m_document,
+                                                  pos, textFrame->frameFormat().position());
+                } else {
+                    // Having nodes spanning across frame boundaries will break the current bookkeeping mechanism. We need to prevent that.
+                    QList<int> frameBoundaries;
+                    frameBoundaries.reserve(frames.size());
+                    Q_FOREACH (QTextFrame *frame, frames)
+                        frameBoundaries.append(frame->firstPosition());
+                    std::sort(frameBoundaries.begin(), frameBoundaries.end());
+
+                    QTextFrame::iterator it = textFrame->begin();
+                    for (int k=0; k<m_dirtyPos; k++, it++);
+
+                    while (!it.atEnd()) {
+
+                        QTextBlock block = it.currentBlock();
+                        ++it;
+                        if (!block.isVisible()) continue;
+
+                        if (!engine.hasContents()) {
+                            nodeOffset = m_document->documentLayout()->blockBoundingRect(block).topLeft();
+                            updateNodeTransform(node, nodeOffset);
+                            // int offset = m_textEdit->getPaletteManager()->drawingOffset(block.blockNumber(), false);
+
+                            int offset = 0;
+                            if (m_textEdit && m_textEdit->lineControl())
+                                offset = m_textEdit->lineControl()->drawingOffset(block.blockNumber(), false);
+                            nodeOffset.setY(nodeOffset.y() - offset);
+                        }
+
+                        engine.addTextBlock(m_document, block, -nodeOffset, m_color, QColor(), -1, -1);
+                        currentNodeSize += block.length();
+
+                        currentNodeSize = 0;
+                        engine.addToSceneGraph(node, QQuickText::Normal, QColor());
+                        m_textNodeMap.append(new LineSurface::Node(-1, node));
+                        rootNode->appendChildNode(node);
+                        node = new TextNode(this);
+                        resetEngine(&engine, m_color, QColor(), QColor());
+                    }
+                }
+                engine.addToSceneGraph(node, QQuickText::Normal, QColor());
+                m_textNodeMap.append(new LineSurface::Node(-1, node));
+                rootNode->appendChildNode(node);            }
+        }
+
+
+        frameDecorationsEngine.addToSceneGraph(rootNode->frameDecorationsNode, QQuickText::Normal, QColor());
+        // Now prepend the frame decorations since we want them rendered first, with the text nodes and cursor in front.
+        rootNode->prependChildNode(rootNode->frameDecorationsNode);
+
+        // Since we iterate over blocks from different text frames that are potentially not sorted
+        // we need to ensure that our list of nodes is sorted again:
+        std::sort(m_textNodeMap.begin(), m_textNodeMap.end(), &comesBefore);
+    }
+
+    QTextBlock block;
+    for (block = m_document->firstBlock(); block.isValid(); block = block.next()) {
+        if (block.layout() != nullptr && block.layout()->engine() != nullptr)
+            block.layout()->engine()->resetFontEngineCache();
+    }
+
+    return rootNode;
+}
+
+//### we should perhaps be a bit smarter here -- depending on what has changed, we shouldn't
+//    need to do all the calculations each time
+void LineSurface::updateSize()
+{
+    if (!m_document) return;
+    QSizeF layoutSize = m_document->documentLayout()->documentSize();
+    setImplicitSize(layoutSize.width(), layoutSize.height());
+}
+
+}
diff --git a/lib/lveditor/src/linesurface.h b/lib/lveditor/src/linesurface.h
index f032bb6..958af32 100644
--- a/lib/lveditor/src/linesurface.h
+++ b/lib/lveditor/src/linesurface.h
@@ -1,115 +1,113 @@
-#ifndef LINESURFACE_H
-#define LINESURFACE_H
-
-#include <QtGui/qtextoption.h>
-#include "live/lveditorglobal.h"
-#include "textedit_p.h"
-#include "qquickpainteditem.h"
-
-class QTextBlock;
-
-namespace lv {
-
-class LineSurfacePrivate;
-class LineManager;
-class TextNode;
-
-/// \private
-class LineSurface : public QQuickItem
-{
-    Q_OBJECT
-
-    Q_PROPERTY(QColor color READ color WRITE setColor NOTIFY colorChanged)
-    Q_PROPERTY(QFont font READ font WRITE setFont NOTIFY fontChanged)
-
-public:
-
-    friend class TextUtil;
-    friend class LineManager;
-
-public:
-    /// \private
-    class Node
-    {
-    public:
-        explicit Node(int startPos, TextNode* node)
-            : m_startPos(startPos), m_node(node) { }
-        TextNode* textNode() const { return m_node; }
-        void moveStartPos(int delta) { Q_ASSERT(m_startPos + delta > 0); m_startPos += delta; }
-        int startPos() const { return m_startPos; }
-
-    private:
-        int m_startPos;
-        TextNode* m_node;
-    };
-
-    LineSurface(QQuickItem *parent=nullptr);
-    ~LineSurface() Q_DECL_OVERRIDE;
-    QFont font() const;
-    void setFont(const QFont &font);
-    QColor color() const;
-    void setColor(const QColor &c);
-    Q_INVOKABLE void setComponents(lv::TextEdit* te);
-    void setDocument(QTextDocument* doc);
-    void unsetTextDocument();
-
-public Q_SLOTS:
-    void setDirtyBlockPosition(int pos);
-    void paletteSlot(int blockNum);
-    void triggerUpdate(int prev, int curr, int dirty);
-
-Q_SIGNALS:
-    void colorChanged(const QColor &color);
-    void fontChanged(const QFont &font);
-
-protected:
-    void mousePressEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
-    QSGNode *updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData *updatePaintNodeData) Q_DECL_OVERRIDE;
-
-private Q_SLOTS:
-    void updateSize();
-    void triggerPreprocess();
-
-private:
-    void showHideLines(bool show, int pos, int num);
-    void writeOutBlockStates();
-    void writeOutBlockVisibility();
-
-    static inline int numberOfDigits(int i) {
-        int res = 0;
-        if (i < 10) return 2;
-        while (i > 0)
-        {
-            res++;
-            i/=10;
-        }
-        return res;
-    }
-
-    enum UpdateType {
-        UpdateNone,
-        UpdateOnlyPreprocess,
-        UpdatePaintNode
-    };
-
-    QColor m_color;
-    QFont m_font;
-    QTextDocument *m_document;
-    QList<Node*> m_textNodeMap;
-    UpdateType m_updateType;
-    TextEdit* m_textEdit;
-    int m_previousLineNumber;
-    int m_lineNumber;
-    int m_dirtyPos;
-    int m_deltaLineNumber;
-    bool m_updatePending;
-private:
-    Q_DISABLE_COPY(LineSurface)
-};
-
-}
-
-QML_DECLARE_TYPE(lv::LineSurface)
-
-
-#endif // LINESURFACE_H
+#ifndef LINESURFACE_H
+#define LINESURFACE_H
+
+#include <QtGui/qtextoption.h>
+#include "live/lveditorglobal.h"
+#include "textedit_p.h"
+#include "qquickpainteditem.h"
+
+class QTextBlock;
+
+namespace lv {
+
+class LineSurfacePrivate;
+class LineManager;
+class TextNode;
+
+/// \private
+class LineSurface : public QQuickItem
+{
+    Q_OBJECT
+
+    Q_PROPERTY(QColor color READ color WRITE setColor NOTIFY colorChanged)
+    Q_PROPERTY(QFont font READ font WRITE setFont NOTIFY fontChanged)
+
+public:
+
+    friend class TextUtil;
+    friend class LineManager;
+
+public:
+    /// \private
+    class Node
+    {
+    public:
+        explicit Node(int startPos, TextNode* node)
+            : m_startPos(startPos), m_node(node) { }
+        TextNode* textNode() const { return m_node; }
+        void moveStartPos(int delta) { Q_ASSERT(m_startPos + delta > 0); m_startPos += delta; }
+        int startPos() const { return m_startPos; }
+
+    private:
+        int m_startPos;
+        TextNode* m_node;
+    };
+
+    LineSurface(QQuickItem *parent=nullptr);
+    ~LineSurface() Q_DECL_OVERRIDE;
+    QFont font() const;
+    void setFont(const QFont &font);
+    QColor color() const;
+    void setColor(const QColor &c);
+    Q_INVOKABLE void setComponents(lv::TextEdit* te);
+    void setDocument(QTextDocument* doc);
+    void unsetTextDocument();
+
+public Q_SLOTS:
+    void setDirtyBlockPosition(int pos);
+    void paletteSlot(int blockNum);
+    void triggerUpdate(int lineNumber, int dirty);
+
+Q_SIGNALS:
+    void colorChanged(const QColor &color);
+    void fontChanged(const QFont &font);
+
+protected:
+    void mousePressEvent(QMouseEvent *event) Q_DECL_OVERRIDE;
+    QSGNode *updatePaintNode(QSGNode *oldNode, UpdatePaintNodeData *updatePaintNodeData) Q_DECL_OVERRIDE;
+
+private Q_SLOTS:
+    void updateSize();
+    void triggerPreprocess();
+
+private:
+    void showHideLines(bool show, int pos, int num);
+
+    static inline int numberOfDigits(int i) {
+        int res = 0;
+        if (i < 10) return 2;
+        while (i > 0)
+        {
+            res++;
+            i/=10;
+        }
+        return res;
+    }
+
+    enum UpdateType {
+        UpdateNone,
+        UpdateOnlyPreprocess,
+        UpdatePaintNode
+    };
+
+    QColor m_color;
+    QFont m_font;
+    QTextDocument *m_document;
+    QList<Node*> m_textNodeMap;
+    UpdateType m_updateType;
+    TextEdit* m_textEdit;
+    int m_previousLineNumber;
+    int m_lineNumber;
+    int m_dirtyPos;
+    int m_deltaLineNumber;
+    bool m_updatePending;
+private:
+    Q_DISABLE_COPY(LineSurface)
+};
+
+}
+
+QML_DECLARE_TYPE(lv::LineSurface)
+
+
+#endif // LINESURFACE_H
diff --git a/lib/lveditor/src/lveditor.pri b/lib/lveditor/src/lveditor.pri
index 5dec63c..ad0598b 100644
--- a/lib/lveditor/src/lveditor.pri
+++ b/lib/lveditor/src/lveditor.pri
@@ -1,49 +1,51 @@
-INCLUDEPATH += $$PWD \
-               $$PWD/../3rdparty
-
-HEADERS += \
-    $$PWD/project.h \
-    $$PWD/projectentry.h \
-    $$PWD/projectfile.h \
-    $$PWD/projectfilemodel.h \
-    $$PWD/projectdocument.h \
-    $$PWD/codecompletionmodel.h \
-    $$PWD/codecompletionsuggestion.h \
-    $$PWD/abstractcodehandler.h \
-    $$PWD/projectnavigationmodel.h \
-    $$PWD/projectdocumentmodel.h \
-    $$PWD/editorsettings.h \
-    $$PWD/documenthandler.h \
-    $$PWD/editorsettingscategory.h \
-    $$PWD/lveditorglobal.h \
-    $$PWD/editorglobalobject.h \
-    $$PWD/editorprivate_plugin.h \
-    $$PWD/linemanager.h \
-    $$PWD/linesurface.h \
-    $$PWD/palettemanager.h \
-    $$PWD/palettecontainer.h \
-    $$PWD/palettelist.h \
-    $$PWD/codepalette.h
-
-SOURCES += \
-    $$PWD/project.cpp \
-    $$PWD/projectentry.cpp \
-    $$PWD/projectfile.cpp \
-    $$PWD/projectfilemodel.cpp \
-    $$PWD/projectdocument.cpp \
-    $$PWD/codecompletionmodel.cpp \
-    $$PWD/codecompletionsuggestion.cpp \
-    $$PWD/abstractcodehandler.cpp \
-    $$PWD/projectnavigationmodel.cpp \
-    $$PWD/projectdocumentmodel.cpp \
-    $$PWD/editorsettings.cpp \
-    $$PWD/documenthandler.cpp \
-    $$PWD/editorsettingscategory.cpp \
-    $$PWD/editorglobalobject.cpp \
-    $$PWD/editorprivate_plugin.cpp \
-    $$PWD/linemanager.cpp \
-    $$PWD/linesurface.cpp \
-    $$PWD/palettemanager.cpp \
-    $$PWD/palettecontainer.cpp \
-    $$PWD/palettelist.cpp \
-    $$PWD/codepalette.cpp
+INCLUDEPATH += $$PWD \
+               $$PWD/../3rdparty
+
+HEADERS += \
+    $$PWD/project.h \
+    $$PWD/projectentry.h \
+    $$PWD/projectfile.h \
+    $$PWD/projectfilemodel.h \
+    $$PWD/projectdocument.h \
+    $$PWD/codecompletionmodel.h \
+    $$PWD/codecompletionsuggestion.h \
+    $$PWD/abstractcodehandler.h \
+    $$PWD/projectnavigationmodel.h \
+    $$PWD/projectdocumentmodel.h \
+    $$PWD/editorsettings.h \
+    $$PWD/documenthandler.h \
+    $$PWD/editorsettingscategory.h \
+    $$PWD/lveditorglobal.h \
+    $$PWD/editorglobalobject.h \
+    $$PWD/editorprivate_plugin.h \
+    $$PWD/linesurface.h \
+    $$PWD/palettemanager.h \
+    $$PWD/palettecontainer.h \
+    $$PWD/palettelist.h \
+    $$PWD/codepalette.h \
+    $$PWD/texteditnodedebugmodel.h \
+    $$PWD/linecontrol.h
+
+SOURCES += \
+    $$PWD/project.cpp \
+    $$PWD/projectentry.cpp \
+    $$PWD/projectfile.cpp \
+    $$PWD/projectfilemodel.cpp \
+    $$PWD/projectdocument.cpp \
+    $$PWD/codecompletionmodel.cpp \
+    $$PWD/codecompletionsuggestion.cpp \
+    $$PWD/abstractcodehandler.cpp \
+    $$PWD/projectnavigationmodel.cpp \
+    $$PWD/projectdocumentmodel.cpp \
+    $$PWD/editorsettings.cpp \
+    $$PWD/documenthandler.cpp \
+    $$PWD/editorsettingscategory.cpp \
+    $$PWD/editorglobalobject.cpp \
+    $$PWD/editorprivate_plugin.cpp \
+    $$PWD/linesurface.cpp \
+    $$PWD/palettemanager.cpp \
+    $$PWD/palettecontainer.cpp \
+    $$PWD/palettelist.cpp \
+    $$PWD/codepalette.cpp \
+    $$PWD/texteditnodedebugmodel.cpp \
+    $$PWD/linecontrol.cpp
diff --git a/lib/lveditor/src/lveditorglobal.h b/lib/lveditor/src/lveditorglobal.h
index f60a461..ed8ef18 100644
--- a/lib/lveditor/src/lveditorglobal.h
+++ b/lib/lveditor/src/lveditorglobal.h
@@ -1,37 +1,39 @@
-/****************************************************************************
-**
-** Copyright (C) 2014-2018 Dinu SV.
-** (contact: mail@dinusv.com)
-** This file is part of Live CV Application.
-**
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPLv3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl.html.
-**
-****************************************************************************/
-
-#ifndef LVEDITORGLOBAL_H
-#define LVEDITORGLOBAL_H
-
-#include <qglobal.h>
-
-/**
-  \defgroup lveditor lveditor Library
-  \brief Contains editor functionality and extension hooks.
-  */
-
-#ifndef LV_EDITOR_STATIC
-#  ifdef LV_EDITOR_LIB
-#    define LV_EDITOR_EXPORT Q_DECL_EXPORT
-#  else
-#    define LV_EDITOR_EXPORT Q_DECL_IMPORT
-#  endif
-#else
-#  define LV_EDITOR_EXPORT
-#endif
-
-#endif //LVEDITORGLOBAL_H
+/****************************************************************************
+**
+** Copyright (C) 2014-2018 Dinu SV.
+** (contact: mail@dinusv.com)
+** This file is part of Live CV Application.
+**
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPLv3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl.html.
+**
+****************************************************************************/
+
+#ifndef LVEDITORGLOBAL_H
+#define LVEDITORGLOBAL_H
+
+#include <qglobal.h>
+
+/**
+  \defgroup lveditor lveditor Library
+  \brief Contains editor functionality and extension hooks.
+  */
+
+#ifndef LV_EDITOR_STATIC
+#  ifdef LV_EDITOR_LIB
+#    define LV_EDITOR_EXPORT Q_DECL_EXPORT
+#  else
+#    define LV_EDITOR_EXPORT Q_DECL_IMPORT
+#  endif
+#else
+#  define LV_EDITOR_EXPORT
+#endif
+
+// #define LV_EDITOR_DEBUG
+
+#endif //LVEDITORGLOBAL_H
diff --git a/lib/lveditor/src/palettemanager.cpp b/lib/lveditor/src/palettemanager.cpp
index 46d8077..5e3d7f7 100644
--- a/lib/lveditor/src/palettemanager.cpp
+++ b/lib/lveditor/src/palettemanager.cpp
@@ -1,339 +1,355 @@
-#include "palettemanager.h"
-#include <qmath.h>
-#include "qdebug.h"
-#include "textedit_p.h"
-using namespace std;
-
-namespace lv {
-
-PaletteManager::PaletteManager()
-{
-    m_lineNumber = 0;
-    m_dirtyPos = -1;
-    m_totalOffset = 0;
-}
-
-bool paletteCmp(PaletteData* a, PaletteData* b)
-{
-    return a->m_startBlock < b->m_startBlock;
-}
-
-void PaletteManager::paletteAdded(int sb, int span, int height, QQuickItem *p, int startPos, int endPos)
-{
-    auto pd = new PaletteData();
-    pd->m_startBlock = sb;
-    pd->m_lineSpan = span;
-    pd->m_palette = p;
-    pd->m_paletteHeight = height;
-    pd->m_paletteSpan = qCeil((height > 0 ? height + 10 : 0)*1.0/this->m_lineHeight);
-
-    pd->m_startPos = startPos;
-    pd->m_endPos = endPos;
-    m_palettes.push_back(pd);
-    m_palettes.sort(paletteCmp);
-
-    if (pd->m_palette->objectName() != "fragmentStartPalette" && pd->m_palette->objectName() != "fragmentEndPalette")
-    {
-        m_totalOffset += pd->m_lineSpan - pd->m_paletteSpan;
-    }
-
-    auto it = m_palettes.begin();
-    while ((*it)->m_startBlock != pd->m_startBlock) ++it;
-    while (it != m_palettes.end()){ adjustPalettePosition((*it)); ++it; }
-}
-
-int PaletteManager::drawingOffset(int blockNumber, bool forCursor)
-{
-    auto it = m_palettes.begin();
-    int offset = 0;
-    while (it != m_palettes.end())
-    {
-        PaletteData* pd = *it;
-        if (blockNumber < pd->m_startBlock) break;
-
-        if (blockNumber < pd->m_startBlock + pd->m_lineSpan)
-        {
-            if (forCursor) offset = 0;
-            else offset = (-blockNumber - 2)*this->m_lineHeight;
-            break;
-        }
-        offset += (pd->m_paletteSpan - pd->m_lineSpan) * this->m_lineHeight;
-
-        ++it;
-    }
-
-    return offset;
-}
-
-int PaletteManager::positionOffset(int y)
-{
-    auto it = m_palettes.begin();
-    int offset = y / this->m_lineHeight;
-    while (it != m_palettes.end())
-    {
-        PaletteData* pd = *it;
-
-        if (offset < pd->m_startBlock) break;
-
-        if (offset < pd->m_startBlock + pd->m_paletteSpan)
-        {
-            offset = pd->m_startBlock - 1;
-            break;
-        }
-
-        offset += pd->m_lineSpan - pd->m_paletteSpan;
-        it++;
-    }
-
-    return offset * this->m_lineHeight + this->m_lineHeight / 2;
-}
-
-void PaletteManager::setTextEdit(TextEdit *value)
-{
-    m_textEdit = value;
-    if (value != nullptr)
-    {
-        // QObject::connect(textEdit, &TextEdit::dirtyBlockPosition, this, &PaletteManager::setDirtyPos);
-        QObject::connect(m_textEdit, &TextEdit::lineCountChanged, this, &PaletteManager::lineNumberChange);
-    }
-}
-
-void PaletteManager::setLineHeight(int value)
-{
-    m_lineHeight = value;
-}
-
-/** 0 if not, positive number of lines if yes*/
-int PaletteManager::isLineBeforePalette(int blockNumber)
-{
-    auto it = m_palettes.begin();
-    while (it != m_palettes.end())
-    {
-        PaletteData* pd = *it;
-        if (pd->m_startBlock == blockNumber + 1) return pd->m_lineSpan;
-        if (pd->m_startBlock > blockNumber) return 0;
-
-        ++it;
-    }
-
-    return 0;
-}
-
-int PaletteManager::isLineAfterPalette(int blockNumber)
-{
-    auto it = m_palettes.begin();
-    while (it != m_palettes.end())
-    {
-        PaletteData* pd = *it;
-        if (pd->m_startBlock + pd->m_lineSpan == blockNumber) return pd->m_lineSpan;
-        if (pd->m_startBlock >= blockNumber) return 0;
-
-        ++it;
-    }
-
-    return 0;
-}
-
-int  PaletteManager::removePalette(QQuickItem *palette)
-{
-    auto it = m_palettes.begin();
-    int result = -1;
-    while (it != m_palettes.end())
-    {
-        PaletteData* pd = *it;
-        if (pd->matchesPalette(palette))
-        {
-            if (pd->m_palette->objectName() != "fragmentStartPalette" && pd->m_palette->objectName() != "fragmentEndPalette")
-            {
-                m_totalOffset -= pd->m_lineSpan - pd->m_paletteSpan;
-            }
-            result = pd->m_startBlock;
-            delete pd;
-            it = m_palettes.erase(it);
-            continue;
-        }
-        if (result != -1)
-        {
-            adjustPalettePosition(pd);
-        }
-
-        ++it;
-    }
-
-    return result;
-}
-
-int PaletteManager::resizePalette(QQuickItem *palette, int newHeight)
-{
-    auto it = m_palettes.begin();
-    int result = -1;
-    while (it != m_palettes.end())
-    {
-        PaletteData* pd = *it;
-        if (pd->matchesPalette(palette))
-        {
-            pd->m_paletteHeight = newHeight;
-            int newPaletteSpan = qCeil((newHeight > 0 ? newHeight + 10 : 0) * 1.0/ this->m_lineHeight);
-            if (newPaletteSpan != pd->m_paletteSpan)
-            {
-                if (pd->m_palette->objectName() != "fragmentStartPalette" && pd->m_palette->objectName() != "fragmentEndPalette")
-                {
-                    m_totalOffset += pd->m_paletteSpan;
-                }
-                // if changed, we must move the later palettes accordingly
-                pd->m_paletteSpan = newPaletteSpan;
-                if (pd->m_palette->objectName() != "fragmentStartPalette" && pd->m_palette->objectName() != "fragmentEndPalette")
-                {
-                    m_totalOffset -= pd->m_paletteSpan;
-                }
-                result = pd->m_startBlock; ++it; continue;
-            }
-            break; // no effective change
-        }
-        if (result != -1)
-        {
-            adjustPalettePosition(pd);
-        }
-
-        ++it;
-    }
-
-    return result;
-}
-
-std::list<QQuickItem *> PaletteManager::updatePaletteBounds(int pos, int removed, int added)
-{
-    std::list<QQuickItem*> result;
-    if (m_palettes.empty()) return result;
-    auto it = m_palettes.begin();
-    while (it != m_palettes.end()){
-        PaletteData* pd = *it;
-        if (pd->m_palette->objectName() == "fragmentStartPalette" || pd->m_palette->objectName() == "fragmentEndPalette" || pd->m_endPos < pos) {
-            ++it;
-            continue;
-        }
-
-        bool toBeRemoved = pos <= pd->m_startPos && pd->m_startPos <= pos + removed;
-        toBeRemoved = toBeRemoved || (pos <= pd->m_endPos && pd->m_endPos <= pos + removed);
-        toBeRemoved = toBeRemoved && (removed > 0);
-
-        if (toBeRemoved){
-            result.push_back(pd->m_palette);
-        } else {
-            pd->m_startPos += added - removed;
-            pd->m_endPos += added - removed;
-        }
-        ++it;
-    }
-
-    return result;
-}
-
-std::list<QQuickItem *> PaletteManager::deletedOnCollapse(int pos, int num)
-{
-    std::list<QQuickItem*> result;
-    if (m_palettes.empty()) return result;
-    auto it = m_palettes.begin();
-
-    while (it != m_palettes.end()){
-        PaletteData* pd = *it;
-        if (pd->m_palette->objectName() == "fragmentStartPalette" || pd->m_palette->objectName() == "fragmentEndPalette" || pd->m_endPos < pos) {
-            ++it;
-            continue;
-        }
-
-        bool toBeRemoved = (pos <= pd->m_startBlock) && ((pd->m_startBlock + pd->m_lineSpan) <= (pos + num));
-
-        if (toBeRemoved){
-            result.push_back(pd->m_palette);
-        }
-
-        ++it;
-    }
-
-    return result;
-}
-
-int PaletteManager::totalOffset()
-{
-    return m_totalOffset;
-}
-
-void PaletteManager::setDirtyPos(int pos)
-{
-    m_dirtyPos = pos;
-}
-
-void PaletteManager::lineNumberChange()
-{
-    m_prevLineNumber = m_lineNumber;
-    m_lineNumber = m_textEdit->documentHandler()->target()->blockCount();
-    if (m_prevLineNumber == m_lineNumber) return;
-
-    if (m_prevLineNumber < m_lineNumber) linesAdded();
-    else linesRemoved();
-}
-
-void PaletteManager::linesAdded()
-{
-    int delta = m_lineNumber - m_prevLineNumber;
-    auto it = m_palettes.begin();
-    while (it != m_palettes.end())
-    {
-        PaletteData* pd = *it;
-        if (m_dirtyPos >= pd->m_startBlock && m_dirtyPos < pd->m_startBlock + pd->m_lineSpan)
-        {
-            pd->m_lineSpan += delta;
-            ++it;
-            continue;
-        }
-        if (m_dirtyPos >= pd->m_startBlock + pd->m_lineSpan)
-        {
-            ++it;
-            continue;
-        }
-
-        pd->m_startBlock += delta;
-        adjustPalettePosition(pd);
-        ++it;
-    }
-}
-
-void PaletteManager::linesRemoved()
-{
-    int delta = m_prevLineNumber - m_lineNumber;
-    auto it = m_palettes.begin();
-    while (it != m_palettes.end())
-    {
-        PaletteData* pd = *it;
-        if (m_dirtyPos >= pd->m_startBlock + pd->m_lineSpan)
-        {
-            ++it;
-            continue;
-        }
-
-        pd->m_startBlock -= delta;
-        adjustPalettePosition(pd);
-        ++it;
-    }
-}
-
-void PaletteManager::adjustPalettePosition(PaletteData* pd)
-{
-    auto item = pd->m_palette;
-    if (!item) return;
-
-    int offset = 0;
-    for (auto it = m_palettes.begin(); it != m_palettes.end() && (*it)->m_startBlock < pd->m_startBlock; ++it)
-    {
-        offset += (*it)->m_paletteSpan-(*it)->m_lineSpan;
-    }
-
-    item->setProperty("x", 20);
-    item->setProperty("y",(pd->m_startBlock+offset)*this->m_lineHeight + (pd->m_paletteSpan * this->m_lineHeight - pd->m_paletteHeight)/2 + 6);
-
-}
-
-
-
-}
+/*#include "palettemanager.h"
+#include <qmath.h>
+#include "qdebug.h"
+#include "textedit_p.h"
+using namespace std;
+
+namespace lv {
+
+PaletteManager::PaletteManager()
+{
+    m_lineNumber = 0;
+    m_dirtyPos = -1;
+    m_totalOffset = 0;
+}
+
+bool paletteCmp(PaletteData* a, PaletteData* b)
+{
+    return a->m_startBlock < b->m_startBlock;
+}
+
+void PaletteManager::paletteAdded(int sb, int span, int height, QQuickItem *p, int startPos, int endPos)
+{
+    auto pd = new PaletteData();
+    pd->m_startBlock = sb;
+    pd->m_lineSpan = span;
+    pd->m_palette = p;
+    pd->m_paletteHeight = height;
+    pd->m_paletteSpan = qCeil((height > 0 ? height + 10 : 0)*1.0/this->m_lineHeight);
+
+    pd->m_startPos = startPos;
+    pd->m_endPos = endPos;
+    m_palettes.push_back(pd);
+    m_palettes.sort(paletteCmp);
+
+    if (pd->m_palette->objectName() != "fragmentStartPalette" && pd->m_palette->objectName() != "fragmentEndPalette")
+    {
+        m_totalOffset += pd->m_lineSpan - pd->m_paletteSpan;
+    }
+
+    auto it = m_palettes.begin();
+    while ((*it)->m_startBlock != pd->m_startBlock) ++it;
+    while (it != m_palettes.end()){ adjustPalettePosition((*it)); ++it; }
+}
+
+int PaletteManager::drawingOffset(int blockNumber, bool forCursor)
+{
+    auto it = m_palettes.begin();
+    int offset = 0;
+    while (it != m_palettes.end())
+    {
+        PaletteData* pd = *it;
+        if (blockNumber < pd->m_startBlock) break;
+
+        if (blockNumber < pd->m_startBlock + pd->m_lineSpan)
+        {
+            if (forCursor) offset = 0;
+            else offset = (-blockNumber - 2)*this->m_lineHeight;
+            break;
+        }
+        offset += (pd->m_paletteSpan - pd->m_lineSpan) * this->m_lineHeight;
+
+        ++it;
+    }
+
+    return offset;
+}
+
+int PaletteManager::positionOffset(int y)
+{
+    auto it = m_palettes.begin();
+    int offset = y / this->m_lineHeight;
+    while (it != m_palettes.end())
+    {
+        PaletteData* pd = *it;
+
+        if (offset < pd->m_startBlock) break;
+
+        if (offset < pd->m_startBlock + pd->m_paletteSpan)
+        {
+            offset = pd->m_startBlock - 1;
+            break;
+        }
+
+        offset += pd->m_lineSpan - pd->m_paletteSpan;
+        it++;
+    }
+
+    return offset * this->m_lineHeight + this->m_lineHeight / 2;
+}
+
+void PaletteManager::setTextEdit(TextEdit *value)
+{
+    m_textEdit = value;
+    if (value != nullptr)
+    {
+        // QObject::connect(textEdit, &TextEdit::dirtyBlockPosition, this, &PaletteManager::setDirtyPos);
+        QObject::connect(m_textEdit, &TextEdit::lineCountChanged, this, &PaletteManager::lineNumberChange);
+    }
+}
+
+void PaletteManager::setLineHeight(int value)
+{
+    m_lineHeight = value;
+}
+
+// 0 if not, positive number of lines if yes
+int PaletteManager::isLineBeforePalette(int blockNumber)
+{
+    auto it = m_palettes.begin();
+    while (it != m_palettes.end())
+    {
+        PaletteData* pd = *it;
+        if (pd->m_startBlock == blockNumber + 1) return pd->m_lineSpan;
+        if (pd->m_startBlock > blockNumber) return 0;
+
+        ++it;
+    }
+
+    return 0;
+}
+
+int PaletteManager::isLineAfterPalette(int blockNumber)
+{
+    auto it = m_palettes.begin();
+    while (it != m_palettes.end())
+    {
+        PaletteData* pd = *it;
+        if (pd->m_startBlock + pd->m_lineSpan == blockNumber) return pd->m_lineSpan;
+        if (pd->m_startBlock >= blockNumber) return 0;
+
+        ++it;
+    }
+
+    return 0;
+}
+
+int  PaletteManager::removePalette(QQuickItem *palette)
+{
+    auto it = m_palettes.begin();
+    int result = -1;
+    while (it != m_palettes.end())
+    {
+        PaletteData* pd = *it;
+        if (pd->matchesPalette(palette))
+        {
+            if (pd->m_palette->objectName() != "fragmentStartPalette" && pd->m_palette->objectName() != "fragmentEndPalette")
+            {
+                m_totalOffset -= pd->m_lineSpan - pd->m_paletteSpan;
+            }
+            result = pd->m_startBlock;
+            delete pd;
+            it = m_palettes.erase(it);
+            continue;
+        }
+        if (result != -1)
+        {
+            adjustPalettePosition(pd);
+        }
+
+        ++it;
+    }
+
+    return result;
+}
+
+int PaletteManager::resizePalette(QQuickItem *palette, int newHeight)
+{
+    auto it = m_palettes.begin();
+    int result = -1;
+    while (it != m_palettes.end())
+    {
+        PaletteData* pd = *it;
+        if (pd->matchesPalette(palette))
+        {
+            pd->m_paletteHeight = newHeight;
+            int newPaletteSpan = qCeil((newHeight > 0 ? newHeight + 10 : 0) * 1.0/ this->m_lineHeight);
+            if (newPaletteSpan != pd->m_paletteSpan)
+            {
+                if (pd->m_palette->objectName() != "fragmentStartPalette" && pd->m_palette->objectName() != "fragmentEndPalette")
+                {
+                    m_totalOffset += pd->m_paletteSpan;
+                }
+                // if changed, we must move the later palettes accordingly
+                pd->m_paletteSpan = newPaletteSpan;
+                if (pd->m_palette->objectName() != "fragmentStartPalette" && pd->m_palette->objectName() != "fragmentEndPalette")
+                {
+                    m_totalOffset -= pd->m_paletteSpan;
+                }
+                result = pd->m_startBlock; ++it; continue;
+            }
+            break; // no effective change
+        }
+        if (result != -1)
+        {
+            adjustPalettePosition(pd);
+        }
+
+        ++it;
+    }
+
+    return result;
+}
+
+std::list<QQuickItem *> PaletteManager::updatePaletteBounds(int pos, int removed, int added)
+{
+    std::list<QQuickItem*> result;
+    if (m_palettes.empty()) return result;
+    auto it = m_palettes.begin();
+    while (it != m_palettes.end()){
+        PaletteData* pd = *it;
+        if (pd->m_palette->objectName() == "fragmentStartPalette" || pd->m_palette->objectName() == "fragmentEndPalette" || pd->m_endPos < pos) {
+            ++it;
+            continue;
+        }
+
+        bool toBeRemoved = pos <= pd->m_startPos && pd->m_startPos <= pos + removed;
+        toBeRemoved = toBeRemoved || (pos <= pd->m_endPos && pd->m_endPos <= pos + removed);
+        toBeRemoved = toBeRemoved && (removed > 0);
+
+        if (toBeRemoved){
+            result.push_back(pd->m_palette);
+        } else {
+            pd->m_startPos += added - removed;
+            pd->m_endPos += added - removed;
+        }
+        ++it;
+    }
+
+    return result;
+}
+
+std::list<QQuickItem *> PaletteManager::deletedOnCollapse(int pos, int num)
+{
+    std::list<QQuickItem*> result;
+    if (m_palettes.empty()) return result;
+    auto it = m_palettes.begin();
+
+    while (it != m_palettes.end()){
+        PaletteData* pd = *it;
+        if (pd->m_palette->objectName() == "fragmentStartPalette" || pd->m_palette->objectName() == "fragmentEndPalette" || pd->m_endPos < pos) {
+            ++it;
+            continue;
+        }
+
+        bool toBeRemoved = (pos <= pd->m_startBlock) && ((pd->m_startBlock + pd->m_lineSpan) <= (pos + num));
+
+        if (toBeRemoved){
+            result.push_back(pd->m_palette);
+        }
+
+        ++it;
+    }
+
+    return result;
+}
+
+bool PaletteManager::isLineUnderPalette(int pos)
+{
+    for (auto it = m_palettes.begin(); it != m_palettes.end(); ++it)
+    {
+        PaletteData* pd = *it;
+        if (pos >= pd->m_startBlock + pd->m_lineSpan) continue;
+
+        if (pos < pd->m_startBlock) return false;
+        return true;
+    }
+
+    return false;
+
+}
+
+int PaletteManager::totalOffset()
+{
+    return m_totalOffset;
+}
+
+void PaletteManager::setDirtyPos(int pos)
+{
+    m_dirtyPos = pos;
+}
+
+void PaletteManager::lineNumberChange()
+{
+    m_prevLineNumber = m_lineNumber;
+    m_lineNumber = m_textEdit->documentHandler()->target()->blockCount();
+    if (m_prevLineNumber == m_lineNumber) return;
+
+    if (m_prevLineNumber < m_lineNumber) linesAdded();
+    else linesRemoved();
+}
+
+void PaletteManager::linesAdded()
+{
+    int delta = m_lineNumber - m_prevLineNumber;
+    auto it = m_palettes.begin();
+    while (it != m_palettes.end())
+    {
+        PaletteData* pd = *it;
+        if (m_dirtyPos >= pd->m_startBlock && m_dirtyPos < pd->m_startBlock + pd->m_lineSpan)
+        {
+            pd->m_lineSpan += delta;
+            ++it;
+            continue;
+        }
+        if (m_dirtyPos >= pd->m_startBlock + pd->m_lineSpan)
+        {
+            ++it;
+            continue;
+        }
+
+        pd->m_startBlock += delta;
+        adjustPalettePosition(pd);
+        ++it;
+    }
+}
+
+void PaletteManager::linesRemoved()
+{
+    int delta = m_prevLineNumber - m_lineNumber;
+    auto it = m_palettes.begin();
+    while (it != m_palettes.end())
+    {
+        PaletteData* pd = *it;
+        if (m_dirtyPos >= pd->m_startBlock + pd->m_lineSpan)
+        {
+            ++it;
+            continue;
+        }
+
+        pd->m_startBlock -= delta;
+        adjustPalettePosition(pd);
+        ++it;
+    }
+}
+
+void PaletteManager::adjustPalettePosition(PaletteData* pd)
+{
+    auto item = pd->m_palette;
+    if (!item) return;
+
+    int offset = 0;
+    for (auto it = m_palettes.begin(); it != m_palettes.end() && (*it)->m_startBlock < pd->m_startBlock; ++it)
+    {
+        offset += (*it)->m_paletteSpan-(*it)->m_lineSpan;
+    }
+
+    item->setProperty("x", 20);
+    item->setProperty("y",(pd->m_startBlock+offset)*this->m_lineHeight + (pd->m_paletteSpan * this->m_lineHeight - pd->m_paletteHeight)/2 + 6);
+
+}
+
+
+
+}
+*/
diff --git a/lib/lveditor/src/palettemanager.h b/lib/lveditor/src/palettemanager.h
index 03328a2..1decff5 100644
--- a/lib/lveditor/src/palettemanager.h
+++ b/lib/lveditor/src/palettemanager.h
@@ -1,75 +1,77 @@
-#ifndef PALETTEMANAGER_H
-#define PALETTEMANAGER_H
-
-#include "lveditorglobal.h"
-#include "qobjectdefs.h"
-#include <list>
-#include "qquickitem.h"
-
-namespace lv {
-
-class TextEdit;
-
-/// \private
-class PaletteData
-{
-public:
-    int m_startBlock;
-    int m_lineSpan;
-    int m_paletteHeight;
-    QQuickItem* m_palette;
-    int m_paletteSpan;
-    int m_startPos;
-    int m_endPos;
-
-    bool matchesPalette(QQuickItem* p)
-    {
-        return m_palette == p;
-    }
-};
-
-/// \private
-class PaletteManager: public QObject
-{
-    Q_OBJECT
-
-public:
-    PaletteManager();
-
-    void paletteAdded(int sb, int span, int height, QQuickItem* p, int startPos, int endPos);
-    int drawingOffset(int blockNumber, bool forCursor);
-    int positionOffset(int y);
-    void setTextEdit(TextEdit *value);
-
-    void setLineHeight(int value);
-    int isLineBeforePalette(int blockNumber);
-    int isLineAfterPalette(int blockNumber);
-    int removePalette(QQuickItem* palette);
-    int resizePalette(QQuickItem* palette, int newHeight);
-    std::list<QQuickItem *> updatePaletteBounds(int pos, int removed, int added);
-    std::list<QQuickItem *> deletedOnCollapse(int pos, int num);
-    int totalOffset();
-public Q_SLOTS:
-    void setDirtyPos(int pos);
-    void lineNumberChange();
-private:
-    int m_lineHeight;
-    TextEdit *m_textEdit;
-    std::list<PaletteData*> m_palettes;
-    int m_dirtyPos;
-    int m_prevLineNumber;
-    int m_lineNumber;
-    int m_totalOffset;
-
-    void linesAdded();
-    void linesRemoved();
-    void adjustPalettePosition(PaletteData* pd);
-
-
-    friend class TextControl;
-    friend class LineSurface;
-};
-
-}
-
-#endif // PALETTEMANAGER_H
+/*#ifndef PALETTEMANAGER_H
+#define PALETTEMANAGER_H
+
+#include "lveditorglobal.h"
+#include "qobjectdefs.h"
+#include <list>
+#include "qquickitem.h"
+
+namespace lv {
+
+class TextEdit;
+
+/// \private
+class PaletteData
+{
+public:
+    int m_startBlock;
+    int m_lineSpan;
+    int m_paletteHeight;
+    QQuickItem* m_palette;
+    int m_paletteSpan;
+    int m_startPos;
+    int m_endPos;
+
+    bool matchesPalette(QQuickItem* p)
+    {
+        return m_palette == p;
+    }
+};
+
+/// \private
+class PaletteManager: public QObject
+{
+    Q_OBJECT
+
+public:
+    PaletteManager();
+
+    void paletteAdded(int sb, int span, int height, QQuickItem* p, int startPos, int endPos);//
+    int drawingOffset(int blockNumber, bool forCursor);
+    int positionOffset(int y);
+    void setTextEdit(TextEdit *value);//
+
+    void setLineHeight(int value);//
+    int isLineBeforePalette(int blockNumber);
+    int isLineAfterPalette(int blockNumber);
+    int removePalette(QQuickItem* palette);//
+    int resizePalette(QQuickItem* palette, int newHeight);//
+    std::list<QQuickItem *> updatePaletteBounds(int pos, int removed, int added);
+    std::list<QQuickItem *> deletedOnCollapse(int pos, int num);
+    bool isLineUnderPalette(int pos);
+    int totalOffset();//
+public Q_SLOTS:
+    void setDirtyPos(int pos);//
+    void lineNumberChange();//
+private:
+    int m_lineHeight;//
+    TextEdit *m_textEdit;//
+    std::list<PaletteData*> m_palettes;
+    int m_dirtyPos;//
+    int m_prevLineNumber;//
+    int m_lineNumber;//
+    int m_totalOffset;
+
+    void linesAdded();
+    void linesRemoved();
+    void adjustPalettePosition(PaletteData* pd);
+
+
+    friend class TextControl;
+    friend class LineSurface;
+};
+
+}
+
+#endif // PALETTEMANAGER_H
+*/
diff --git a/lib/lveditor/src/projectdocument.cpp b/lib/lveditor/src/projectdocument.cpp
index c16f8ab..e727410 100644
--- a/lib/lveditor/src/projectdocument.cpp
+++ b/lib/lveditor/src/projectdocument.cpp
@@ -570,7 +570,7 @@ void ProjectDocumentAction::redo(){
 //    parent->m_content.replace(position, charsRemoved.size(), charsAdded);
 }
 
-ProjectDocumentBlockData::ProjectDocumentBlockData() : m_collapseState(NoCollapse), m_numOfCollapsedLines(0)
+ProjectDocumentBlockData::ProjectDocumentBlockData() : m_numOfCollapsedLines(0)
     , m_stateChangeFlag(false) {}
 
 ProjectDocumentBlockData::~ProjectDocumentBlockData(){
@@ -675,9 +675,8 @@ void ProjectDocumentBlockData::removeSection(ProjectDocumentSection *section){
         section->m_parentBlock = nullptr;
 }
 
-void ProjectDocumentBlockData::setCollapse(CollapseState state, CollapseFunctionType func)
+void ProjectDocumentBlockData::setCollapse(CollapseFunctionType func)
 {
-    m_collapseState = state;
     m_onCollapse = func;
 
 }
@@ -692,14 +691,15 @@ void ProjectDocumentBlockData::setReplacementString(QString &repl)
     m_replacementString = repl;
 }
 
-ProjectDocumentBlockData::CollapseState ProjectDocumentBlockData::collapseState() { return m_collapseState; }
+// ProjectDocumentBlockData::CollapseState ProjectDocumentBlockData::collapseState() { return m_collapseState; }
 int ProjectDocumentBlockData::numOfCollapsedLines() { return m_numOfCollapsedLines; }
 CollapseFunctionType ProjectDocumentBlockData::onCollapse() { return m_onCollapse; }
 QString& ProjectDocumentBlockData::replacementString() { return m_replacementString; }
 
 void ProjectDocumentBlockData::resetCollapseParams()
 {
-	m_collapseState = NoCollapse;
+    // m_collapseState = NoCollapse;
+    m_collapsable = false;
 	m_replacementString = QString();
 
 }
diff --git a/lib/lveditor/src/projectdocument.h b/lib/lveditor/src/projectdocument.h
index 0ff8924..7e52392 100644
--- a/lib/lveditor/src/projectdocument.h
+++ b/lib/lveditor/src/projectdocument.h
@@ -1,485 +1,482 @@
-/****************************************************************************
-**
-** Copyright (C) 2014-2018 Dinu SV.
-** (contact: mail@dinusv.com)
-** This file is part of Live CV Application.
-**
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPLv3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl.html.
-**
-****************************************************************************/
-
-#ifndef LVPROJECTDOCUMENT_H
-#define LVPROJECTDOCUMENT_H
-
-#include <QObject>
-#include <QDateTime>
-#include <QLinkedList>
-#include <QAbstractUndoItem>
-#include <QTextBlockUserData>
-
-#include <functional>
-
-#include "live/lveditorglobal.h"
-
-#include <QDebug>
-
-namespace lv{
-
-class Project;
-class ProjectFile;
-class ProjectDocument;
-class ProjectDocumentBlockData;
-class DocumentHandler;
-
-class LV_EDITOR_EXPORT ProjectDocumentMarker{
-
-public:
-    friend class ProjectDocument;
-    /** Shared pointer to the marker */
-    typedef QSharedPointer<ProjectDocumentMarker>       Ptr;
-    /** Const shared pointer to the marker */
-    typedef QSharedPointer<const ProjectDocumentMarker> ConstPtr;
-
-public:
-    int position() const{ return m_position; }
-    bool isValid() const{ return m_position != -1; }
-    /** Create a ProjectDocumentMarker */
-    static Ptr create(){ return ProjectDocumentMarker::Ptr(new ProjectDocumentMarker); }
-    ~ProjectDocumentMarker(){}
-
-private:
-    ProjectDocumentMarker(int position = -1) : m_position(position){}
-    void invalidate(){m_position = -1;}
-
-private:
-    int m_position;
-};
-
-class LV_EDITOR_EXPORT ProjectDocumentSection{
-
-public:
-    friend class ProjectDocument;
-    friend class ProjectDocumentBlockData;
-    /** Shared pointer to a section */
-    typedef QSharedPointer<ProjectDocumentSection>       Ptr;
-    /** Const shared pointer to a section */
-    typedef QSharedPointer<const ProjectDocumentSection> ConstPtr;
-
-public:
-    int position() const{ return m_position; }
-    int length() const{ return m_length; }
-    int type() const{ return m_type; }
-    bool isValid() const{ return m_position != -1; }
-    void resize(int newLength){ m_length = newLength; }
-    ~ProjectDocumentSection();
-
-    void setUserData(void* data){ m_userData = data; }
-    void* userData(){ return m_userData; }
-
-    ProjectDocument* document(){ return m_document; }
-    ProjectDocumentBlockData* parentBlock(){ return m_parentBlock; }
-
-    void onTextChanged(std::function<void(ProjectDocumentSection::Ptr, int, int, const QString &)> handler);
-
-    /** Create a ProjectDocumentMarker with given parameters */
-    static Ptr create(int type, int position = -1, int length = 0){
-        return ProjectDocumentSection::Ptr(new ProjectDocumentSection(0, type, position, length));
-    }
-
-private:
-    ProjectDocumentSection(ProjectDocument* document, int type, int position = -1, int length = 0)
-        : m_document(document), m_type(type), m_position(position), m_length(length), m_userData(0), m_parentBlock(0)
-    {}
-    static Ptr create(ProjectDocument* document, int type, int position = -1, int length = 0){
-        return ProjectDocumentSection::Ptr(new ProjectDocumentSection(document, type, position, length));
-    }
-    void invalidate();
-
-private:
-    ProjectDocument* m_document;
-    int              m_type;
-    int              m_position;
-    int              m_length;
-    void*            m_userData;
-    ProjectDocumentBlockData* m_parentBlock;
-    std::function<void(ProjectDocumentSection::Ptr, int, int, const QString&)> m_textChangedHandler;
-};
-
-/**
-  \private
-*/
-class LV_EDITOR_EXPORT ProjectDocumentAction : public QAbstractUndoItem{
-
-public:
-    /** Default constructor */
-    ProjectDocumentAction(
-            ProjectDocument* pParent,
-            int pPosition,
-            const QString& pCharsAdded,
-            const QString& pCharsRemoved,
-            bool pCommited)
-        : parent(pParent)
-        , charsAdded(pCharsAdded)
-        , charsRemoved(pCharsRemoved)
-        , position(pPosition)
-        , commited(pCommited)
-    {
-    }
-
-    void undo();
-    void redo();
-
-    ProjectDocument* parent;
-
-    QString charsAdded;
-    QString charsRemoved;
-    int     position;
-    bool    commited;
-};
-
-typedef std::function<void(const QTextBlock& tb, int& numLines, QString& replacement)> CollapseFunctionType;
-
-/**
-  \private
-*/
-class LV_EDITOR_EXPORT ProjectDocumentBlockData : public QTextBlockUserData{
-
-public:
-    enum CollapseState {NoCollapse, Collapse, Expand};
-
-    ProjectDocumentBlockData();
-    ~ProjectDocumentBlockData();
-
-    void addSection(ProjectDocumentSection::Ptr section);
-    void removeSection(ProjectDocumentSection::Ptr section);
-    void removeSection(ProjectDocumentSection* section);
-
-    QLinkedList<ProjectDocumentSection::Ptr> m_sections;
-    QLinkedList<ProjectDocumentSection::Ptr> m_exceededSections;
-    QList<int> bracketPositions;
-    QString    blockIdentifier;
-
-    void setCollapse(CollapseState state, CollapseFunctionType func);
-    CollapseState collapseState();
-    void setReplacementString(QString& string);
-    QString &replacementString();
-    void setNumOfCollapsedLines(int num);
-    int numOfCollapsedLines();
-    CollapseFunctionType onCollapse();
-    void setStateChangeFlag(bool value) {m_stateChangeFlag = value; }
-    bool stateChangeFlag() {return m_stateChangeFlag; }
-    void collapse() {m_collapseState = Expand;  }
-    void expand() { m_collapseState = Collapse; }
-
-    void resetCollapseParams();
-
-private:
-    CollapseState m_collapseState;
-    QString m_replacementString;
-    int m_numOfCollapsedLines;
-    CollapseFunctionType m_onCollapse;
-    bool m_stateChangeFlag;
-};
-
-
-class LV_EDITOR_EXPORT ProjectDocument : public QObject{
-
-    Q_OBJECT
-    Q_PROPERTY(lv::ProjectFile* file  READ file        NOTIFY fileChanged)
-    Q_PROPERTY(QString content        READ content     NOTIFY contentChanged)
-    Q_PROPERTY(bool isMonitored       READ isMonitored NOTIFY isMonitoredChanged)
-    Q_PROPERTY(bool isDirty           READ isDirty     WRITE  setIsDirty     NOTIFY isDirtyChanged)
-    Q_ENUMS(OpenMode)
-
-public:
-    /** Iterator through sections */
-    typedef QLinkedList<ProjectDocumentSection::Ptr>::iterator       SectionIterator;
-    /** Const iterator through sections */
-    typedef QLinkedList<ProjectDocumentSection::Ptr>::const_iterator SectionConstIterator;
-
-    friend class ProjectDocumentAction;
-    friend class ProjectDocumentMarker;
-    friend class ProjectDocumentSection;
-
-    /** Enum containing possible modes of opening documents */
-    enum OpenMode{
-        /** The file open in the editor */
-        Edit = 0,
-        /** Read-only, but any external change will be reflected */
-        Monitor,
-        /** If not opened, will be open for editing. If already monitored, it will not be available for editing. */
-        EditIfNotOpen
-    };
-
-    /** Editing states of an opened document */
-    enum EditingState{
-        /**     0 : coming from the user */
-        Manual   = 0,
-        /**     1 : coming from a code completion assistant */
-        Assisted = 1,
-        /**    10 : does not trigger a recompile */
-        Silent   = 2,
-        /**   110 : also silent (when a palette edits a section) */
-        Palette  = 6,
-        /**  1010 : also silent (comming from a runtime binding) */
-        Runtime  = 10,
-        /** 10000 : populate from file, does not signal anything */
-        Read     = 16
-    };
-
-public:
-    explicit ProjectDocument(ProjectFile* file, bool isMonitored, Project *parent);
-
-    ~ProjectDocument();
-
-    /** \brief File getter */
-    lv::ProjectFile* file() const;
-
-    /**
-     * \brief Returns document content
-     */
-    QString content() const;
-
-    void setIsDirty(bool isDirty);
-
-    bool isDirty() const;
-
-    void setIsMonitored(bool isMonitored);
-    /**
-     * \brief Shows if the document is monitored
-     */
-    bool isMonitored() const;
-
-    const QDateTime& lastModified() const;
-    void setLastModified(const QDateTime& lastModified);
-
-    Project* parentAsProject();
-
-    QTextDocument* textDocument();
-
-    ProjectDocumentMarker::Ptr addMarker(int position);
-    void removeMarker(ProjectDocumentMarker::Ptr marker);
-
-    ProjectDocumentSection::Ptr createSection(int type, int position, int length);
-    SectionIterator sectionsBegin();
-    SectionIterator sectionsEnd();
-    SectionConstIterator sectionsBegin() const;
-    SectionConstIterator sectionsEnd() const;
-    int totalSections() const;
-    bool hasSections() const;
-    ProjectDocumentSection::Ptr sectionAt(int position);
-    bool removeSectionAt(int position);
-    void removeSection(ProjectDocumentSection::Ptr section);
-
-    bool isActive() const;
-
-    QString peekContent(int position) const;
-
-    void addEditingState(EditingState type);
-    void removeEditingState(EditingState state);
-    bool editingStateIs(int flag) const;
-    void resetEditingState();
-
-public slots:
-    void documentContentsChanged(int position, int charsRemoved, int charsAdded);
-    void setContent(const QString& content);
-    void readContent();
-    bool save();
-    bool saveAs(const QString& path);
-    bool saveAs(const QUrl& url);
-
-signals:
-    /** shows dirty state changed */
-    void isDirtyChanged();
-    /** shows if monitoring state changed */
-    void isMonitoredChanged();
-    /** shows if the file changed */
-    void fileChanged();
-    /** shows if the document content changed */
-    void contentChanged();
-    /** shows if the format changed */
-    void formatChanged(int position, int length);
-
-private:
-    void syncContent() const;
-    void resetSync() const;
-    void updateSections(int position, int charsRemoved, const QString& addedText);
-    void updateMarkers(int position, int charsRemoved, int addedText);
-    void updateSectionBlocks(int position, const QString& addedText);
-    QString getCharsRemoved(int position, int count);
-
-    ProjectFile*    m_file;
-    QDateTime       m_lastModified;
-
-    QTextDocument*   m_textDocument;
-
-    QLinkedList<ProjectDocumentSection::Ptr> m_sections;
-    QLinkedList<ProjectDocumentMarker::Ptr>  m_markers;
-
-    QLinkedList<ProjectDocumentSection::Ptr> m_sectionsToRemove;
-    bool                                     m_iteratingSections;
-
-    QLinkedList<ProjectDocumentAction>      m_changes;
-    mutable QLinkedList<ProjectDocumentAction>::iterator m_lastChange;
-
-    mutable int   m_editingState;
-    bool          m_isDirty;
-    mutable bool  m_isSynced;
-    bool          m_isMonitored;
-};
-
-/**
- * \brief File getter
- */
-inline ProjectFile *ProjectDocument::file() const{
-    return m_file;
-}
-
-inline QString ProjectDocument::content() const{
-    syncContent();
-    return m_textDocument->toPlainText();
-}
-
-/**
- * \brief Sets the "dirty" indicator
- */
-inline void ProjectDocument::setIsDirty(bool isDirty){
-    if ( m_isDirty == isDirty )
-        return;
-
-    m_isDirty = isDirty;
-    isDirtyChanged();
-}
-
-inline bool ProjectDocument::isDirty() const{
-    return m_isDirty;
-}
-
-/**
- * \brief Sets the indicator for monitoring
- */
-inline void ProjectDocument::setIsMonitored(bool isMonitored){
-    if ( m_isMonitored == isMonitored )
-        return;
-
-    m_isMonitored = isMonitored;
-    emit isMonitoredChanged();
-}
-
-
-inline bool ProjectDocument::isMonitored() const{
-    return m_isMonitored;
-}
-
-/**
- * \brief Returns the timestamp of last modification
- */
-inline const QDateTime &ProjectDocument::lastModified() const{
-    return m_lastModified;
-}
-
-/**
- * \brief Sets the timestamp of latest modification
- */
-inline void ProjectDocument::setLastModified(const QDateTime &lastModified){
-    m_lastModified = lastModified;
-}
-
-/**
- * \brief Begin-iterator of the sections
- */
-inline ProjectDocument::SectionIterator ProjectDocument::sectionsBegin(){
-    return m_sections.begin();
-}
-
-/**
- * \brief End-iterator of the sections
- */
-inline ProjectDocument::SectionIterator ProjectDocument::sectionsEnd(){
-    return m_sections.end();
-}
-
-
-/**
- * \brief Const begin-iterator of the sections
- */
-inline ProjectDocument::SectionConstIterator ProjectDocument::sectionsBegin() const{
-    return m_sections.begin();
-}
-
-
-/**
- * \brief Const end-iterator of the sections
- */
-inline ProjectDocument::SectionConstIterator ProjectDocument::sectionsEnd() const{
-    return m_sections.end();
-}
-
-/**
- * \brief Number of sections
- */
-inline int ProjectDocument::totalSections() const{
-    return m_sections.size();
-}
-
-/**
- * \brief Shows if the object has any sections
- */
-inline bool ProjectDocument::hasSections() const{
-    return totalSections() > 0;
-}
-
-inline void ProjectDocument::resetSync() const{
-    m_isSynced = false;
-}
-
-/**
- * \brief Text document which is wrapped inside the ProjectDocument
- */
-inline QTextDocument *ProjectDocument::textDocument(){
-    return m_textDocument;
-}
-
-/**
- * \brief Adds editing state flag
- */
-inline void ProjectDocument::addEditingState(EditingState state){
-    m_editingState |= state;
-}
-
-/**
- * \brief Removes the given editing state flag
- */
-inline void ProjectDocument::removeEditingState(EditingState state){
-    if ( m_editingState & state ){
-        bool restoreSilent = editingStateIs(ProjectDocument::Palette | ProjectDocument::Runtime);
-        m_editingState = m_editingState & ~state;
-        if ( restoreSilent ){
-            m_editingState |= ProjectDocument::Silent;
-        }
-    }
-}
-
-/**
- * \brief Shows if the editing state includes the given flags
- */
-inline bool ProjectDocument::editingStateIs(int flag) const{
-    return (flag & m_editingState) == flag;
-}
-
-/**
- * \brief Resets all of the editing state flags
- */
-inline void ProjectDocument::resetEditingState(){
-    m_editingState = 0;
-}
-
-}// namespace
-
-#endif // LVPROJECTDOCUMENT_H
+/****************************************************************************
+**
+** Copyright (C) 2014-2018 Dinu SV.
+** (contact: mail@dinusv.com)
+** This file is part of Live CV Application.
+**
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPLv3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl.html.
+**
+****************************************************************************/
+
+#ifndef LVPROJECTDOCUMENT_H
+#define LVPROJECTDOCUMENT_H
+
+#include <QObject>
+#include <QDateTime>
+#include <QLinkedList>
+#include <QAbstractUndoItem>
+#include <QTextBlockUserData>
+
+#include <functional>
+
+#include "live/lveditorglobal.h"
+
+#include <QDebug>
+
+namespace lv{
+
+class Project;
+class ProjectFile;
+class ProjectDocument;
+class ProjectDocumentBlockData;
+class DocumentHandler;
+
+class LV_EDITOR_EXPORT ProjectDocumentMarker{
+
+public:
+    friend class ProjectDocument;
+    /** Shared pointer to the marker */
+    typedef QSharedPointer<ProjectDocumentMarker>       Ptr;
+    /** Const shared pointer to the marker */
+    typedef QSharedPointer<const ProjectDocumentMarker> ConstPtr;
+
+public:
+    int position() const{ return m_position; }
+    bool isValid() const{ return m_position != -1; }
+    /** Create a ProjectDocumentMarker */
+    static Ptr create(){ return ProjectDocumentMarker::Ptr(new ProjectDocumentMarker); }
+    ~ProjectDocumentMarker(){}
+
+private:
+    ProjectDocumentMarker(int position = -1) : m_position(position){}
+    void invalidate(){m_position = -1;}
+
+private:
+    int m_position;
+};
+
+class LV_EDITOR_EXPORT ProjectDocumentSection{
+
+public:
+    friend class ProjectDocument;
+    friend class ProjectDocumentBlockData;
+    /** Shared pointer to a section */
+    typedef QSharedPointer<ProjectDocumentSection>       Ptr;
+    /** Const shared pointer to a section */
+    typedef QSharedPointer<const ProjectDocumentSection> ConstPtr;
+
+public:
+    int position() const{ return m_position; }
+    int length() const{ return m_length; }
+    int type() const{ return m_type; }
+    bool isValid() const{ return m_position != -1; }
+    void resize(int newLength){ m_length = newLength; }
+    ~ProjectDocumentSection();
+
+    void setUserData(void* data){ m_userData = data; }
+    void* userData(){ return m_userData; }
+
+    ProjectDocument* document(){ return m_document; }
+    ProjectDocumentBlockData* parentBlock(){ return m_parentBlock; }
+
+    void onTextChanged(std::function<void(ProjectDocumentSection::Ptr, int, int, const QString &)> handler);
+
+    /** Create a ProjectDocumentMarker with given parameters */
+    static Ptr create(int type, int position = -1, int length = 0){
+        return ProjectDocumentSection::Ptr(new ProjectDocumentSection(0, type, position, length));
+    }
+
+private:
+    ProjectDocumentSection(ProjectDocument* document, int type, int position = -1, int length = 0)
+        : m_document(document), m_type(type), m_position(position), m_length(length), m_userData(0), m_parentBlock(0)
+    {}
+    static Ptr create(ProjectDocument* document, int type, int position = -1, int length = 0){
+        return ProjectDocumentSection::Ptr(new ProjectDocumentSection(document, type, position, length));
+    }
+    void invalidate();
+
+private:
+    ProjectDocument* m_document;
+    int              m_type;
+    int              m_position;
+    int              m_length;
+    void*            m_userData;
+    ProjectDocumentBlockData* m_parentBlock;
+    std::function<void(ProjectDocumentSection::Ptr, int, int, const QString&)> m_textChangedHandler;
+};
+
+/**
+  \private
+*/
+class LV_EDITOR_EXPORT ProjectDocumentAction : public QAbstractUndoItem{
+
+public:
+    /** Default constructor */
+    ProjectDocumentAction(
+            ProjectDocument* pParent,
+            int pPosition,
+            const QString& pCharsAdded,
+            const QString& pCharsRemoved,
+            bool pCommited)
+        : parent(pParent)
+        , charsAdded(pCharsAdded)
+        , charsRemoved(pCharsRemoved)
+        , position(pPosition)
+        , commited(pCommited)
+    {
+    }
+
+    void undo();
+    void redo();
+
+    ProjectDocument* parent;
+
+    QString charsAdded;
+    QString charsRemoved;
+    int     position;
+    bool    commited;
+};
+
+typedef std::function<void(const QTextBlock& tb, int& numLines, QString& replacement)> CollapseFunctionType;
+
+/**
+  \private
+*/
+class LV_EDITOR_EXPORT ProjectDocumentBlockData : public QTextBlockUserData{
+
+public:
+
+    ProjectDocumentBlockData();
+    ~ProjectDocumentBlockData();
+
+    void addSection(ProjectDocumentSection::Ptr section);
+    void removeSection(ProjectDocumentSection::Ptr section);
+    void removeSection(ProjectDocumentSection* section);
+
+    QLinkedList<ProjectDocumentSection::Ptr> m_sections;
+    QLinkedList<ProjectDocumentSection::Ptr> m_exceededSections;
+    QList<int> bracketPositions;
+    QString    blockIdentifier;
+
+    void setCollapse(CollapseFunctionType func);
+    void setReplacementString(QString& string);
+    QString &replacementString();
+    void setNumOfCollapsedLines(int num);
+    int numOfCollapsedLines();
+    CollapseFunctionType onCollapse();
+    void setStateChangeFlag(bool value) {m_stateChangeFlag = value; }
+    bool stateChangeFlag() {return m_stateChangeFlag; }
+    bool isCollapsible() { return m_collapsable; }
+    void setCollapsible(bool col) { m_collapsable = col; }
+    void resetCollapseParams();
+
+private:
+    QString m_replacementString;
+    int m_numOfCollapsedLines;
+    CollapseFunctionType m_onCollapse;
+    bool m_stateChangeFlag;
+    bool m_collapsable;
+};
+
+
+class LV_EDITOR_EXPORT ProjectDocument : public QObject{
+
+    Q_OBJECT
+    Q_PROPERTY(lv::ProjectFile* file  READ file        NOTIFY fileChanged)
+    Q_PROPERTY(QString content        READ content     NOTIFY contentChanged)
+    Q_PROPERTY(bool isMonitored       READ isMonitored NOTIFY isMonitoredChanged)
+    Q_PROPERTY(bool isDirty           READ isDirty     WRITE  setIsDirty     NOTIFY isDirtyChanged)
+    Q_ENUMS(OpenMode)
+
+public:
+    /** Iterator through sections */
+    typedef QLinkedList<ProjectDocumentSection::Ptr>::iterator       SectionIterator;
+    /** Const iterator through sections */
+    typedef QLinkedList<ProjectDocumentSection::Ptr>::const_iterator SectionConstIterator;
+
+    friend class ProjectDocumentAction;
+    friend class ProjectDocumentMarker;
+    friend class ProjectDocumentSection;
+
+    /** Enum containing possible modes of opening documents */
+    enum OpenMode{
+        /** The file open in the editor */
+        Edit = 0,
+        /** Read-only, but any external change will be reflected */
+        Monitor,
+        /** If not opened, will be open for editing. If already monitored, it will not be available for editing. */
+        EditIfNotOpen
+    };
+
+    /** Editing states of an opened document */
+    enum EditingState{
+        /**     0 : coming from the user */
+        Manual   = 0,
+        /**     1 : coming from a code completion assistant */
+        Assisted = 1,
+        /**    10 : does not trigger a recompile */
+        Silent   = 2,
+        /**   110 : also silent (when a palette edits a section) */
+        Palette  = 6,
+        /**  1010 : also silent (comming from a runtime binding) */
+        Runtime  = 10,
+        /** 10000 : populate from file, does not signal anything */
+        Read     = 16
+    };
+
+public:
+    explicit ProjectDocument(ProjectFile* file, bool isMonitored, Project *parent);
+
+    ~ProjectDocument();
+
+    /** \brief File getter */
+    lv::ProjectFile* file() const;
+
+    /**
+     * \brief Returns document content
+     */
+    QString content() const;
+
+    void setIsDirty(bool isDirty);
+
+    bool isDirty() const;
+
+    void setIsMonitored(bool isMonitored);
+    /**
+     * \brief Shows if the document is monitored
+     */
+    bool isMonitored() const;
+
+    const QDateTime& lastModified() const;
+    void setLastModified(const QDateTime& lastModified);
+
+    Project* parentAsProject();
+
+    QTextDocument* textDocument();
+
+    ProjectDocumentMarker::Ptr addMarker(int position);
+    void removeMarker(ProjectDocumentMarker::Ptr marker);
+
+    ProjectDocumentSection::Ptr createSection(int type, int position, int length);
+    SectionIterator sectionsBegin();
+    SectionIterator sectionsEnd();
+    SectionConstIterator sectionsBegin() const;
+    SectionConstIterator sectionsEnd() const;
+    int totalSections() const;
+    bool hasSections() const;
+    ProjectDocumentSection::Ptr sectionAt(int position);
+    bool removeSectionAt(int position);
+    void removeSection(ProjectDocumentSection::Ptr section);
+
+    bool isActive() const;
+
+    QString peekContent(int position) const;
+
+    void addEditingState(EditingState type);
+    void removeEditingState(EditingState state);
+    bool editingStateIs(int flag) const;
+    void resetEditingState();
+
+public slots:
+    void documentContentsChanged(int position, int charsRemoved, int charsAdded);
+    void setContent(const QString& content);
+    void readContent();
+    bool save();
+    bool saveAs(const QString& path);
+    bool saveAs(const QUrl& url);
+
+signals:
+    /** shows dirty state changed */
+    void isDirtyChanged();
+    /** shows if monitoring state changed */
+    void isMonitoredChanged();
+    /** shows if the file changed */
+    void fileChanged();
+    /** shows if the document content changed */
+    void contentChanged();
+    /** shows if the format changed */
+    void formatChanged(int position, int length);
+
+private:
+    void syncContent() const;
+    void resetSync() const;
+    void updateSections(int position, int charsRemoved, const QString& addedText);
+    void updateMarkers(int position, int charsRemoved, int addedText);
+    void updateSectionBlocks(int position, const QString& addedText);
+    QString getCharsRemoved(int position, int count);
+
+    ProjectFile*    m_file;
+    QDateTime       m_lastModified;
+
+    QTextDocument*   m_textDocument;
+
+    QLinkedList<ProjectDocumentSection::Ptr> m_sections;
+    QLinkedList<ProjectDocumentMarker::Ptr>  m_markers;
+
+    QLinkedList<ProjectDocumentSection::Ptr> m_sectionsToRemove;
+    bool                                     m_iteratingSections;
+
+    QLinkedList<ProjectDocumentAction>      m_changes;
+    mutable QLinkedList<ProjectDocumentAction>::iterator m_lastChange;
+
+    mutable int   m_editingState;
+    bool          m_isDirty;
+    mutable bool  m_isSynced;
+    bool          m_isMonitored;
+};
+
+/**
+ * \brief File getter
+ */
+inline ProjectFile *ProjectDocument::file() const{
+    return m_file;
+}
+
+inline QString ProjectDocument::content() const{
+    syncContent();
+    return m_textDocument->toPlainText();
+}
+
+/**
+ * \brief Sets the "dirty" indicator
+ */
+inline void ProjectDocument::setIsDirty(bool isDirty){
+    if ( m_isDirty == isDirty )
+        return;
+
+    m_isDirty = isDirty;
+    isDirtyChanged();
+}
+
+inline bool ProjectDocument::isDirty() const{
+    return m_isDirty;
+}
+
+/**
+ * \brief Sets the indicator for monitoring
+ */
+inline void ProjectDocument::setIsMonitored(bool isMonitored){
+    if ( m_isMonitored == isMonitored )
+        return;
+
+    m_isMonitored = isMonitored;
+    emit isMonitoredChanged();
+}
+
+
+inline bool ProjectDocument::isMonitored() const{
+    return m_isMonitored;
+}
+
+/**
+ * \brief Returns the timestamp of last modification
+ */
+inline const QDateTime &ProjectDocument::lastModified() const{
+    return m_lastModified;
+}
+
+/**
+ * \brief Sets the timestamp of latest modification
+ */
+inline void ProjectDocument::setLastModified(const QDateTime &lastModified){
+    m_lastModified = lastModified;
+}
+
+/**
+ * \brief Begin-iterator of the sections
+ */
+inline ProjectDocument::SectionIterator ProjectDocument::sectionsBegin(){
+    return m_sections.begin();
+}
+
+/**
+ * \brief End-iterator of the sections
+ */
+inline ProjectDocument::SectionIterator ProjectDocument::sectionsEnd(){
+    return m_sections.end();
+}
+
+
+/**
+ * \brief Const begin-iterator of the sections
+ */
+inline ProjectDocument::SectionConstIterator ProjectDocument::sectionsBegin() const{
+    return m_sections.begin();
+}
+
+
+/**
+ * \brief Const end-iterator of the sections
+ */
+inline ProjectDocument::SectionConstIterator ProjectDocument::sectionsEnd() const{
+    return m_sections.end();
+}
+
+/**
+ * \brief Number of sections
+ */
+inline int ProjectDocument::totalSections() const{
+    return m_sections.size();
+}
+
+/**
+ * \brief Shows if the object has any sections
+ */
+inline bool ProjectDocument::hasSections() const{
+    return totalSections() > 0;
+}
+
+inline void ProjectDocument::resetSync() const{
+    m_isSynced = false;
+}
+
+/**
+ * \brief Text document which is wrapped inside the ProjectDocument
+ */
+inline QTextDocument *ProjectDocument::textDocument(){
+    return m_textDocument;
+}
+
+/**
+ * \brief Adds editing state flag
+ */
+inline void ProjectDocument::addEditingState(EditingState state){
+    m_editingState |= state;
+}
+
+/**
+ * \brief Removes the given editing state flag
+ */
+inline void ProjectDocument::removeEditingState(EditingState state){
+    if ( m_editingState & state ){
+        bool restoreSilent = editingStateIs(ProjectDocument::Palette | ProjectDocument::Runtime);
+        m_editingState = m_editingState & ~state;
+        if ( restoreSilent ){
+            m_editingState |= ProjectDocument::Silent;
+        }
+    }
+}
+
+/**
+ * \brief Shows if the editing state includes the given flags
+ */
+inline bool ProjectDocument::editingStateIs(int flag) const{
+    return (flag & m_editingState) == flag;
+}
+
+/**
+ * \brief Resets all of the editing state flags
+ */
+inline void ProjectDocument::resetEditingState(){
+    m_editingState = 0;
+}
+
+}// namespace
+
+#endif // LVPROJECTDOCUMENT_H
diff --git a/lib/lveditor/src/texteditnodedebugmodel.cpp b/lib/lveditor/src/texteditnodedebugmodel.cpp
new file mode 100644
index 0000000..bde443a
--- /dev/null
+++ b/lib/lveditor/src/texteditnodedebugmodel.cpp
@@ -0,0 +1,67 @@
+#include "texteditnodedebugmodel.h"
+#include "textedit_p.h"
+
+#ifdef LV_EDITOR_DEBUG
+
+
+namespace lv {
+
+TextEditNodeDebugModel::TextEditNodeDebugModel(TextEdit* parent):
+    QAbstractListModel(parent), m_parentTextEdit(parent), m_size(0)
+{
+    m_roles[TextEditNodeDebugModel::BlockNumber]        = "blockNumber";
+    m_roles[TextEditNodeDebugModel::LineText]           = "lineText";
+    m_roles[TextEditNodeDebugModel::BlockText]          = "blockText";
+    m_roles[TextEditNodeDebugModel::HiddenByCollapse]   = "hiddenByCollapse";
+    m_roles[TextEditNodeDebugModel::HiddenByPalette]    = "hiddenByPalette";
+    m_roles[TextEditNodeDebugModel::Offset]             = "offset";
+}
+
+QVariant TextEditNodeDebugModel::data(const QModelIndex &index, int role) const
+{
+    unsigned row = static_cast<unsigned>(index.row());
+
+    switch (role)
+    {
+    case TextEditNodeDebugModel::BlockNumber:
+        return m_entries[row].m_blockNumber;
+    case TextEditNodeDebugModel::LineText:
+        return m_entries[row].m_lineText;
+    case TextEditNodeDebugModel::BlockText:
+        return m_entries[row].m_blockText;
+    case TextEditNodeDebugModel::HiddenByCollapse:
+        return m_entries[row].m_hiddenByCollapse;
+    case TextEditNodeDebugModel::HiddenByPalette:
+        return m_entries[row].m_hiddenByPalette;
+    case TextEditNodeDebugModel::Offset:
+        return m_entries[row].m_offset;
+    default:
+        return QVariant();
+    }
+}
+
+void TextEditNodeDebugModel::updateModel(int pos, int size)
+{
+    if (pos < m_entries.size())
+    {
+        beginRemoveRows(QModelIndex(), pos, m_entries.size()-1);
+        endRemoveRows();
+    }
+    m_size = pos;
+
+    if (size != m_entries.size())
+        m_entries.resize(size);
+
+    beginInsertRows(QModelIndex(), pos, size-1);
+    for (int i = pos; i < size; ++i)
+    {
+        m_entries[i] = m_parentTextEdit->getDebugEntry(i);
+    }
+    endInsertRows();
+
+    m_size = size;
+}
+
+} // namespace
+
+#endif
diff --git a/lib/lveditor/src/texteditnodedebugmodel.h b/lib/lveditor/src/texteditnodedebugmodel.h
new file mode 100644
index 0000000..5e45fe8
--- /dev/null
+++ b/lib/lveditor/src/texteditnodedebugmodel.h
@@ -0,0 +1,82 @@
+#ifndef TEXTEDITNODEDEBUGMODEL_H
+#define TEXTEDITNODEDEBUGMODEL_H
+
+#include "qabstractitemmodel.h"
+
+#include "lveditorglobal.h"
+
+#ifdef LV_EDITOR_DEBUG
+
+namespace lv {
+
+class TextEdit;
+
+class TextEditNodeDebugModel : public QAbstractListModel
+{
+    Q_OBJECT
+
+public:
+    enum Roles{
+        BlockNumber = Qt::UserRole + 1,
+        LineText,
+        BlockText,
+        HiddenByCollapse,
+        HiddenByPalette,
+        Offset
+    };
+
+    class Entry{
+    public:
+        Entry(int bn, QString lt, QString bt, bool col = false, bool pal = false, int off = 0):
+            m_blockNumber(bn), m_lineText(lt), m_blockText(bt), m_hiddenByCollapse(col),
+            m_hiddenByPalette(pal), m_offset(off) {}
+
+        Entry() : Entry(0, "", "") {}
+        QString toString(){
+            std::string s = std::to_string(m_blockNumber) + " "
+                    + m_lineText.toStdString() + " "
+                    + m_blockText.toStdString() + " "
+                    + (m_hiddenByCollapse ? "true " : "false ")
+                    + (m_hiddenByPalette ? "true " : "false ")
+                    + std::to_string(m_offset);
+
+            return QString(s.c_str());
+        }
+
+        int m_blockNumber;
+        QString m_lineText;
+        QString m_blockText;
+        bool m_hiddenByCollapse;
+        bool m_hiddenByPalette;
+        int m_offset;
+    };
+
+    TextEditNodeDebugModel(TextEdit* parent=nullptr);
+
+
+    QHash<int, QByteArray> roleNames() const;
+    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const;
+    int rowCount(const QModelIndex &parent = QModelIndex()) const;
+
+    void updateModel(int pos, int size);
+private:
+    TextEdit* m_parentTextEdit;
+    std::vector<Entry> m_entries;
+    unsigned m_size;
+    QHash<int, QByteArray> m_roles;
+};
+
+inline QHash<int, QByteArray> TextEditNodeDebugModel::roleNames() const{
+    return m_roles;
+}
+
+inline int TextEditNodeDebugModel::rowCount(const QModelIndex &parent) const {
+    Q_UNUSED(parent)
+    return static_cast<int>(m_size);
+}
+
+} // namespace
+
+#endif // TEXTEDITNODEDEBUGMODEL_H
+
+#endif
diff --git a/lib/lveditqmljs/src/codeqmlhandler.cpp b/lib/lveditqmljs/src/codeqmlhandler.cpp
index a1829af..157e55c 100644
--- a/lib/lveditqmljs/src/codeqmlhandler.cpp
+++ b/lib/lveditqmljs/src/codeqmlhandler.cpp
@@ -722,7 +722,6 @@ CodeQmlHandler::CodeQmlHandler(
  */
 CodeQmlHandler::~CodeQmlHandler(){
     Q_D(CodeQmlHandler);
-    cancelEdit();
 
     if ( d->projectHandler ){
         d->projectHandler->removeCodeQmlHandler(this);
@@ -894,16 +893,6 @@ void CodeQmlHandler::setDocument(ProjectDocument *document){
     m_highlighter->setTarget(m_target);
     d->documentScope = DocumentQmlScope::createEmptyScope(d->projectHandler->scanMonitor()->projectScope());
 
-    if ( m_document ){
-        auto it = m_edits.begin();
-        while( it != m_edits.end() ){
-            QmlEditFragment* edit = *it;
-            it = m_edits.erase(it);
-            edit->emitRemoval();
-            edit->deleteLater();
-        }
-    }
-
     if ( d->projectHandler->scanMonitor()->hasProjectScope() && document != 0 ){
         d->projectHandler->scanMonitor()->scanNewDocumentScope(document->file()->path(), document->content(), this);
         d->projectHandler->scanner()->queueProjectScan();
@@ -1198,6 +1187,21 @@ QPair<int, int> CodeQmlHandler::contextBlock(int position){
     return QPair<int, int>(start, end);
 }
 
+void CodeQmlHandler::aboutToDelete()
+{
+    cancelEdit();
+
+    if ( m_document ){
+        auto it = m_edits.begin();
+        while( it != m_edits.end() ){
+            QmlEditFragment* edit = *it;
+            it = m_edits.erase(it);
+            edit->emitRemoval();
+            edit->deleteLater();
+        }
+    }
+}
+
 /**
  * \brief Adds an editing fragment to the current document
  */
@@ -1585,27 +1589,28 @@ void CodeQmlHandler::frameEdit(QQuickItem *box, lv::QmlEditFragment *edit){
     if (!edit)
         return;
 
-    connect(box, &QQuickItem::heightChanged, [this, box](){
-        resizedEditFrame(box);
+    DocumentHandler* dh = static_cast<DocumentHandler*>(parent());
+
+    // add stuff
+    connect(box, &QQuickItem::heightChanged, [dh, box](){
+        dh->lineBoxResized(box, box->height());
     });
 
 
-    connect(box, &QQuickItem::destroyed, [this, box](){
-        removeEditFrame(box);
+    connect(box, &QQuickItem::destroyed, [dh, box](){
+        dh->lineBoxRemoved(box);
     });
 
     int pos = edit->declaration()->position();
     QTextBlock tb = m_document->textDocument()->findBlock(pos);
     QTextBlock tbend = m_document->textDocument()->findBlock(pos + edit->declaration()->length());
 
-    DocumentHandler* dh = static_cast<DocumentHandler*>(parent());
     dh->lineBoxAdded(tb.blockNumber() + 1, tbend.blockNumber() + 1, box->height(), box);
 }
 
 void CodeQmlHandler::removeEditFrame(QQuickItem *box)
 {
-    DocumentHandler* dh = static_cast<DocumentHandler*>(parent());
-    dh->lineBoxRemoved(box);
+    static_cast<DocumentHandler*>(box->parent())->lineBoxRemoved(box);
 }
 
 void CodeQmlHandler::resizedEditFrame(QQuickItem *box)
diff --git a/lib/lveditqmljs/src/codeqmlhandler.h b/lib/lveditqmljs/src/codeqmlhandler.h
index e5687a7..32e2319 100644
--- a/lib/lveditqmljs/src/codeqmlhandler.h
+++ b/lib/lveditqmljs/src/codeqmlhandler.h
@@ -1,232 +1,233 @@
-/****************************************************************************
-**
-** Copyright (C) 2014-2018 Dinu SV.
-** (contact: mail@dinusv.com)
-** This file is part of Live CV Application.
-**
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPLv3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl.html.
-**
-****************************************************************************/
-
-#ifndef LVCODEQMLHANDLER_H
-#define LVCODEQMLHANDLER_H
-
-#include "live/lveditqmljsglobal.h"
-#include "live/abstractcodehandler.h"
-#include "live/projectdocument.h"
-#include "live/documentqmlscope.h"
-#include "live/projectqmlscope.h"
-#include "live/qmldeclaration.h"
-#include "live/lockedfileiosession.h"
-#include "live/viewengine.h"
-#include "live/settings.h"
-#include "live/palettelist.h"
-
-#include <QTimer>
-#include <QTextCursor>
-#include <QQmlListProperty>
-
-class QQmlEngine;
-
-namespace lv{
-
-class ProjectQmlScanner;
-class ProjectQmlExtension;
-class PluginInfoExtractor;
-
-class QmlCursorInfo;
-class QmlEditFragment;
-class QmlJsHighlighter;
-class QmlJsSettings;
-class QmlAddContainer;
-class QmlCompletionContextFinder;
-class QmlCompletionContext;
-
-class CodeQmlHandlerPrivate;
-class LV_EDITQMLJS_EXPORT CodeQmlHandler : public AbstractCodeHandler{
-
-    Q_OBJECT
-    Q_DISABLE_COPY(CodeQmlHandler)
-
-    friend class ProjectQmlExtension;
-
-public:
-    explicit CodeQmlHandler(
-        ViewEngine* engine,
-        Project* project,
-        QmlJsSettings *settings,
-        ProjectQmlExtension* projectHandler,
-        DocumentHandler* handler = 0
-    );
-    ~CodeQmlHandler();
-
-    void assistCompletion(
-        const QTextCursor& cursor,
-        const QChar& insertion,
-        bool manuallyTriggered,
-        CodeCompletionModel* model,
-        QTextCursor& cursorChange
-    ) Q_DECL_OVERRIDE;
-    void setDocument(ProjectDocument* document) Q_DECL_OVERRIDE;
-    AbstractCodeHandler::ContentsTrigger documentContentsChanged(int position, int charsRemoved, int charsAdded) Q_DECL_OVERRIDE;
-    void rehighlightBlock(const QTextBlock& block) Q_DECL_OVERRIDE;
-    QPair<int, int> contextBlock(int position) Q_DECL_OVERRIDE;
-
-    QList<lv::QmlDeclaration::Ptr> getDeclarations(const QTextCursor& cursor);
-    bool findDeclarationValue(int position, int length, int& valuePosition, int& valueEnd);
-    QmlEditFragment* createInjectionChannel(QmlDeclaration::Ptr property, QObject* runtime);
-
-    bool addEditingFragment(QmlEditFragment *edit);
-    void removeEditingFragment(QmlEditFragment* edit);
-
-    QmlJsSettings* settings();
-
-    QmlEditFragment* findEditFragment(CodePalette* palette);
-    QmlEditFragment* findEditFragmentIn(QmlEditFragment *parent, CodePalette* palette);
-
-public slots:
-    // Palette and binding management
-
-    lv::QmlCursorInfo* cursorInfo(int position, int length);
-    lv::QmlEditFragment* openConnection(int position, QObject *currentApp = nullptr);
-    lv::QmlEditFragment* openNestedConnection(lv::QmlEditFragment* edit, int position, QObject* currentApp = nullptr);
-    void removeConnection(lv::QmlEditFragment* edit);
-
-    lv::PaletteList *findPalettes(int position, bool unrepeated = false);
-    lv::CodePalette* openPalette(lv::QmlEditFragment* fragment, lv::PaletteList* palette, int index);
-    lv::QmlEditFragment* removePalette(lv::CodePalette* palette);
-
-    lv::CodePalette* openBinding(lv::QmlEditFragment* edit, lv::PaletteList* paletteList, int index);
-    void closeBinding(int position, int length);
-
-    bool isForAnObject(lv::QmlEditFragment* palette);
-
-    void frameEdit(QQuickItem *box, lv::QmlEditFragment* palette);
-    void removeEditFrame(QQuickItem* box);
-    void resizedEditFrame(QQuickItem* box);
-
-    // Direct editing management
-
-    lv::CodePalette *edit(lv::QmlEditFragment* ef);
-    void cancelEdit();
-
-    // Add Property Management
-
-    lv::QmlAddContainer* getAddOptions(int position);
-    int addProperty(
-        int position,
-        const QString& object,
-        const QString& type,
-        const QString& name,
-        bool assignDefault = false);
-    int addItem(int position, const QString& object, const QString& type);
-    void addItemToRuntime(lv::QmlEditFragment* edit, const QString& type, QObject* currentApp = nullptr);
-    void updateRuntimeBindings(QObject* obj);
-
-    // Scopes
-
-    void newDocumentScopeReady(const QString& path, DocumentQmlScope::Ptr documentScope);
-    void newProjectScopeReady();
-    void updateScope();
-
-signals:
-
-private:
-    void rehighlightSection(int start, int end);
-    void resetProjectQmlExtension();
-
-    void suggestionsForGlobalQmlContext(
-        const QmlCompletionContext& context,
-        QList<CodeCompletionSuggestion>& suggestions
-    );
-
-    void suggestionsForImport(
-        const QmlCompletionContext& context,
-        QList<CodeCompletionSuggestion>& suggestions
-    );
-    void suggestionsForStringImport(
-        const QString &enteredPath,
-        QList<CodeCompletionSuggestion>& suggestions,
-        QString &filter
-    );
-    void suggestionsForRecursiveImport(
-        int index,
-        const QString &dir,
-        const QStringList& expression,
-        QList<CodeCompletionSuggestion>& suggestions
-    );
-
-    void suggestionsForValueObject(
-        const DocumentQmlObject& object,
-        QList<CodeCompletionSuggestion>& suggestions,
-        bool extractProperties,
-        bool extractFunctions,
-        bool extractSlots,
-        bool extractSignals
-    );
-
-    void suggestionsForNamespaceTypes(
-        const QString& typeNameSpace,
-        QList<CodeCompletionSuggestion>& suggestions
-    );
-    void suggestionsForNamespaceImports(
-        QList<CodeCompletionSuggestion>& suggestions
-    );
-    void suggestionsForDocumentsIds(
-        QList<CodeCompletionSuggestion>& suggestions
-    );
-
-    void suggestionsForLeftBind(
-        const QmlCompletionContext& context,
-        int cursorPosition,
-        QList<CodeCompletionSuggestion>& suggestions
-    );
-    void suggestionsForRightBind(
-        const QmlCompletionContext& context,
-        int cursorPosition,
-        QList<CodeCompletionSuggestion>& suggestions
-    );
-    void suggestionsForLeftSignalBind(
-        const QmlCompletionContext& context,
-        int cursorPosition,
-        QList<CodeCompletionSuggestion>& suggestions
-    );
-
-    QString extractQuotedString(const QTextCursor& cursor) const;
-
-    QString getBlockIndent(const QTextBlock& bl);
-    bool isBlockEmptySpace(const QTextBlock& bl);
-
-    QTextDocument*      m_target;
-    QmlJsHighlighter*   m_highlighter;
-    QmlJsSettings*      m_settings;
-    QQmlEngine*         m_engine;
-    QmlCompletionContextFinder* m_completionContextFinder;
-
-    ProjectDocument*       m_document;
-
-    bool                   m_newScope;
-    QTimer                 m_scopeTimer;
-
-    QLinkedList<QmlEditFragment*> m_edits; // opened palettes
-    QmlEditFragment*              m_editingFragment; // editing fragment
-
-    QScopedPointer<CodeQmlHandlerPrivate> d_ptr;
-
-    Q_DECLARE_PRIVATE(CodeQmlHandler)
-};
-
-/// \brief Returns the settings associated with this object.
-inline QmlJsSettings *CodeQmlHandler::settings(){
-    return m_settings;
-}
-
-}// namespace
-
-#endif // LVCODEQMLHANDLER_H
+/****************************************************************************
+**
+** Copyright (C) 2014-2018 Dinu SV.
+** (contact: mail@dinusv.com)
+** This file is part of Live CV Application.
+**
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPLv3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl.html.
+**
+****************************************************************************/
+
+#ifndef LVCODEQMLHANDLER_H
+#define LVCODEQMLHANDLER_H
+
+#include "live/lveditqmljsglobal.h"
+#include "live/abstractcodehandler.h"
+#include "live/projectdocument.h"
+#include "live/documentqmlscope.h"
+#include "live/projectqmlscope.h"
+#include "live/qmldeclaration.h"
+#include "live/lockedfileiosession.h"
+#include "live/viewengine.h"
+#include "live/settings.h"
+#include "live/palettelist.h"
+
+#include <QTimer>
+#include <QTextCursor>
+#include <QQmlListProperty>
+
+class QQmlEngine;
+
+namespace lv{
+
+class ProjectQmlScanner;
+class ProjectQmlExtension;
+class PluginInfoExtractor;
+
+class QmlCursorInfo;
+class QmlEditFragment;
+class QmlJsHighlighter;
+class QmlJsSettings;
+class QmlAddContainer;
+class QmlCompletionContextFinder;
+class QmlCompletionContext;
+
+class CodeQmlHandlerPrivate;
+class LV_EDITQMLJS_EXPORT CodeQmlHandler : public AbstractCodeHandler{
+
+    Q_OBJECT
+    Q_DISABLE_COPY(CodeQmlHandler)
+
+    friend class ProjectQmlExtension;
+
+public:
+    explicit CodeQmlHandler(
+        ViewEngine* engine,
+        Project* project,
+        QmlJsSettings *settings,
+        ProjectQmlExtension* projectHandler,
+        DocumentHandler* handler = 0
+    );
+    ~CodeQmlHandler();
+
+    void assistCompletion(
+        const QTextCursor& cursor,
+        const QChar& insertion,
+        bool manuallyTriggered,
+        CodeCompletionModel* model,
+        QTextCursor& cursorChange
+    ) Q_DECL_OVERRIDE;
+    void setDocument(ProjectDocument* document) Q_DECL_OVERRIDE;
+    AbstractCodeHandler::ContentsTrigger documentContentsChanged(int position, int charsRemoved, int charsAdded) Q_DECL_OVERRIDE;
+    void rehighlightBlock(const QTextBlock& block) Q_DECL_OVERRIDE;
+    QPair<int, int> contextBlock(int position) Q_DECL_OVERRIDE;
+    void aboutToDelete() Q_DECL_OVERRIDE;
+
+    QList<lv::QmlDeclaration::Ptr> getDeclarations(const QTextCursor& cursor);
+    bool findDeclarationValue(int position, int length, int& valuePosition, int& valueEnd);
+    QmlEditFragment* createInjectionChannel(QmlDeclaration::Ptr property, QObject* runtime);
+
+    bool addEditingFragment(QmlEditFragment *edit);
+    void removeEditingFragment(QmlEditFragment* edit);
+
+    QmlJsSettings* settings();
+
+    QmlEditFragment* findEditFragment(CodePalette* palette);
+    QmlEditFragment* findEditFragmentIn(QmlEditFragment *parent, CodePalette* palette);
+
+public slots:
+    // Palette and binding management
+
+    lv::QmlCursorInfo* cursorInfo(int position, int length);
+    lv::QmlEditFragment* openConnection(int position, QObject *currentApp = nullptr);
+    lv::QmlEditFragment* openNestedConnection(lv::QmlEditFragment* edit, int position, QObject* currentApp = nullptr);
+    void removeConnection(lv::QmlEditFragment* edit);
+
+    lv::PaletteList *findPalettes(int position, bool unrepeated = false);
+    lv::CodePalette* openPalette(lv::QmlEditFragment* fragment, lv::PaletteList* palette, int index);
+    lv::QmlEditFragment* removePalette(lv::CodePalette* palette);
+
+    lv::CodePalette* openBinding(lv::QmlEditFragment* edit, lv::PaletteList* paletteList, int index);
+    void closeBinding(int position, int length);
+
+    bool isForAnObject(lv::QmlEditFragment* palette);
+
+    void frameEdit(QQuickItem *box, lv::QmlEditFragment* palette);
+    void removeEditFrame(QQuickItem* box);
+    void resizedEditFrame(QQuickItem* box);
+
+    // Direct editing management
+
+    lv::CodePalette *edit(lv::QmlEditFragment* ef);
+    void cancelEdit();
+
+    // Add Property Management
+
+    lv::QmlAddContainer* getAddOptions(int position);
+    int addProperty(
+        int position,
+        const QString& object,
+        const QString& type,
+        const QString& name,
+        bool assignDefault = false);
+    int addItem(int position, const QString& object, const QString& type);
+    void addItemToRuntime(lv::QmlEditFragment* edit, const QString& type, QObject* currentApp = nullptr);
+    void updateRuntimeBindings(QObject* obj);
+
+    // Scopes
+
+    void newDocumentScopeReady(const QString& path, DocumentQmlScope::Ptr documentScope);
+    void newProjectScopeReady();
+    void updateScope();
+
+signals:
+
+private:
+    void rehighlightSection(int start, int end);
+    void resetProjectQmlExtension();
+
+    void suggestionsForGlobalQmlContext(
+        const QmlCompletionContext& context,
+        QList<CodeCompletionSuggestion>& suggestions
+    );
+
+    void suggestionsForImport(
+        const QmlCompletionContext& context,
+        QList<CodeCompletionSuggestion>& suggestions
+    );
+    void suggestionsForStringImport(
+        const QString &enteredPath,
+        QList<CodeCompletionSuggestion>& suggestions,
+        QString &filter
+    );
+    void suggestionsForRecursiveImport(
+        int index,
+        const QString &dir,
+        const QStringList& expression,
+        QList<CodeCompletionSuggestion>& suggestions
+    );
+
+    void suggestionsForValueObject(
+        const DocumentQmlObject& object,
+        QList<CodeCompletionSuggestion>& suggestions,
+        bool extractProperties,
+        bool extractFunctions,
+        bool extractSlots,
+        bool extractSignals
+    );
+
+    void suggestionsForNamespaceTypes(
+        const QString& typeNameSpace,
+        QList<CodeCompletionSuggestion>& suggestions
+    );
+    void suggestionsForNamespaceImports(
+        QList<CodeCompletionSuggestion>& suggestions
+    );
+    void suggestionsForDocumentsIds(
+        QList<CodeCompletionSuggestion>& suggestions
+    );
+
+    void suggestionsForLeftBind(
+        const QmlCompletionContext& context,
+        int cursorPosition,
+        QList<CodeCompletionSuggestion>& suggestions
+    );
+    void suggestionsForRightBind(
+        const QmlCompletionContext& context,
+        int cursorPosition,
+        QList<CodeCompletionSuggestion>& suggestions
+    );
+    void suggestionsForLeftSignalBind(
+        const QmlCompletionContext& context,
+        int cursorPosition,
+        QList<CodeCompletionSuggestion>& suggestions
+    );
+
+    QString extractQuotedString(const QTextCursor& cursor) const;
+
+    QString getBlockIndent(const QTextBlock& bl);
+    bool isBlockEmptySpace(const QTextBlock& bl);
+
+    QTextDocument*      m_target;
+    QmlJsHighlighter*   m_highlighter;
+    QmlJsSettings*      m_settings;
+    QQmlEngine*         m_engine;
+    QmlCompletionContextFinder* m_completionContextFinder;
+
+    ProjectDocument*       m_document;
+
+    bool                   m_newScope;
+    QTimer                 m_scopeTimer;
+
+    QLinkedList<QmlEditFragment*> m_edits; // opened palettes
+    QmlEditFragment*              m_editingFragment; // editing fragment
+
+    QScopedPointer<CodeQmlHandlerPrivate> d_ptr;
+
+    Q_DECLARE_PRIVATE(CodeQmlHandler)
+};
+
+/// \brief Returns the settings associated with this object.
+inline QmlJsSettings *CodeQmlHandler::settings(){
+    return m_settings;
+}
+
+}// namespace
+
+#endif // LVCODEQMLHANDLER_H
diff --git a/lib/lveditqmljs/src/qmljshighlighter.cpp b/lib/lveditqmljs/src/qmljshighlighter.cpp
index cacbff4..6332e86 100644
--- a/lib/lveditqmljs/src/qmljshighlighter.cpp
+++ b/lib/lveditqmljs/src/qmljshighlighter.cpp
@@ -1,337 +1,342 @@
-/****************************************************************************
-**
-** Copyright (C) 2014-2018 Dinu SV.
-** (contact: mail@dinusv.com)
-** This file is part of Live CV Application.
-**
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPLv3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl.html.
-**
-****************************************************************************/
-
-#include "qmljshighlighter_p.h"
-#include "documentqmlvaluescanner_p.h"
-
-namespace lv{
-
-QmlJsHighlighter::QmlJsHighlighter(QmlJsSettings* settings, DocumentHandler* handler, QTextDocument *parent)
-    : QSyntaxHighlighter(parent)
-    , m_handler(handler)
-    , m_settings(settings)
-{
-}
-
-// Walks through ab.bc.cd to find whether it preceedes a colon or an opening brace
-// depending on the case, this can be an qml type or a qml property
-// Anything else is discarded
-QmlJsHighlighter::LookAheadType QmlJsHighlighter::lookAhead(
-        const QString& text,
-        const QList<QmlJS::Token> &tokens,
-        QList<QmlJS::Token>::ConstIterator it,
-        int state)
-{
-    bool identifierExpected = false;
-    while ( it != tokens.end() ){
-        const QmlJS::Token& tk = *it;
-        if ( tk.is(QmlJS::Token::Colon) ){
-            return QmlJsHighlighter::Property;
-        } else if ( tk.is(QmlJS::Token::LeftBrace) ){
-            return QmlJsHighlighter::Type;
-        } else if ( tk.is(QmlJS::Token::Identifier ) ){
-            if ( !identifierExpected ){
-                if ( tk.length == 2 && text.mid(tk.begin(), tk.length) == "on" )
-                     return QmlJsHighlighter::Type;
-
-                return QmlJsHighlighter::Unknown;
-            }
-            identifierExpected = false;
-        } else if ( tk.is(QmlJS::Token::Dot) ){
-            identifierExpected = true;
-        } else if ( tk.isNot(QmlJS::Token::Comment) ){
-            return QmlJsHighlighter::Unknown;
-        }
-        ++it;
-    }
-
-    QTextBlock bl = currentBlock().next();
-    while ( bl.isValid() ){
-        QmlJS::Scanner scn;
-        QList<QmlJS::Token> tks = scn(bl.text(), state);
-        state = scn.state();
-        it = tks.begin();
-
-        while ( it != tks.end() ){
-            const QmlJS::Token& tk = *it;
-            if ( tk.is(QmlJS::Token::Colon) ){
-                return QmlJsHighlighter::Property;
-            } else if ( tk.is(QmlJS::Token::LeftBrace) ){
-                return QmlJsHighlighter::Type;
-            } else if ( tk.is(QmlJS::Token::Identifier ) ){
-                if ( !identifierExpected ){
-                    if ( tk.length == 2 && text.mid(tk.begin(), tk.length) == "on" )
-                         return QmlJsHighlighter::Type;
-
-                    return QmlJsHighlighter::Unknown;
-                }
-                identifierExpected = false;
-            } else if ( tk.is(QmlJS::Token::Dot) ){
-                identifierExpected = true;
-            } else if ( tk.isNot(QmlJS::Token::Comment) ){
-                return QmlJsHighlighter::Unknown;
-            }
-            ++it;
-        }
-
-        bl = bl.next();
-    }
-
-    return QmlJsHighlighter::Unknown;
-}
-
-void QmlJsHighlighter::collapse(const QTextBlock &tb, int &numLines, QString &replacement){
-    int blockState   = tb.previous().userState();
-
-    bool prevSectionExceeded = (blockState >> 4) & 1;
-    int bracketLevel         = blockState >> 5;
-    int state                = blockState & 15;
-
-
-    if (blockState < 0) {
-        prevSectionExceeded = false;
-        bracketLevel        = 0;
-        state               = QmlJS::Scanner::Normal;
-    }
-
-    QmlJS::Scanner scanner;
-    QList<QmlJS::Token> tokens = scanner(tb.text(), state);
-    QList<QmlJS::Token>::iterator it = tokens.begin();
-    while ( it != tokens.end() ){
-        QmlJS::Token& tk = *it;
-        if ( tk.kind == QmlJS::Token::LeftBrace ){
-            QTextBlock bScan = tb;
-            if ( DocumentQmlValueScanner::getBlockEnd(bScan, tb.position() + tk.end()) == 0 )
-            {
-                numLines = tb.document()->blockCount() - tb.blockNumber();
-            } else {
-
-                numLines = bScan.blockNumber() - tb.blockNumber();
-            }
-            replacement = "{ ... }";
-
-            return;
-        }
-        ++it;
-    }
-}
-
-void QmlJsHighlighter::highlightBlock(const QString &text){
-    QList<int> bracketPositions;
-    int blockState   = previousBlockState();
-
-    bool prevSectionExceeded = (blockState >> 4) & 1;
-    int bracketLevel         = blockState >> 5;
-    int state                = blockState & 15;
-
-
-    if (blockState < 0) {
-        prevSectionExceeded = false;
-        bracketLevel        = 0;
-        state               = QmlJS::Scanner::Normal;
-    }
-
-    QmlJsSettings& settings = *m_settings;
-
-    QmlJS::Scanner scanner;
-    QList<QmlJS::Token> tokens = scanner(text, state);
-    state = scanner.state();
-
-    lv::ProjectDocumentBlockData *blockData =
-            reinterpret_cast<lv::ProjectDocumentBlockData*>(currentBlock().userData());
-    if (!blockData) {
-        blockData = new lv::ProjectDocumentBlockData;
-        blockData->setCollapse(lv::ProjectDocumentBlockData::NoCollapse, &QmlJsHighlighter::collapse);
-        currentBlock().setUserData(blockData);
-    } else {
-        blockData->resetCollapseParams();
-    }
-
-    QList<QmlJS::Token>::iterator it = tokens.begin();
-    while ( it != tokens.end() ){
-        QmlJS::Token& tk = *it;
-        switch(tk.kind){
-        case QmlJS::Token::Keyword:
-            setFormat(tk.begin(), tk.length, settings[QmlJsSettings::Keyword]);
-            break;
-        case QmlJS::Token::Identifier:{
-            QString tktext = text.mid(tk.begin(), tk.length);
-            if ( m_knownIds.contains(tktext) ){
-                setFormat(tk.begin(), tk.length, settings[QmlJsSettings::Identifier]);
-            } else if ( tktext == "true" || tktext == "false" ){
-                setFormat(tk.begin(), tk.length, settings[QmlJsSettings::Keyword]);
-            } else {
-                QList<QmlJS::Token>::iterator lait = it;
-                QmlJsHighlighter::LookAheadType la = lookAhead(text, tokens, ++lait, state);
-                if ( la == QmlJsHighlighter::Property )
-                    setFormat(tk.begin(), tk.length, settings[QmlJsSettings::QmlProperty]);
-                else if ( la == QmlJsHighlighter::Type )
-                    setFormat(tk.begin(), tk.length, settings[QmlJsSettings::QmlType]);
-            }
-            break;
-        }
-        case QmlJS::Token::String:
-            setFormat(tk.begin(), tk.length, settings[QmlJsSettings::String]);
-            break;
-        case QmlJS::Token::Comment:
-            setFormat(tk.begin(), tk.length, settings[QmlJsSettings::Comment]);
-            break;
-        case QmlJS::Token::Number:
-            setFormat(tk.begin(), tk.length, settings[QmlJsSettings::Number]);
-            break;
-        case QmlJS::Token::LeftParenthesis:
-        case QmlJS::Token::RightParenthesis:
-            break;
-        case QmlJS::Token::LeftBrace:
-            blockData->setCollapse(lv::ProjectDocumentBlockData::Collapse, &QmlJsHighlighter::collapse);
-            blockData->setStateChangeFlag(true);
-            document()->markContentsDirty(currentBlock().position(), currentBlock().length());
-            break;
-        case QmlJS::Token::RightBrace:
-        case QmlJS::Token::LeftBracket:
-        case QmlJS::Token::RightBracket:
-        case QmlJS::Token::EndOfFile:
-            break;
-        case QmlJS::Token::Semicolon:
-        case QmlJS::Token::Colon:
-        case QmlJS::Token::Comma:
-        case QmlJS::Token::Dot:
-        case QmlJS::Token::Delimiter:
-            setFormat(tk.begin(), tk.length, settings[QmlJsSettings::Operator]);
-            break;
-        case QmlJS::Token::RegExp:
-            setFormat(tk.begin(), tk.length, settings[QmlJsSettings::String]);
-            break;
-        }
-
-
-        ++it;
-    }
-
-    blockData->m_exceededSections.clear();
-
-    if (!bracketPositions.isEmpty()) {
-        blockData->bracketPositions = bracketPositions;
-    }
-
-    bool exceeded = false;
-
-    if ( prevSectionExceeded ){
-        QTextBlock prevBlock = currentBlock().previous();
-        if ( prevBlock.isValid() && prevBlock.userData() ){
-            lv::ProjectDocumentBlockData *prevBlockData =
-                    reinterpret_cast<lv::ProjectDocumentBlockData*>(prevBlock.userData());
-
-            foreach (const ProjectDocumentSection::Ptr& section, prevBlockData->m_exceededSections ){
-                if ( section->isValid() ){
-                    highlightSection(section, blockData, exceeded);
-                }
-            }
-        }
-    }
-
-
-    if ( blockData ){
-        foreach(const ProjectDocumentSection::Ptr& section, blockData->m_sections ){
-            highlightSection(section, blockData, exceeded);
-        }
-    }
-
-    blockState = (state & 15) | (exceeded << 4) | (bracketLevel << 5);
-    setCurrentBlockState(blockState);
-}
-
-void QmlJsHighlighter::highlightSection(const ProjectDocumentSection::Ptr &section, ProjectDocumentBlockData *blockData, bool &exceeded){
-    QmlJsSettings& settings = *m_settings;
-    if ( section->type() == lv::QmlEditFragment::Section && section->userData() ){
-        lv::QmlEditFragment* def = reinterpret_cast<lv::QmlEditFragment*>(section->userData());
-        if ( def->bindingPalette() ){
-            int identifierBegin = def->declaration()->position() - currentBlock().position();
-            int identifierEnd   = identifierBegin + def->declaration()->identifierLength();
-
-            if ( identifierEnd > 0 ){
-                if ( identifierBegin < 0 )
-                    identifierBegin = 0;
-                setFormat(
-                    identifierBegin,
-                    identifierEnd - identifierBegin,
-                    settings[QmlJsSettings::QmlRuntimeBoundProperty]
-                );
-            }
-
-            int valueBegin = def->valuePosition() - currentBlock().position();
-            int valueEnd   = def->valuePosition() + def->declaration()->valueLength();
-
-            if ( valueBegin < 0 )
-                valueBegin = 0;
-
-            setFormat(valueBegin, valueEnd - valueBegin, settings[QmlJsSettings::QmlRuntimeModifiedValue]);
-            if ( valueEnd > currentBlock().position() + currentBlock().length() ){
-                exceeded = true;
-                blockData->m_exceededSections.append(section);
-            }
-        }
-        if ( def->totalPalettes() ){
-            int valueBegin = def->valuePosition() - currentBlock().position();
-            int valueEnd   = def->valuePosition() + def->valueLength();
-
-            if ( valueBegin < 0 )
-                valueBegin = 0;
-
-            setFormat(valueBegin, valueEnd - valueBegin, settings[QmlJsSettings::QmlEdit]);
-            if ( valueEnd > currentBlock().position() + currentBlock().length() ){
-                exceeded = true;
-                blockData->m_exceededSections.append(section);
-            }
-        }
-    }
-}
-
-QSet<QString> QmlJsHighlighter::m_knownIds = QmlJsHighlighter::createKnownIds();
-
-QSet<QString> QmlJsHighlighter::createKnownIds(){
-    QSet<QString> knownIds;
-
-    // built-in and other popular objects + properties
-    knownIds << "Object";
-    knownIds << "prototype";
-    knownIds << "property";
-    knownIds << "__parent__";
-    knownIds << "__proto__";
-    knownIds << "__defineGetter__";
-    knownIds << "__defineSetter__";
-    knownIds << "__lookupGetter__";
-    knownIds << "__lookupSetter__";
-    knownIds << "__noSuchMethod__";
-    knownIds << "Function";
-    knownIds << "String";
-    knownIds << "Array";
-    knownIds << "RegExp";
-    knownIds << "global";
-    knownIds << "NaN";
-    knownIds << "undefined";
-    knownIds << "Math";
-    knownIds << "import";
-    knownIds << "string";
-    knownIds << "int";
-    knownIds << "variant";
-    knownIds << "signal";
-
-    return knownIds;
-}
-
-}// namespace
-
+/****************************************************************************
+**
+** Copyright (C) 2014-2018 Dinu SV.
+** (contact: mail@dinusv.com)
+** This file is part of Live CV Application.
+**
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPLv3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl.html.
+**
+****************************************************************************/
+
+#include "qmljshighlighter_p.h"
+#include "documentqmlvaluescanner_p.h"
+
+namespace lv{
+
+QmlJsHighlighter::QmlJsHighlighter(QmlJsSettings* settings, DocumentHandler* handler, QTextDocument *parent)
+    : QSyntaxHighlighter(parent)
+    , m_handler(handler)
+    , m_settings(settings)
+{
+}
+
+// Walks through ab.bc.cd to find whether it preceedes a colon or an opening brace
+// depending on the case, this can be an qml type or a qml property
+// Anything else is discarded
+QmlJsHighlighter::LookAheadType QmlJsHighlighter::lookAhead(
+        const QString& text,
+        const QList<QmlJS::Token> &tokens,
+        QList<QmlJS::Token>::ConstIterator it,
+        int state)
+{
+    bool identifierExpected = false;
+    while ( it != tokens.end() ){
+        const QmlJS::Token& tk = *it;
+        if ( tk.is(QmlJS::Token::Colon) ){
+            return QmlJsHighlighter::Property;
+        } else if ( tk.is(QmlJS::Token::LeftBrace) ){
+            return QmlJsHighlighter::Type;
+        } else if ( tk.is(QmlJS::Token::Identifier ) ){
+            if ( !identifierExpected ){
+                if ( tk.length == 2 && text.mid(tk.begin(), tk.length) == "on" )
+                     return QmlJsHighlighter::Type;
+
+                return QmlJsHighlighter::Unknown;
+            }
+            identifierExpected = false;
+        } else if ( tk.is(QmlJS::Token::Dot) ){
+            identifierExpected = true;
+        } else if ( tk.isNot(QmlJS::Token::Comment) ){
+            return QmlJsHighlighter::Unknown;
+        }
+        ++it;
+    }
+
+    QTextBlock bl = currentBlock().next();
+    while ( bl.isValid() ){
+        QmlJS::Scanner scn;
+        QList<QmlJS::Token> tks = scn(bl.text(), state);
+        state = scn.state();
+        it = tks.begin();
+
+        while ( it != tks.end() ){
+            const QmlJS::Token& tk = *it;
+            if ( tk.is(QmlJS::Token::Colon) ){
+                return QmlJsHighlighter::Property;
+            } else if ( tk.is(QmlJS::Token::LeftBrace) ){
+                return QmlJsHighlighter::Type;
+            } else if ( tk.is(QmlJS::Token::Identifier ) ){
+                if ( !identifierExpected ){
+                    if ( tk.length == 2 && text.mid(tk.begin(), tk.length) == "on" )
+                         return QmlJsHighlighter::Type;
+
+                    return QmlJsHighlighter::Unknown;
+                }
+                identifierExpected = false;
+            } else if ( tk.is(QmlJS::Token::Dot) ){
+                identifierExpected = true;
+            } else if ( tk.isNot(QmlJS::Token::Comment) ){
+                return QmlJsHighlighter::Unknown;
+            }
+            ++it;
+        }
+
+        bl = bl.next();
+    }
+
+    return QmlJsHighlighter::Unknown;
+}
+
+void QmlJsHighlighter::collapse(const QTextBlock &tb, int &numLines, QString &replacement){
+    int blockState   = tb.previous().userState();
+
+    bool prevSectionExceeded = (blockState >> 4) & 1;
+    int bracketLevel         = blockState >> 5;
+    int state                = blockState & 15;
+
+
+    if (blockState < 0) {
+        prevSectionExceeded = false;
+        bracketLevel        = 0;
+        state               = QmlJS::Scanner::Normal;
+    }
+
+    QmlJS::Scanner scanner;
+    QList<QmlJS::Token> tokens = scanner(tb.text(), state);
+    QList<QmlJS::Token>::iterator it = tokens.begin();
+    while ( it != tokens.end() ){
+        QmlJS::Token& tk = *it;
+        if ( tk.kind == QmlJS::Token::LeftBrace ){
+            QTextBlock bScan = tb;
+            if ( DocumentQmlValueScanner::getBlockEnd(bScan, tb.position() + tk.end()) == 0 )
+            {
+                numLines = tb.document()->blockCount() - tb.blockNumber();
+            } else {
+
+                numLines = bScan.blockNumber() - tb.blockNumber();
+            }
+            replacement = "{ ... }";
+
+            return;
+        }
+        ++it;
+    }
+}
+
+void QmlJsHighlighter::highlightBlock(const QString &text){
+    QList<int> bracketPositions;
+    int blockState   = previousBlockState();
+
+    bool prevSectionExceeded = (blockState >> 4) & 1;
+    int bracketLevel         = blockState >> 5;
+    int state                = blockState & 15;
+
+
+    if (blockState < 0) {
+        prevSectionExceeded = false;
+        bracketLevel        = 0;
+        state               = QmlJS::Scanner::Normal;
+    }
+
+    QmlJsSettings& settings = *m_settings;
+
+    QmlJS::Scanner scanner;
+    QList<QmlJS::Token> tokens = scanner(text, state);
+    state = scanner.state();
+
+    lv::ProjectDocumentBlockData *blockData =
+            reinterpret_cast<lv::ProjectDocumentBlockData*>(currentBlock().userData());
+    if (!blockData) {
+        blockData = new lv::ProjectDocumentBlockData;
+        blockData->setCollapse(&QmlJsHighlighter::collapse);
+        blockData->setCollapsible(false);
+        currentBlock().setUserData(blockData);
+    } else {
+        blockData->resetCollapseParams();
+    }
+
+    QList<QmlJS::Token>::iterator it = tokens.begin();
+    while ( it != tokens.end() ){
+        QmlJS::Token& tk = *it;
+        switch(tk.kind){
+        case QmlJS::Token::Keyword:
+            setFormat(tk.begin(), tk.length, settings[QmlJsSettings::Keyword]);
+            break;
+        case QmlJS::Token::Identifier:{
+            QString tktext = text.mid(tk.begin(), tk.length);
+            if ( m_knownIds.contains(tktext) ){
+                setFormat(tk.begin(), tk.length, settings[QmlJsSettings::Identifier]);
+            } else if ( tktext == "true" || tktext == "false" ){
+                setFormat(tk.begin(), tk.length, settings[QmlJsSettings::Keyword]);
+            } else {
+                QList<QmlJS::Token>::iterator lait = it;
+                QmlJsHighlighter::LookAheadType la = lookAhead(text, tokens, ++lait, state);
+                if ( la == QmlJsHighlighter::Property )
+                    setFormat(tk.begin(), tk.length, settings[QmlJsSettings::QmlProperty]);
+                else if ( la == QmlJsHighlighter::Type )
+                    setFormat(tk.begin(), tk.length, settings[QmlJsSettings::QmlType]);
+            }
+            break;
+        }
+        case QmlJS::Token::String:
+            setFormat(tk.begin(), tk.length, settings[QmlJsSettings::String]);
+            break;
+        case QmlJS::Token::Comment:
+            setFormat(tk.begin(), tk.length, settings[QmlJsSettings::Comment]);
+            break;
+        case QmlJS::Token::Number:
+            setFormat(tk.begin(), tk.length, settings[QmlJsSettings::Number]);
+            break;
+        case QmlJS::Token::LeftParenthesis:
+        case QmlJS::Token::RightParenthesis:
+            break;
+        case QmlJS::Token::LeftBrace:
+            blockData->setCollapse(&QmlJsHighlighter::collapse);
+            blockData->setStateChangeFlag(true);
+            blockData->setCollapsible(true);
+            document()->markContentsDirty(currentBlock().position(), currentBlock().length());
+            break;
+        case QmlJS::Token::RightBrace:
+            if (blockData->isCollapsible())
+                blockData->setCollapsible(false);
+            break;
+        case QmlJS::Token::LeftBracket:
+        case QmlJS::Token::RightBracket:
+        case QmlJS::Token::EndOfFile:
+            break;
+        case QmlJS::Token::Semicolon:
+        case QmlJS::Token::Colon:
+        case QmlJS::Token::Comma:
+        case QmlJS::Token::Dot:
+        case QmlJS::Token::Delimiter:
+            setFormat(tk.begin(), tk.length, settings[QmlJsSettings::Operator]);
+            break;
+        case QmlJS::Token::RegExp:
+            setFormat(tk.begin(), tk.length, settings[QmlJsSettings::String]);
+            break;
+        }
+
+
+        ++it;
+    }
+
+    blockData->m_exceededSections.clear();
+
+    if (!bracketPositions.isEmpty()) {
+        blockData->bracketPositions = bracketPositions;
+    }
+
+    bool exceeded = false;
+
+    if ( prevSectionExceeded ){
+        QTextBlock prevBlock = currentBlock().previous();
+        if ( prevBlock.isValid() && prevBlock.userData() ){
+            lv::ProjectDocumentBlockData *prevBlockData =
+                    reinterpret_cast<lv::ProjectDocumentBlockData*>(prevBlock.userData());
+
+            foreach (const ProjectDocumentSection::Ptr& section, prevBlockData->m_exceededSections ){
+                if ( section->isValid() ){
+                    highlightSection(section, blockData, exceeded);
+                }
+            }
+        }
+    }
+
+
+    if ( blockData ){
+        foreach(const ProjectDocumentSection::Ptr& section, blockData->m_sections ){
+            highlightSection(section, blockData, exceeded);
+        }
+    }
+
+    blockState = (state & 15) | (exceeded << 4) | (bracketLevel << 5);
+    setCurrentBlockState(blockState);
+}
+
+void QmlJsHighlighter::highlightSection(const ProjectDocumentSection::Ptr &section, ProjectDocumentBlockData *blockData, bool &exceeded){
+    QmlJsSettings& settings = *m_settings;
+    if ( section->type() == lv::QmlEditFragment::Section && section->userData() ){
+        lv::QmlEditFragment* def = reinterpret_cast<lv::QmlEditFragment*>(section->userData());
+        if ( def->bindingPalette() ){
+            int identifierBegin = def->declaration()->position() - currentBlock().position();
+            int identifierEnd   = identifierBegin + def->declaration()->identifierLength();
+
+            if ( identifierEnd > 0 ){
+                if ( identifierBegin < 0 )
+                    identifierBegin = 0;
+                setFormat(
+                    identifierBegin,
+                    identifierEnd - identifierBegin,
+                    settings[QmlJsSettings::QmlRuntimeBoundProperty]
+                );
+            }
+
+            int valueBegin = def->valuePosition() - currentBlock().position();
+            int valueEnd   = def->valuePosition() + def->declaration()->valueLength();
+
+            if ( valueBegin < 0 )
+                valueBegin = 0;
+
+            setFormat(valueBegin, valueEnd - valueBegin, settings[QmlJsSettings::QmlRuntimeModifiedValue]);
+            if ( valueEnd > currentBlock().position() + currentBlock().length() ){
+                exceeded = true;
+                blockData->m_exceededSections.append(section);
+            }
+        }
+        if ( def->totalPalettes() ){
+            int valueBegin = def->valuePosition() - currentBlock().position();
+            int valueEnd   = def->valuePosition() + def->valueLength();
+
+            if ( valueBegin < 0 )
+                valueBegin = 0;
+
+            setFormat(valueBegin, valueEnd - valueBegin, settings[QmlJsSettings::QmlEdit]);
+            if ( valueEnd > currentBlock().position() + currentBlock().length() ){
+                exceeded = true;
+                blockData->m_exceededSections.append(section);
+            }
+        }
+    }
+}
+
+QSet<QString> QmlJsHighlighter::m_knownIds = QmlJsHighlighter::createKnownIds();
+
+QSet<QString> QmlJsHighlighter::createKnownIds(){
+    QSet<QString> knownIds;
+
+    // built-in and other popular objects + properties
+    knownIds << "Object";
+    knownIds << "prototype";
+    knownIds << "property";
+    knownIds << "__parent__";
+    knownIds << "__proto__";
+    knownIds << "__defineGetter__";
+    knownIds << "__defineSetter__";
+    knownIds << "__lookupGetter__";
+    knownIds << "__lookupSetter__";
+    knownIds << "__noSuchMethod__";
+    knownIds << "Function";
+    knownIds << "String";
+    knownIds << "Array";
+    knownIds << "RegExp";
+    knownIds << "global";
+    knownIds << "NaN";
+    knownIds << "undefined";
+    knownIds << "Math";
+    knownIds << "import";
+    knownIds << "string";
+    knownIds << "int";
+    knownIds << "variant";
+    knownIds << "signal";
+
+    return knownIds;
+}
+
+}// namespace
+
diff --git a/plugins/editor/qml/Editor.qml b/plugins/editor/qml/Editor.qml
index 7ba574a..4e26e57 100644
--- a/plugins/editor/qml/Editor.qml
+++ b/plugins/editor/qml/Editor.qml
@@ -556,9 +556,8 @@ Rectangle{
                 textFormat: NewTextEdit.PlainText
 
                 wrapMode: NewTextEdit.NoWrap
-                height : Math.max( flick.height - 10, paintedHeight + 15)
-                width : Math.max( flick.width - 10, paintedWidth + 15)
-
+                height: paintedHeight
+                width: paintedWidth
                 readOnly: editor.document === null || editor.document.isMonitored
 
                 Keys.onPressed: {
diff --git a/plugins/editor/qml/WindowControls.qml b/plugins/editor/qml/WindowControls.qml
index ad66201..91a3e40 100644
--- a/plugins/editor/qml/WindowControls.qml
+++ b/plugins/editor/qml/WindowControls.qml
@@ -1,48 +1,53 @@
-import QtQuick 2.5
-import QtQuick.Dialogs 1.2
-import QtQuick.Controls 1.2
-
-QtObject{
-    property FileDialog saveFileDialog: null
-    property FileDialog openFileDialog: null
-    property FileDialog openDirDialog: null
-    property var messageDialog: null
-    property QtObject runSpace: null
-    property Item editSpace: null
-    property Timer createTimer: null
-    property Component paletteBoxFactory: null
-    property Item activePane : null
-    property Item activeItem : null
-    property Item navEditor: null
-    property int codingMode: null
-    property int prevWindowState: null
-
-    function setActiveItem(item, pane){
-        activeItem = item
-        var p = pane ? pane : item
-        while ( p !== null ){
-            if ( p.objectName === 'editor' || p.objectName === 'project' || p.objectName === 'viewer' ){
-                activePane = p
-                return
-            }
-            p = p.parent
-        }
-    }
-
-    function activateItem(item, pane){
-        if ( activeItem && activeItem !== item ){
-            activeItem.focus = false
-        }
-
-        activeItem = item
-        activeItem.forceActiveFocus()
-        var p = pane ? pane : item
-        while ( p !== null ){
-            if ( p.objectName === 'editor' || p.objectName === 'project' || p.objectName === 'viewer' ){
-                activePane = p
-                return
-            }
-            p = p.parent
-        }
-    }
-}
+import QtQuick 2.5
+import QtQuick.Dialogs 1.2
+import QtQuick.Controls 1.2
+
+QtObject{
+    property FileDialog saveFileDialog: null
+    property FileDialog openFileDialog: null
+    property FileDialog openDirDialog: null
+    property var messageDialog: null
+    property QtObject runSpace: null
+    property Item editSpace: null
+    property Timer createTimer: null
+    property Component paletteBoxFactory: null
+    property Item activePane : null
+    property Item activeItem : null
+    property Item navEditor: null
+    property int codingMode: null
+    property int prevWindowState: null
+    property var createWindow: null
+
+    function setActiveItem(item, pane){
+        activeItem = item
+        var p = pane ? pane : item
+        while ( p !== null ){
+            if ( p.objectName === 'editor' || p.objectName === 'project' || p.objectName === 'viewer' ){
+                activePane = p
+                return
+            }
+            p = p.parent
+        }
+    }
+
+    function activateItem(item, pane){
+        if ( activeItem && activeItem !== item ){
+            activeItem.focus = false
+        }
+
+        activeItem = item
+        activeItem.forceActiveFocus()
+        var p = pane ? pane : item
+        while ( p !== null ){
+            if ( p.objectName === 'editor' || p.objectName === 'project' || p.objectName === 'viewer' ){
+                activePane = p
+                return
+            }
+            p = p.parent
+        }
+    }
+
+    function createNewWindow(){
+        return createWindow();
+    }
+}
diff --git a/plugins/lcvcore/src/qmatext.h b/plugins/lcvcore/src/qmatext.h
index bacca75..a55b766 100644
--- a/plugins/lcvcore/src/qmatext.h
+++ b/plugins/lcvcore/src/qmatext.h
@@ -1,61 +1,62 @@
-/****************************************************************************
-**
-** Copyright (C) 2014-2018 Dinu SV.
-** (contact: mail@dinusv.com)
-** This file is part of Live CV Application.
-**
-** GNU Lesser General Public License Usage
-** This file may be used under the terms of the GNU Lesser
-** General Public License version 3 as published by the Free Software
-** Foundation and appearing in the file LICENSE.LGPLv3 included in the
-** packaging of this file. Please review the following information to
-** ensure the GNU Lesser General Public License version 3 requirements
-** will be met: https://www.gnu.org/licenses/lgpl.html.
-**
-****************************************************************************/
-
-#ifndef QMAT_EXT_H
-#define QMAT_EXT_H
-
-#include "qmat.h"
-#include "live/visuallog.h"
-#include "live/mlnode.h"
-
-namespace lv{ namespace ml{
-
-template<>
-inline void serialize<QMat>(const QMat& v, MLNode& node){
-    node = {
-        {"cols", v.data().cols},
-        {"rows", v.data().rows},
-        {"channels", v.data().channels()},
-        {"depth", v.data().depth()},
-        {"data", MLNode::BytesType(v.data().data, v.data().total() * v.data().elemSize())}
-    };
-}
-
-template<>
-inline void deserialize<QMat>(const MLNode& node, QMat& v){
-    *v.cvMat() = cv::Mat(
-        cv::Size(node["cols"].asInt(), node["rows"].asInt()),
-        CV_MAKETYPE(node["depth"].asInt(), node["channels"].asInt()),
-        cv::Mat::AUTO_STEP
-    );
-    lv::MLNode::BytesType bt = node["data"].asBytes();
-    memcpy(v.cvMat()->data, bt.data(), bt.size());
-}
-
-} // namespace ml
-
-class QmlObjectList;
-QmlObjectList* createMatList();
-
-inline lv::VisualLog& operator << (lv::VisualLog& vl, const QMat& v){
-    vl.asObject("QMat", v);
-    vl.asView("lcvcore/MatLog.qml", [&v](){ return QVariant::fromValue(v.clone()); });
-    return vl << "Mat[" << v.data().cols << "x" << v.data().rows << "," << v.data().channels() << "]";
-}
-
-} // namespace lv
-
-#endif // QMAT_EXT_H
+/****************************************************************************
+**
+** Copyright (C) 2014-2018 Dinu SV.
+** (contact: mail@dinusv.com)
+** This file is part of Live CV Application.
+**
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPLv3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl.html.
+**
+****************************************************************************/
+
+#ifndef QMAT_EXT_H
+#define QMAT_EXT_H
+
+#include "qmat.h"
+#include "live/visuallog.h"
+#include "live/mlnode.h"
+#include "qlcvcoreglobal.h"
+
+namespace lv{ namespace ml{
+
+template<>
+inline void serialize<QMat>(const QMat& v, MLNode& node){
+    node = {
+        {"cols", v.data().cols},
+        {"rows", v.data().rows},
+        {"channels", v.data().channels()},
+        {"depth", v.data().depth()},
+        {"data", MLNode::BytesType(v.data().data, v.data().total() * v.data().elemSize())}
+    };
+}
+
+template<>
+inline void deserialize<QMat>(const MLNode& node, QMat& v){
+    *v.cvMat() = cv::Mat(
+        cv::Size(node["cols"].asInt(), node["rows"].asInt()),
+        CV_MAKETYPE(node["depth"].asInt(), node["channels"].asInt()),
+        cv::Mat::AUTO_STEP
+    );
+    lv::MLNode::BytesType bt = node["data"].asBytes();
+    memcpy(v.cvMat()->data, bt.data(), bt.size());
+}
+
+} // namespace ml
+
+class QmlObjectList;
+Q_LCVCORE_EXPORT QmlObjectList* createMatList();
+
+inline lv::VisualLog& operator << (lv::VisualLog& vl, const QMat& v){
+    vl.asObject("QMat", v);
+    vl.asView("lcvcore/MatLog.qml", [&v](){ return QVariant::fromValue(v.clone()); });
+    return vl << "Mat[" << v.data().cols << "x" << v.data().rows << "," << v.data().channels() << "]";
+}
+
+} // namespace lv
+
+#endif // QMAT_EXT_H
diff --git a/samples/editor/fragmenteditor.qml b/samples/editor/fragmenteditor.qml
index 897c20f..d957e6e 100644
--- a/samples/editor/fragmenteditor.qml
+++ b/samples/editor/fragmenteditor.qml
@@ -19,21 +19,12 @@ Item{
             fragmentEditor.document = project.openFile(project.path('fragmenteditor.qml'))
         }
     }
-/*    
-    DocumentFragment{
-        id: fragmentSelection
-        document: project.openFile(project.path('fragmenteditor.qml'))
-        lineStartIndex: staticLineIndex.item.start
-        onLineStartIndexChanged: staticLineIndex.item.start = lineStartIndex
-        lineEndIndex: staticLineIndex.item.end
-        onLineEndIndexChanged: staticLineIndex.item.end = lineEndIndex
-    }
-*/
+
     Editor{
         id: fragmentEditor
         anchors.left: parent.left
-        fragmentStart: 32
-        fragmentEnd: 41
+        fragmentStart: 33
+        fragmentEnd: 39
         height: 500
         width: 600
         windowControls: livecv.windowControls()
diff --git a/tests/unit/lveditortest/lveditortest.pro b/tests/unit/lveditortest/lveditortest.pro
new file mode 100644
index 0000000..48b421b
--- /dev/null
+++ b/tests/unit/lveditortest/lveditortest.pro
@@ -0,0 +1,16 @@
+TARGET   = lveditortest
+TEMPLATE = app
+QT      += qml quick testlib
+CONFIG  += console testcase
+
+linkLocalLibrary(lvbase, lvbase)
+linkLocalLibrary(lvview, lvview)
+linkLocalLibrary(lveditor,  lveditor)
+
+HEADERS += \
+    testrunner.h \
+    lvlinecontroltest.h
+
+SOURCES += \
+    main.cpp \
+    lvlinecontroltest.cpp
diff --git a/tests/unit/lveditortest/lvlinecontroltest.cpp b/tests/unit/lveditortest/lvlinecontroltest.cpp
new file mode 100644
index 0000000..fdaadee
--- /dev/null
+++ b/tests/unit/lveditortest/lvlinecontroltest.cpp
@@ -0,0 +1,163 @@
+#include "lvlinecontroltest.h"
+#include <QDebug>
+#include <QQmlEngine>
+
+Q_TEST_RUNNER_REGISTER(LvLineControlTest);
+
+using namespace lv;
+
+LvLineControlTest::LvLineControlTest(QObject *parent) : QObject(parent) {}
+
+void LvLineControlTest::initTestCase()
+{
+    m_lineControl = new LineControl;
+    m_blockHeight = 15;
+    m_lineControl->setBlockHeight(m_blockHeight);
+}
+
+
+void LvLineControlTest::addingSingleCollapse()
+{
+    m_lineControl->addCollapse(10, 3);
+    QCOMPARE(m_lineControl->sections().size(), 1);
+    auto section = m_lineControl->sections()[0];
+    QCOMPARE(section.type, LineControl::LineSection::Collapsed);
+    QCOMPARE(section.range, 4);
+    QCOMPARE(section.visibleRange, 1);
+    QCOMPARE(section.position, 10);
+    QCOMPARE(section.visiblePosition, 10);
+}
+
+void LvLineControlTest::addingSinglePalette()
+{
+    QQuickItem* item = new QQuickItem;
+    item->setHeight(55);
+    m_lineControl->addPalette(3, 2, item, 25, 45);
+    QCOMPARE(m_lineControl->sections().size(),2);
+    auto section1 = m_lineControl->sections()[0];
+    auto section2 = m_lineControl->sections()[1];
+    // confirm sortedness
+    QCOMPARE(section1.type, LineControl::LineSection::Palette);
+    QCOMPARE(section2.type, LineControl::LineSection::Collapsed);
+    QCOMPARE(section1.range, 2);
+    QCOMPARE(section1.visibleRange, 5);
+    // check offset of section2
+    QCOMPARE(section2.visiblePosition, 13);
+}
+
+void LvLineControlTest::closeCollapsed()
+{
+    m_lineControl->removeCollapse(10);
+    QCOMPARE(m_lineControl->sections().size(), 1);
+    auto section = m_lineControl->sections()[0];
+    QCOMPARE(section.type, LineControl::LineSection::Palette);
+}
+
+void LvLineControlTest::addACollapseAfterPalette()
+{
+    // to be used for the next test!
+    m_lineControl->addCollapse(100, 5);
+    QCOMPARE(m_lineControl->sections().size(), 2);
+    QCOMPARE(m_lineControl->sections()[1].type, LineControl::LineSection::Collapsed);
+
+    QCOMPARE(m_lineControl->sections()[0].type, LineControl::LineSection::Palette);
+    QCOMPARE(m_lineControl->sections()[1].visiblePosition, 103);
+}
+
+void LvLineControlTest::resizePalette()
+{
+    m_lineControl->sections()[0].palette->setHeight(100);
+    m_lineControl->resizePalette(m_lineControl->sections()[0].palette);
+    QCOMPARE(m_lineControl->sections()[0].visibleRange, 8);
+    QCOMPARE(m_lineControl->sections()[1].position, 100);
+    QCOMPARE(m_lineControl->sections()[1].visiblePosition, 106);
+}
+
+void LvLineControlTest::removePalette()
+{
+    auto ptr = m_lineControl->sections()[0].palette;
+    m_lineControl->removePalette(m_lineControl->sections()[0].palette);
+    delete ptr;
+    QCOMPARE(m_lineControl->sections().size(), 1);
+    QCOMPARE(m_lineControl->sections()[0].type, LineControl::LineSection::Collapsed);
+    QCOMPARE(m_lineControl->sections()[0].visiblePosition, 100);
+    QCOMPARE(m_lineControl->sections()[0].position, 100);
+}
+
+void LvLineControlTest::addLines()
+{
+    QQuickItem* item = new QQuickItem;
+    item->setHeight(70);
+    m_lineControl->addPalette(50, 2, item, 324, 400);
+
+
+    m_lineControl->setDirtyPos(60);
+    m_lineControl->deltaLines(5);
+    auto section1 = m_lineControl->sections()[0];
+    auto section2 = m_lineControl->sections()[1];
+
+    QCOMPARE(section1.position, 50);
+    QCOMPARE(section2.position, 105); // only the collapse shifted
+}
+
+void LvLineControlTest::removeLines()
+{
+    m_lineControl->setDirtyPos(40);
+    m_lineControl->deltaLines(-3);
+    auto section1 = m_lineControl->sections()[0];
+    auto section2 = m_lineControl->sections()[1];
+
+    QCOMPARE(section1.position, 47);
+    QCOMPARE(section2.position, 102); // both shifted back
+
+    QCOMPARE(section1.type, LineControl::LineSection::Palette);
+
+    clearLineControl();
+}
+
+void LvLineControlTest::checkVisibleWithNoSections()
+{
+    auto result = m_lineControl->visibleSections(10, 20);
+
+    QCOMPARE(result.size(), 1);
+    QCOMPARE(result[0].start, 10);
+    QCOMPARE(result[0].size, 11);
+    QCOMPARE(result[0].palette, nullptr);
+
+    m_lineControl->addCollapse(10, 4);
+}
+
+void LvLineControlTest::checkBeforeCollapsedSection()
+{
+    auto result = m_lineControl->visibleSections(5,7);
+
+    QCOMPARE(result.size(), 1);
+    QCOMPARE(result[0].start, 5);
+    QCOMPARE(result[0].size, 3);
+    QCOMPARE(result[0].palette, nullptr);
+
+}
+
+void LvLineControlTest::checkWithCollapsedSection()
+{
+    auto result = m_lineControl->visibleSections(9,19);
+    QCOMPARE(result.size(), 3);
+
+
+
+}
+
+
+
+
+
+void LvLineControlTest::cleanupTestCase()
+{
+    clearLineControl();
+    delete m_lineControl;
+}
+
+void LvLineControlTest::clearLineControl()
+{
+    m_lineControl->reset();
+}
diff --git a/tests/unit/lveditortest/lvlinecontroltest.h b/tests/unit/lveditortest/lvlinecontroltest.h
new file mode 100644
index 0000000..51efac2
--- /dev/null
+++ b/tests/unit/lveditortest/lvlinecontroltest.h
@@ -0,0 +1,41 @@
+#ifndef LVLINECONTROLTEST_H
+#define LVLINECONTROLTEST_H
+
+#include <QObject>
+#include "testrunner.h"
+#include "live/linecontrol.h"
+
+class LvLineControlTest : public QObject{
+
+    Q_OBJECT
+    Q_TEST_RUNNER_SUITE
+
+public:
+    explicit LvLineControlTest(QObject* parent = nullptr);
+    ~LvLineControlTest() {}
+private slots:
+    void initTestCase();
+    void addingSingleCollapse();
+    void addingSinglePalette();
+    void closeCollapsed();
+    void addACollapseAfterPalette();
+    void resizePalette();
+    void removePalette();
+    void addLines();
+    void removeLines();
+
+    void checkVisibleWithNoSections();
+    void checkBeforeCollapsedSection();
+    void checkWithCollapsedSection();
+
+    void cleanupTestCase();
+
+public slots:
+private:
+    void clearLineControl();
+
+    lv::LineControl* m_lineControl;
+    int m_blockHeight;
+};
+
+#endif // LVLINECONTROLTEST_H
diff --git a/tests/unit/lveditortest/main.cpp b/tests/unit/lveditortest/main.cpp
new file mode 100644
index 0000000..334d78a
--- /dev/null
+++ b/tests/unit/lveditortest/main.cpp
@@ -0,0 +1,22 @@
+#include <QCoreApplication>
+#include <QTest>
+#include <qqml.h>
+
+#include "testrunner.h"
+#include "lvlinecontroltest.h"
+#include <iostream>
+
+int main(int argc, char *argv[]){
+
+    QCoreApplication app(argc, argv);
+    app.setAttribute(Qt::AA_Use96Dpi, true);
+
+    int result = -1;
+    try {
+        result = lv::TestRunner::runTests(argc, argv);
+    } catch (std::exception e)
+    {
+        qDebug() << e.what();
+    }
+    return result;
+}
diff --git a/tests/unit/lveditortest/testrunner.h b/tests/unit/lveditortest/testrunner.h
new file mode 100644
index 0000000..b701fb9
--- /dev/null
+++ b/tests/unit/lveditortest/testrunner.h
@@ -0,0 +1,80 @@
+/****************************************************************************
+**
+** Copyright (C) 2014-2018 Dinu SV.
+** (contact: mail@dinusv.com)
+** This file is part of Live CV Application.
+**
+** GNU Lesser General Public License Usage
+** This file may be used under the terms of the GNU Lesser
+** General Public License version 3 as published by the Free Software
+** Foundation and appearing in the file LICENSE.LGPLv3 included in the
+** packaging of this file. Please review the following information to
+** ensure the GNU Lesser General Public License version 3 requirements
+** will be met: https://www.gnu.org/licenses/lgpl.html.
+**
+****************************************************************************/
+
+#ifndef LVTESTRUNNER_H
+#define LVTESTRUNNER_H
+
+#include "qglobal.h"
+#include <QObject>
+#include <QList>
+#include <QSharedPointer>
+#include <QTest>
+#include <iostream>
+
+namespace lv{
+
+class TestRunner{
+
+public:
+    static int registerTest(QObject* test);
+    static int runTests(int argc, char *argv[]);
+    static int runTest(int index, int argc, char* argv[]);
+    static int totalRegisteredTests();
+
+private:
+    static QList<QSharedPointer<QObject> >& tests();
+};
+
+inline int TestRunner::registerTest(QObject* test){
+    tests().append(QSharedPointer<QObject>(test));
+    return tests().size() - 1;
+}
+
+inline int TestRunner::runTests(int argc, char *argv[]){
+    int code = 0;
+    std::cout << "3";
+    for ( QList<QSharedPointer<QObject> >::iterator it = tests().begin(); it != tests().end(); ++it ){
+        code += QTest::qExec(it->data(), argc, argv);
+    }
+    return code;
+}
+
+inline int TestRunner::runTest(int index, int argc, char* argv[]){
+    if ( index > tests().size() )
+        return -1;
+    return QTest::qExec(tests()[index].data(), argc, argv);
+}
+
+
+inline int TestRunner::totalRegisteredTests(){
+    return tests().size();
+}
+
+inline QList<QSharedPointer<QObject> > &TestRunner::tests(){
+    static QList<QSharedPointer<QObject> > registeredTests;
+    return registeredTests;
+}
+
+}// namespace
+
+#define Q_TEST_RUNNER_SUITE \
+    public:\
+        static const int testIndex;
+
+#define Q_TEST_RUNNER_REGISTER(className) \
+    const int className::testIndex = lv::TestRunner::registerTest(new className)
+
+#endif // LVTESTRUNNER_H
diff --git a/tests/unit/unit.pro b/tests/unit/unit.pro
index 0bb9ace..e4d4a0d 100644
--- a/tests/unit/unit.pro
+++ b/tests/unit/unit.pro
@@ -1,8 +1,9 @@
-TEMPLATE = subdirs
-SUBDIRS += $$PWD/lvbasetest
-SUBDIRS += $$PWD/lvviewtest
-
-!isEmpty(BUILD_ELEMENTS){
-    SUBDIRS += $$PWD/lvelementstest
-}
-
+TEMPLATE = subdirs
+SUBDIRS += $$PWD/lvbasetest
+SUBDIRS += $$PWD/lvviewtest
+SUBDIRS += $$PWD/lveditortest
+
+!isEmpty(BUILD_ELEMENTS){
+    SUBDIRS += $$PWD/lvelementstest
+}
+
